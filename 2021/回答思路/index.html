<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="回答思路"><meta name="keywords" content=""><meta name="author" content="Summer"><meta name="copyright" content="Summer"><title>回答思路 | 阿七笔记</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.1.1'
} </script><meta name="generator" content="Hexo 5.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">重点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%93%E4%B8%9A%E5%8D%95%E8%AF%8D"><span class="toc-number">2.</span> <span class="toc-text">专业单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8EGC"><span class="toc-number">3.</span> <span class="toc-text">内存模型与GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC"><span class="toc-number">3.2.</span> <span class="toc-text">GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-GC"><span class="toc-number">3.3.</span> <span class="toc-text">Android GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E4%B8%8ECollection"><span class="toc-number">4.</span> <span class="toc-text">锁与Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%EF%BC%88monitorenter-monitorexit%E4%B8%8EACC-SYNCHRONIZED%E3%80%81%E4%B8%89%E7%A7%8D%E9%94%81%E3%80%81%E7%B1%BB%E9%94%81%E4%B8%8E%E5%AF%B9%E8%B1%A1%E9%94%81%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">Synchronized（monitorenter&#x2F;monitorexit与ACC_SYNCHRONIZED、三种锁、类锁与对象锁）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%EF%BC%88AQS%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">ReentrantLock（AQS、公平锁与非公平锁、共享模式和独占模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-number">4.3.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%EF%BC%88%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">volatile（可见性与指令重排）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap%EF%BC%88%E5%88%86%E6%AE%B5%E9%94%81-CAS-synchronized%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">ConcurrentHashMap（分段锁&#x2F;CAS + synchronized、红黑树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E3%80%81List%E3%80%81SparseArray"><span class="toc-number">4.6.</span> <span class="toc-text">Map、List、SparseArray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">线程（生命周期）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E3%80%815%E7%A7%8D%E5%86%85%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81AsyncTask%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">线程池（执行流程、5种内置线程池的区别、AsyncTask）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AsyncTask-%E4%B8%A4%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%AF%E4%BB%A5%E5%88%87%E6%8D%A2"><span class="toc-number">5.3.</span> <span class="toc-text">AsyncTask(两种线程池可以切换)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">6.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%883%E7%A7%8D%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">类加载器（3种）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88ReferenceQueue%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">软引用和弱引用（ReferenceQueue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E7%BD%AE%E4%B8%BA-null%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">强引用置为 null，会不会被回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%EF%BC%8Cfinally%EF%BC%8Cfinalize"><span class="toc-number">6.4.</span> <span class="toc-text">final，finally，finalize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%EF%BC%88%E9%95%BF%E5%BA%A6%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">String（长度）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">7.</span> <span class="toc-text">网络协议相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%EF%BC%88%E5%8C%BA%E5%88%AB%E3%80%81TLS%E6%8F%A1%E6%89%8B%E3%80%81%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">HTTP（区别、TLS握手、缓存）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Http1-1-%E5%92%8C-Http1-0-%E5%8F%8A-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.1.</span> <span class="toc-text">Http1.1 和 Http1.0 及 2.0 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Https-%E8%AF%B7%E6%B1%82%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">7.1.2.</span> <span class="toc-text">Https 请求慢的解决办法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSL-TLS%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">7.1.3.</span> <span class="toc-text">SSL&#x2F;TLS握手流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">7.1.4.</span> <span class="toc-text">缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-UDP%EF%BC%883%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%814%E6%AC%A1%E6%8C%A5%E6%89%8B%E3%80%81DNS%E8%AF%B7%E6%B1%82%E3%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">TCP&#x2F;UDP（3次握手、4次挥手、DNS请求、网络请求）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">7.2.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="toc-number">7.2.3.</span> <span class="toc-text">TCP 可靠传输原理实现（滑动窗口）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tcp-%E5%92%8C-Udp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.4.</span> <span class="toc-text">Tcp 和 Udp 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS"><span class="toc-number">7.2.5.</span> <span class="toc-text">DNS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmap%EF%BC%88%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98%E3%80%81Options%E3%80%81BitmapRegionDecoder%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">Bitmap（节省内存、Options、BitmapRegionDecoder）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="toc-number">8.0.1.</span> <span class="toc-text">Bitmap 占用内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%A1%86%E6%9E%B6"><span class="toc-number">9.</span> <span class="toc-text">图片框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Glide%EF%BC%88%E7%BC%93%E5%AD%98%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89"><span class="toc-number">9.0.1.</span> <span class="toc-text">Glide（缓存、生命周期）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco%EF%BC%88%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-number">9.0.2.</span> <span class="toc-text">Fresco（缓存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco-%E4%B8%8E-Glide-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">9.0.3.</span> <span class="toc-text">Fresco 与 Glide 的对比：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-ImageLoader-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">9.0.4.</span> <span class="toc-text">实现一个 ImageLoader 的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">9.0.5.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webview%E7%9B%B8%E5%85%B3%EF%BC%88%E5%AE%89%E5%85%A8%E3%80%81%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E3%80%81%E6%80%A7%E8%83%BD%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">webview相关（安全、调用方式、性能）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">10.1.</span> <span class="toc-text">安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">10.2.</span> <span class="toc-text">性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">应用启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AMS%E7%9B%B8%E5%85%B3"><span class="toc-number">11.1.</span> <span class="toc-text">AMS相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WMS%E7%9B%B8%E5%85%B3"><span class="toc-number">11.2.</span> <span class="toc-text">WMS相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">系统的启动过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View%E7%9B%B8%E5%85%B3%EF%BC%88%E7%BB%98%E5%88%B6%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81MeasureSpec%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">View相关（绘制、事件、MeasureSpec）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MeasureSpec%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">13.1.</span> <span class="toc-text">MeasureSpec的原理和计算规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder%E7%9B%B8%E5%85%B3%EF%BC%88binder%E8%83%8C%E6%99%AF%E3%80%81servicemanager%E3%80%81%E7%BB%86%E8%8A%82%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">binder相关（binder背景、servicemanager、细节）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">14.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BAbinder%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9D%A1%E4%BB%B6-%E5%BF%85%E9%A1%BB%E5%85%A8%E9%83%A8%E6%BB%A1%E8%B6%B3-%EF%BC%9A"><span class="toc-number">14.2.</span> <span class="toc-text">新建binder线程的条件(必须全部满足)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E7%9B%AE%E6%A0%87binder%EF%BC%9A"><span class="toc-number">14.3.</span> <span class="toc-text">如何找到目标binder：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E4%B8%8EbindService"><span class="toc-number">14.4.</span> <span class="toc-text">系统服务与bindService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ipc%E7%A7%8D%E7%B1%BB"><span class="toc-number">14.5.</span> <span class="toc-text">ipc种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">14.6.</span> <span class="toc-text">常见问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handler%E7%9B%B8%E5%85%B3"><span class="toc-number">15.</span> <span class="toc-text">handler相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-1"><span class="toc-number">15.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C%E6%B6%88%E6%81%AF%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">15.2.</span> <span class="toc-text">屏障消息使用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#idleHandler%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">15.3.</span> <span class="toc-text">idleHandler的使用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#native%E5%B1%82%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">15.4.</span> <span class="toc-text">native层的消息机制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">15.5.</span> <span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockCanary"><span class="toc-number">15.6.</span> <span class="toc-text">BlockCanary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerThread"><span class="toc-number">15.7.</span> <span class="toc-text">HandlerThread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntentService"><span class="toc-number">15.8.</span> <span class="toc-text">IntentService</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMS"><span class="toc-number">16.</span> <span class="toc-text">AMS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ANR"><span class="toc-number">16.1.</span> <span class="toc-text">ANR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ANR%E6%8E%92%E6%9F%A5"><span class="toc-number">16.2.</span> <span class="toc-text">ANR排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="toc-number">17.</span> <span class="toc-text">构建与安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%EF%BC%88%E6%B5%81%E7%A8%8B%E3%80%81app%E7%BB%84%E6%88%90%EF%BC%89"><span class="toc-number">17.1.</span> <span class="toc-text">打包流程（流程、app组成）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APK%E5%AE%89%E8%A3%85"><span class="toc-number">17.2.</span> <span class="toc-text">APK安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E4%BF%9D%E6%B4%BB%EF%BC%88%E4%BF%9D%E6%B4%BB%E3%80%81%E5%A4%8D%E6%B4%BB%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">Service保活（保活、复活）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%B4%BB%E6%96%B9%E6%A1%88"><span class="toc-number">18.1.</span> <span class="toc-text">保活方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ListView-amp-RecyclerView%EF%BC%88%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-number">19.</span> <span class="toc-text">ListView &amp; RecyclerView（缓存）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Davilk%E3%80%81ART%E5%8C%BA%E5%88%AB"><span class="toc-number">19.1.</span> <span class="toc-text">Davilk、ART区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%8C%96%EF%BC%88%E5%8E%86%E5%8F%B2%E3%80%81%E6%B5%81%E7%A8%8B%E3%80%81%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">热修复与插件化（历史、流程、）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OkHttp-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%A5%BD%E5%A4%84%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%89"><span class="toc-number">21.</span> <span class="toc-text">OkHttp 实现原理（好处、拦截器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpUrlConnection-%E5%92%8C-okhttp-%E5%85%B3%E7%B3%BB"><span class="toc-number">21.0.1.</span> <span class="toc-text">HttpUrlConnection 和 okhttp 关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Volley-%E4%B8%8E-OkHttp-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">21.0.2.</span> <span class="toc-text">Volley 与 OkHttp 的对比：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">21.0.3.</span> <span class="toc-text">衍生问题：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">22.</span> <span class="toc-text">其他</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Summer</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">84</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">阿七笔记</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/menu">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">回答思路</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-22</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>内存模型与GC</p>
<p>锁与并发</p>
<p>线程与线程池</p>
<p>bitmap</p>
<p>图片框架与okhttpclient</p>
<p>http与https区别、tcp的三次握手与四次挥手</p>
<p>View的绘制、事件处理</p>
<p>RecyclerView与ListView</p>
<p>WebView</p>
<p>Binder</p>
<p>Handler</p>
<p>打开app流程与系统启动流程</p>
<p>打包流程</p>
<p>Davilk、ART</p>
<p>IM、Socket与保活</p>
<p>kotlin基础知识</p>
<h2 id="专业单词"><a href="#专业单词" class="headerlink" title="专业单词"></a>专业单词</h2><p>ReentrantLock： [riː’entrənt]<br>ConcurrentHashMap：[kənˈkʌrənt]<br>segment：[ˈseɡmənt]<br>Zygote: [ˈzaɪɡəʊt]<br>Allocation: [ˌæləˈkeɪʃn]<br>volatile [ˈvɒlətaɪl]<br>Sparse：[spɑːs]<br>Dalvik<br>Instrumentation<br>DecorView<br>LayoutParams<br>MeasureSpec<br>finalize<br>eden、survivor<br>Minor、<br>复制：</p>
<h2 id="内存模型与GC"><a href="#内存模型与GC" class="headerlink" title="内存模型与GC"></a>内存模型与GC</h2><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>JVM 主要包括四个部分：<br>1.类加载器（ClassLoader）:在 JVM 启动时或者在类运行将需要的 class 加载到 JVM 中。<br>2.执行引擎：负责执行 class 文件中包含的字节码指令；<br>3.内存区（也叫运行时数据区）：是在 JVM 运行的时候操作所分配的内存区。 运行时内存区主要可以划分为 5 个区域，</p>
<ul>
<li>方法区(MethodArea)：用于存储类结构信息的地方，包括常量池、静态常量、 构造函数等。虽然 JVM 规范把方法区描述为堆的一个辑部分， 但它却有个别名 non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。</li>
<li>java 堆(Heap)：存储 java 实例或者对象的地方。这块是 GC 的主要区域。从存储 的内容我们可以很容易知道，方法和堆是被所有 java 线程共享的。</li>
<li>java 栈(Stack)：java 栈总是和线程关联在一起，每当创一个线程时，JVM 就会为 这个线程创建一个对应的 java 栈在这个 java 栈中,其中又会包含多个栈帧，每运 行一个方法就建一个栈帧，用于存储局部变量表、操作栈、方法返回等。每一个 方法从调用直至执行完成的过程，就对应一栈帧在 java 栈中入栈到出栈的过程。 所以 java 栈是现成有的。</li>
<li>程序计数器(PCRegister)：用于保存当前线程执行的内存地址。由于 JVM 程序是 多线程执行的（线程轮流切换），所以为了保证程切换回来后，还能恢复到原先 状态，就需要一个独立计数器，记录之前中断的地方，可见程序计数器也是线程 私有的。</li>
<li>本地方法栈(Native MethodStack)：和 java 栈的作用差不多，只不过是为 JVM 使 用到 native 方法服务的。</li>
</ul>
<p>4.本地方法接口：主要是调用 C 或 C++实现的本地方法及回调结果。</p>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>关键字：可达性分析与GCRoots、回收算法与垃圾回收器、分代、回收时机</p>
<p>可达性分析：<br>可达性分析算法通过一系列称为 GCRoots 的对象作为起始点，从这些节点从上 向下搜索，所走过的路径称为引用链，当一个对象没有任何引用链与 GCRoots 连接时就说明此对象不可用，也就是对象不可达。<br>GC Roots 对象通常包括：</p>
<ul>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表） </li>
<li>方法中类的静态属性引用的对象 </li>
<li>方法区中常量引用的对象 </li>
<li>Native 方法引用的对象</li>
</ul>
<p>可达性分析算法整个流程如下所示：<br>第一次标记：对象在经过可达性分析后发现没有与 GC Roots 有引用链，则进行 第一次标记并进行一次筛选，筛选条件是：该对象是否有必要执行 finalize()方法。 没有覆盖 finalize()方法或者 finalize()方法已经被执行过都会被认为没有必要执行。 如果有必要执行：则该对象会被放在一个 F-Queue 队列，并稍后在由虚拟机建立的低优先级 Finalizer 线程中触发该对象的 finalize()方法，但不保证一定等待它执行结束，因为如果这个对象的 finalize()方法发生了死循环或者执行时间较长的情况，会阻塞 F-Queue 队列里的其他对象，影响 GC。<br>第二次标记：GC 对 F-Queue 队列里的对象进行第二次标记，如果在第二次标记 时该对象又成功被引用，则会被移除即将回收的集合，否则会被回收。<br>总之，JVM 在做垃圾回收的时候，会检查堆中的所有对象否会被这些根集对象 引用，不能够被引用的对象就会被圾收集器回收。</p>
<p>一般回收算法也有如下几种：</p>
<p>1).标记-清除（Mark-sweep）<br>标记-清除算法采用从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象 的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效， 但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>
<p>2).标记-整理（Mark-Compact）<br>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不 同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移 动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了 对象的移动，因此成本更高，但是却解决了内存碎片的问题。该垃圾回收算法适 用于对象存活率高的场景（老年代）。</p>
<p>3).复制（Copying）<br>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已 使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存 碎片等复杂情况。</p>
<p>4).分代收集算法<br>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中 不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的 执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就 采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。Java 堆内存一般可以分为新生代、老年代和永久代三个模块：</p>
<p>新生代：<br>1.所有新生成的对象首先都是放在新生代的。新生代的目标就是尽可能快速的收 集掉那些生命周期短的对象。<br>2.新生代内存按照 8:1:1 的比例分为一个 eden 区和两个survivor(survivor0,survivor1)区。大部分对象在 Eden 区中生成。回收时先将 eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区，当这个 survivor0 区也 存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区， 然后清空 eden 和这个 survivor0 区，此时 survivor0 区是空的，然后将 survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。<br>3.当 survivor1 区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次 Full GC，也就是新生代、老 年代都进行回收。<br>4.新生代发生的 GC 也叫做 Minor GC，MinorGC 发生频率比较高(不一定等 Eden 区满了才触发)。</p>
<p>老年代：<br>1.在老年代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到老年代中。因 此，可以认为老年代中存放的都是一些生命周期较长的对象。<br>2.内存比新生代也大很多(大概比例是 1:2)，当老年代内存满时触发 Major GC， 即 Full GC。Full GC 发生频率比较低，老年代对象存活时间比较长。</p>
<p>永久代：<br>永久代主要存放静态文件，如 Java 类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如使用反射、动态代理、CGLib 等 bytecode 框架时，在这种时候需要设置一个比较大的永久代空间来存 放这些运行过程中新增的类。</p>
<p>垃圾收集器：</p>
<ul>
<li>Serial 收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程， 优点是简单高效；</li>
<li>Serial Old 收集器 (标记-整理算法): 老年代单线程收集器，Serial 收集器 的老年代版本；</li>
<li>ParNew 收集器 (复制算法): 新生代收并行集器，实际上是 Serial 收集器 的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现；</li>
<li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行 收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿 的特点，追求最短 GC 回收停顿时间。</li>
<li>Parallel Scavenge 收集器 (复制算法): 新生代并行收集器，追求高吞吐量， 高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC 线程时间)， 高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合 后台应用等对交互相应要求不高的场景；</li>
<li>Parallel Old 收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先， Parallel Scavenge 收集器的老年代版本；</li>
<li>G1(Garbage First)收集器 (标记-整理算法)： Java 堆并行收集器，G1 收 集器是 JDK1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实 现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器 的一个重要特点是：G1 回收的范围是整个 Java 堆(包括新生代，老年代)， 而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<p>Garbage-First（G1，垃圾优先）收集器是服务类型的收集器，目标是多处理器 机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。 Oracle JDK 7 update 4 以及更新发布版完全支持 G1 垃圾收集器。它是将堆内存被划分为多个大小相等的 heap 区,每个 heap 区都是逻辑上连续 的一段内存(virtual memory). 其中一部分区域被当成老一代收集器相同的角色 (eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提 供了更多的灵活性。</p>
<p>JAVA 自动内存管理：给对象分配内存 以及 回收分配给对象的内存。<br>1、对象优先在 Eden 分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起 一次 MinorGC。<br>2、大对象直接进入老年代。如很长的字符串以及数组。很长的字符串以及数组。<br>3、长期存活的对象将进入老年代。当对象在新生代中经历过一定次数（默认为 15）的 Minor GC 后，就会被晋升到老年代中。<br>4、动态对象年龄判定。为了更好地适应不同程序的内存状况，虚拟机并不是永 远地要求对象年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大 于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p>
<p>回收时机：<br>对象优先在 Eden 分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起 一次 MinorGC。<br>当 survivor1 区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次 Full GC，也就是新生代、老 年代都进行回收。</p>
<h3 id="Android-GC"><a href="#Android-GC" class="headerlink" title="Android GC"></a>Android GC</h3><p>关键字：Dalvik的缺点、ART的优点、GC方案、GC的维度</p>
<p>Dalvik缺点:</p>
<ol>
<li>Dalvik对象的内存分配和回收都比较慢,在GC时需要挂起虚拟机所有线程</li>
<li>Dalvik GC采用了并发标记-清除（CMS）算法。Dalvik GC只对后台的App进行内存整理（压缩），导致（前台App）堆中出现大量内存碎片，这些碎片往往都比较小，导致大而连续的空间紧张</li>
</ol>
<p>ART优点：</p>
<ol>
<li>在ART中标记不需要挂起所有程序的线程：在ART中GC会要求程序在分配空间的时候标记自身的堆栈，这个过程非常短，不需要挂起所有程序的线程（解决问题1）</li>
<li>提供 LOS ：large object space 专供Bitmap使用，从而提高了GC的管理效率和整体性能（解决问题2）</li>
<li>ART里有moving collector来压缩活动对象，使得内存空间更加紧凑 （解决问题3）</li>
</ol>
<p>GC方案：<br>   ART 有多个不同的 GC 方案，涉及运行不同的垃圾回收器。从 Android 8 (Oreo) 开始，默认方案是并发复制 (CC)，前台默认使用CC, 后台使用CCBackground。<br>   ART 仍然支持的另一个 GC 方案是并发标记清除(CMS)。此 GC 方案还支持压缩，但不是以并发方式。在应用进入后台之前，它会避免执行压缩，应用进入后台后，它会暂停应用线程以执行压缩。如果对象分配因碎片而失败，也必须执行压缩操作。在这种情况下，应用可能会在一段时间内没有响应。</p>
<p>GC的维度：<br>区分前后台</p>
<p>区分堆：<br>ImageSpace 主要用来管理加载到内存中的art文件<br>Zygote Space Zygote进程的heap区<br>LargeObjeactSpace  主要管理存放大对象的内存区域<br>AllocationSpace 常规内存对象的分配区域</p>
<p>区分回收力度GcType：<br>kGcTypeSticky：只回收上次GC后在Allocation Space中新分配的垃圾对象<br>kGcTypePartial：只回收Allocation Space的垃圾对象<br>kGcTypeFull：同时回收Zygote Space和Allocation Space的垃圾对象</p>
<p>区分回收器：并发标记-清除CMS、半空间压缩SS、标记-压缩MC（Q已经移除）、并发复制回收CC、后台并发复制回收CCBackground等</p>
<p>区分内存分配器：线程私有分配区TLAB、专门分配大对象的LOS等</p>
<h2 id="锁与Collection"><a href="#锁与Collection" class="headerlink" title="锁与Collection"></a>锁与Collection</h2><h3 id="Synchronized（monitorenter-monitorexit与ACC-SYNCHRONIZED、三种锁、类锁与对象锁）"><a href="#Synchronized（monitorenter-monitorexit与ACC-SYNCHRONIZED、三种锁、类锁与对象锁）" class="headerlink" title="Synchronized（monitorenter/monitorexit与ACC_SYNCHRONIZED、三种锁、类锁与对象锁）"></a>Synchronized（monitorenter/monitorexit与ACC_SYNCHRONIZED、三种锁、类锁与对象锁）</h3><p>synchronized 代码块是由一对儿 monitorenter/monitorexit 指令实现的， Monitor 对象是同步的基本实现，而 synchronized 同步方法使用了 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行 相应的同步调用。<br>在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要 进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。 现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同 的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、 轻量级锁和重量级锁，大大改进了其性能。 所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检 测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、 降级。</p>
<p>synchronized 修饰静态方法获取的是类锁(类的字节码文件对象)。<br>synchronized 修饰普通方法或代码块获取的是对象锁。这种机制确保了同一时刻 对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处 于可执行状态，从而有效避免了类成员变量的访问冲突。</p>
<h3 id="ReentrantLock（AQS、公平锁与非公平锁、共享模式和独占模式）"><a href="#ReentrantLock（AQS、公平锁与非公平锁、共享模式和独占模式）" class="headerlink" title="ReentrantLock（AQS、公平锁与非公平锁、共享模式和独占模式）"></a>ReentrantLock（AQS、公平锁与非公平锁、共享模式和独占模式）</h3><p>ReentrantLock 实现的前提就是 AbstractQueuedSynchronizer，简称 AQS，是 java.util.concurrent 的核心，CountDownLatch、FutureTask、Semaphore、 ReentrantLock 等都有一个内部类是这个抽象类的子类。由于 AQS 是基于 FIFO 队列的实现，因此必然存在一个个节点，Node 就是一个节点，Node 有两种模 式：共享模式和独占模式。ReentrantLock 是基于 AQS 的，AQS 是 Java 并发包中众多同步组件的构建基础，它通过一个 int 类型的状态变量 state 和一个 FIFO 队列来完成共享资源的获取，线程的排队等待等。AQS 是个底层框架，采用模 板方法模式，它定义了通用的较为复杂的逻辑骨架，比如线程的排队，阻塞，唤 醒等，将这些复杂但实质通用的部分抽取出来，这些都是需要构建同步组件的使 用者无需关心的，使用者仅需重写一些简单的指定的方法即可（其实就是对于共 享变量 state 的一些简单的获取释放的操作）。AQS 的子类一般只需要重写 tryAcquire(int arg)和 tryRelease(int arg)两个方法即可。</p>
<p>ReentrantLock的处理逻辑：</p>
<p>其内部定义了三个重要的静态内部类，Sync，NonFairSync，FairSync。Sync 作 为 ReentrantLock 中公用的同步组件，继承了 AQS（要利用 AQS 复杂的顶层逻 辑嘛，线程排队，阻塞，唤醒等等）；NonFairSync 和 FairSync 则都继承 Sync， 调用 Sync 的公用逻辑，然后再在各自内部完成自己特定的逻辑（公平或非公平）。<br>接着说下这两者的 lock()方法实现原理：</p>
<p>NonFairSync（非公平可重入锁）<br>1.先获取 state 值，若为 0，意味着此时没有线程获取到资源，CAS 将其设置为 1， 设置成功则代表获取到排他锁了；<br>2.若 state 大于 0，肯定有线程已经抢占到资源了，此时再去判断是否就是自己 抢占的，是的话，state 累加，返回 true，重入成功，state 的值即是线程重入的 次数；<br>3.其他情况，则获取锁失败。</p>
<p>FairSync（公平可重入锁）<br>可以看到，公平锁的大致逻辑与非公平锁是一致的，不同的地方在于了!hasQueuedPredecessors()这个判断逻辑，即便 state 为 0，也不能贸然直接去获取，要先去看有没有还在排队的线程，若没有，才能尝试去获取，做后面的处理。反之，返回 false，获取失败。</p>
<p>最后，说下 ReentrantLock 的 tryRelease()方法实现原理：<br>若 state 值为 0，表示当前线程已完全释放干净，返回 true，上层的 AQS 会意识到资源已空出。若不为 0，则表示线程还占有资源，只不过将此次重入的资源的释放了而已，返回 false。</p>
<p>ReentrantLock 是一种可重入的，可实现公平性的互斥锁，它的设计基于 AQS框架，可重入和公平性的实现逻辑都不难理解，每重入一次，state 就加 1，当然在释放的时候，也得一层一层释放。至于公平性，在尝试获取锁的时候多了一 个判断：是否有比自己申请早的线程在同步队列中等待，若有，去等待；若没有， 才允许去抢占。</p>
<p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数 据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每 次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。Java中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。<br>乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁， 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版 本号机制和 CAS 算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
<p>乐观锁适用于写比较少的情况下（多读场景），而一般多写的场景下用悲观锁就 比较合适。</p>
<p>乐观锁常见的两种实现方式：<br>1、版本号机制<br>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数， 当数据被修改时，version 值会加 1。当线程 A 要更新数据值时，在读取数据的 同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数 据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>2、CAS 算法<br>即 compare and swap（比较与交换），是一种有名的无锁算法。CAS 有 3 个操 作数，内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。 一般情况下是一个自旋操 作，即不断的重试。</p>
<p>比较：<br>Lock（ReentrantLock）的底层实现主要是 Volatile + CAS（乐观锁），而 Synchronized 是一种悲观锁，比较耗性能。但是在 JDK1.6 以后对 Synchronized 的锁机制进行了优化，加入了偏向锁、轻量级锁、自旋锁、重量级锁，在并发量 不大的情况下，性能可能优于 Lock 机制。所以建议一般请求并发量不大的情况 下使用 synchronized 关键字。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Unsafe 是 CAS 的核心类。因为 Java 无法直接访问底层操作系统，而是通过本地 （native）方法来访问。不过尽管如此，JVM 还是开了一个后门，JDK 中有一个 类 Unsafe，它提供了硬件级别的原子操作。</p>
<p>CAS，Compare and Swap 即比较并交换，设计并发算法时常用到的一种技术， java.util.concurrent 包全完建立在 CAS 之上，没有 CAS 也就没有此包，可见 CAS 的重要性。当前的处理器基本都支持 CAS，只不过不同的厂家的实现不一样罢了。 并且 CAS 也是通过 Unsafe 实现的，由于 CAS 都是硬件级别的操作，因此效率 会比普通加锁高一些。</p>
<h3 id="volatile（可见性与指令重排）"><a href="#volatile（可见性与指令重排）" class="headerlink" title="volatile（可见性与指令重排）"></a>volatile（可见性与指令重排）</h3><p>volatile 有两条关键的语义：</p>
<ul>
<li>保证被 volatile 修饰的变量对所有线程都是可见的</li>
<li>禁止进行指令重排序</li>
</ul>
<p>什么是指令重排序？<br>指令重排序是指指令乱序执行，即在条件允许的情况下直接运行当前有能 力立即执行的后续指令，避开为获取一条指令所需数据而造成的等待，通 过乱序执行的技术提供执行效率。<br>指令重排序会在被 volatile 修饰的变量的赋值操作前，添加一个内存屏障，指令重排序时不能把后面的指令重排序移到内存屏障之前的位置。</p>
<p>synchronized 和 volatile 关键字的作用和区别。<br>Volatile：<br>1）保证了不同线程对这个变量进行操作时的可见性即一个线程修改了某个变量 的值，这新值对其他线程来是立即可见的。 2）禁止进行指令重排序。</p>
<p>volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的， 需从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变 量，其它线程被阻塞住。</p>
<p>1.volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类 级别的。<br>2.volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可 以保证变量的修改可见性和原子性。<br>3.volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。<br>4.volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译 器优化。</p>
<h3 id="ConcurrentHashMap（分段锁-CAS-synchronized、红黑树）"><a href="#ConcurrentHashMap（分段锁-CAS-synchronized、红黑树）" class="headerlink" title="ConcurrentHashMap（分段锁/CAS + synchronized、红黑树）"></a>ConcurrentHashMap（分段锁/CAS + synchronized、红黑树）</h3><p>ConcurrentHashMap 1.7 原理：<br>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同 步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量) 的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。<br>put 方法:首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。<br>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保 证并发的原子性，所以 put 操作时仍然需要加锁处理。 首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞 争，则利用 scanAndLockForPut() 自旋获取锁:<br>尝试自旋获取锁。 如果重试的次数达到了 MAX_SCAN_RETRIES 则改为 阻塞锁获取，保证能获取成功。<br>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是 否相等，相等则覆盖旧的 value。为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断 是否需要扩容。最后会使用 unlock()解除当前 Segment 的锁。<br>get 方法：只需要将 Key 通过 Hash 之后定位到具体的 Segment ， 再通过一次 Hash 定位到具体的元素上。由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内 存可见性，所以每次获取时都是最新值。ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要 加锁。</p>
<p>ConcurrentHashMap 1.8 原理：<br>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但 依然存在 HashMap 在 1.7 版本中的问题：那就是查询遍历链表效率太低。和1.8 HashMap 结构类似：其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p>
<p>AtomicStampedReference：解 决 ABA 问题。这个类的 compareAndSet 方法作用是首先检查当前引用是 否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以 原子方式将该引用和该标志的值设置为给定的更新值。如果 CAS 不成功，则会原地自旋，如果长时间自旋会给 CPU 带来非常大 的执行开销。</p>
<p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率 （O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出 在新版的 JDK 中对 synchronized 优化是很到位的。</p>
<p>HashMap 何时扩容：<br>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值–即大于当前数组的长度乘以加载因子的值的时候，就要自动扩容。</p>
<p>扩容的算法是什么：<br>扩容(resize)就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度， 以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法是使用一 个新的数组代替已有的容量小的数组。</p>
<h3 id="Map、List、SparseArray"><a href="#Map、List、SparseArray" class="headerlink" title="Map、List、SparseArray"></a>Map、List、SparseArray</h3><p>ArrayList 和 LinkedList 怎么动态扩容的吗？<br>ArrayList 初始化大小是 10 （如果你知道你的 arrayList 会达到多少容量，可以 在初始化的时候就指定，能节省扩容的性能开支） 扩容点规则是，新增的时候 发现容量不够用了，就去扩容 扩容大小规则是，扩容后的大小= 原始大小+原始大小/2 + 1。（例如：原始大小是 10 ，扩容后的大小就是 10 + 5+1 = 16）</p>
<p>HashMap 1.7 的原理：<br>HashMap 底层是基于 数组 + 链表 组成的，不过在 jdk1.7 和 1.8 中具体实 现稍有不同。<br>负载因子：给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往 里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量 进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常 消耗性能。因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来 的性能损耗。</p>
<p>HashMap 1.8 的原理：<br>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效 率就会越来越低；时间复杂度为 O(N)，因此 1.8 中重点优化了这个查询效率。TREEIFY_THRESHOLD 用于判断是否需要将链表转换为红黑树的阈值。<br>修改为红黑树之后查询效率直接提高到了 O(logn)。但是 HashMap 原有的问题 也都存在，比如在并发场景下使用时容易出现死循环：<br>在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容 易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出 的 index 正好是环形链表的下标就会出现死循环：在 1.7 中 hash 冲突 采用的头插法形成的链表，在并发条件下会形成循环链表，一旦有查询落 到了这个链表上，当获取不到值时就会死循环。</p>
<p>ArrayMap、SparseArray<br>SparseArray 比 HashMap 更省内存，在某些条件下性能更好，主要是因为它避 免了对 key 的自动装箱（int 转为 Integer 类型），它内部则是通过两个数组来进 行数据存储的，一个存储 key，另外一个存储 value，为了优化性能，它内部对 数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源 码中可以看到 key 和 value 分别是用数组表示；同时，SparseArray 在存储和读取数据时候，使用的是二分查找法。也就是在 put 添加数据的时候，会使用二分查找法和之前的 key 比较当前我们添加的元素的 key 的大小，然后按照从小到大的顺序排列好，所以，SparseArray 存储的元素 都是按元素的 key 值从小到大排列好的。 而在获取数据的时候，也是使用二分 查找法判断元素的位置，所以，在获取数据的时候非常快，比 HashMap 快的多。</p>
<p>ArrayMap:<br>ArrayMap 利用两个数组，mHashes 用来保存每一个 key 的 hash 值，mArrray 大小为 mHashes 的 2 倍，依次保存 key 和 value。当插入时，根据 key 的 hashcode()方法得到 hash 值，计算出在 mArrays 的 index 位置，然后利用二分查找找到对应的位置进行插入，当出现哈希冲突时，会在 index 的相邻位置插入。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程（生命周期）"><a href="#线程（生命周期）" class="headerlink" title="线程（生命周期）"></a>线程（生命周期）</h3><p>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到 CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试 发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。<br>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生 的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结 果后，调用 resume() 使其恢复。<br>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果 等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。<br>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它 有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数， 前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙 述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法 则相反。</p>
<p>线程的生命周期：</p>
<ul>
<li>NEW：创建状态，线程创建之后，但是还未启动。</li>
<li>RUNNABLE：运行状态，处于运行状态的线程，但有可能处于等待状态， 例如等待 CPU、IO 等。</li>
<li>WAITING：等待状态，一般是调用了 wait()、join()、LockSupport.spark() 等方法。</li>
<li>TIMED_WAITING：超时等待状态，也就是带时间的等待状态。一般是调 用 了 wait(time) 、 join(time) 、 LockSupport.sparkNanos() 、 LockSupport.sparkUnit()等方法。</li>
<li>BLOCKED：阻塞状态，等待锁的释放，例如调用了 synchronized 增加了 锁。</li>
<li>TERMINATED：终止状态，一般是线程完成任务后退出或者异常终止。</li>
</ul>
<h3 id="线程池（执行流程、5种内置线程池的区别、AsyncTask）"><a href="#线程池（执行流程、5种内置线程池的区别、AsyncTask）" class="headerlink" title="线程池（执行流程、5种内置线程池的区别、AsyncTask）"></a>线程池（执行流程、5种内置线程池的区别、AsyncTask）</h3><p>核心参数:<br>corePoolSize:核心线程数<br>maximumPoolSize:最大线程数<br>keepAliveTime:非核心线程的闲置时间限制，超过则回收该非核心线程<br>workQueue:BlockingQueue类型，阻塞队列<br>threadFactory：线程的工厂类<br>handler：RejectedExecutionHandler线程池的饱和策略，默认策略是抛出运行时exception</p>
<p>在execute提交时：<br>1.如果线程数小于核心线程，则新建核心线程去执行任务Runable<br>2.将任务Runable加入workQueue中，然后检查是否可以新建线程<br>3.如果队列无法加入Runnable，检查是否可以新建线程(防止线程有回收的),如果不能，执行handler的拒绝策略</p>
<p>thread执行的对象是Worker对象，在worker中run方法会从queue中不停的取任务执行。</p>
<p>Runnable、Callable、Future是三个基础interface，分别是不带结果的运行，带结果的运行，对异步任务整个生命周期的表示。</p>
<p>FutureTask是class，继承了Runnable与Future，内部持有callable。一般外部传入callable。</p>
<p>java内置5中线程池：在Executors中提供静态方法<br>newCachedThreadPool：核心线程0，最大Integer.MAX_VALUE, keepAliveTime为60秒,SynchronousQueue同步阻塞队列。只有非核心线程,最大线程数非常大,所有线程都活动时会为新任务创建新线程, 否则会利用空闲线程(60s 空闲时间,过了就会被回收,所以线程池中有 0 个线程的 可能)处理任务。优点:任何任务都会被立即执行(任务队列 SynchronousQuue 相当于一个空集合); 比较适合执行大量的耗时较少的任务.<br>newSingleThreadExecutor：核心1，最大1，keepAliveTime为0，LinkedBlockingQueue。只有一个核心线程,确保所有的任务都在同一线程中按序完成.因此不需要处理线 程同步的问题.<br>newFixedThreadPool：核心n,最大n，keepAliveTime为0，LinkedBlockingQueue。只有核心线程,并且数量固定的,也不会被回收,所有线程都活动时,因为队列没有 限制大小,新任务会等待执行。优点:更快的响应外界请求。<br>newScheduledThreadPool：线程池为ScheduledThreadPoolExecutor，核心n，最大Integer.MAX_VALUE，keepAliveTime为10秒,DelayedWorkQueue（利用数组模拟堆实现）。主要处理定时任务，和Timer功能类似。核心线程数固定,非核心线程（闲着没活干会被立即回收数）没有限制.优点:执行定时任务以及有固定周期的重复任务<br>newWorkStealingPool：ForkJoinPool，使用一个无限队列来保存需要执行的任务，可以传入线程的数量，不传入，则默认使用当前计算机中可用的cpu数量，使用分治法来解决问题，使用fork()和join()来进行调用.</p>
<h3 id="AsyncTask-两种线程池可以切换"><a href="#AsyncTask-两种线程池可以切换" class="headerlink" title="AsyncTask(两种线程池可以切换)"></a>AsyncTask(两种线程池可以切换)</h3><p>内部持有THREAD_POOL_EXECUTOR（线程池,核心1,最大20）来真正运行任务。<br>sBackupExecutor（线程池,核心5,最大5，LinkedBlockingQueue(Integer.MAX_VALUE)）用来处理被拒绝的请求，其实就是用来托底。<br>持有一个sHandler，指向getMainLooper，用于对接收结果，接收进度，执行在主线程。<br>插入任务时先使用SerialExecutor将任务包装后加入队列，然后逐个将包装后的任务加入THREAD_POOL_EXECUTOR线程池。</p>
<p>Tip:放在activity中注意内存泄漏。</p>
<p>主要回调方法：<br>onPreExecute() //此方法会在后台任务执行前被调用，用于进行一些准备工作<br>doInBackground(Params… params) //此方法中定义要执行的后台任务，在这个方法中可以调用publishProgress来更新任务进度（publishProgress内部会调用onProgressUpdate方法）<br>onProgressUpdate(Progress… values) //由publishProgress内部调用，表示任务进度更新<br>onPostExecute(Result result) //后台任务执行完毕后，此方法会被调用，参数即为后台任务的返回结果<br>onCancelled() //此方法会在后台任务被取消时被调用<br>—-除了doInBackground方法由AsyncTask内部线程池执行外，其余方法均在主线程中执行</p>
<p>缺点：</p>
<ul>
<li>在Android 4.1版本之前，AsyncTask类必须在主线程中加载，这意味着对AsyncTask类的第一次访问必须发生在主线程中；在Android 4.1以及以上版本则不存在这一限制，因为ActivityThread（代表了主线程）的main方法中会自动加载AsyncTask</li>
<li>AsyncTask对象必须在主线程中创建</li>
<li>AsyncTask对象的execute方法必须在主线程中调用</li>
<li>一个AsyncTask对象只能调用一次execute方法</li>
</ul>
<p>AsyncTask其实就是一个分装FutureTask的封装类(内部持有FutureTask)，线程池等都是AsyncTask的static变量，所有AsyncTask就是统一提交到线程池中。</p>
<p>可以引入rxjava、kotlin线程池框架的比较？</p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="类加载器（3种）"><a href="#类加载器（3种）" class="headerlink" title="类加载器（3种）"></a>类加载器（3种）</h3><p>启动类加载器（Bootstrap ClassLoader）：负责加载<JAVA_HOME>\lib目录下或者被-Xbootclasspath 参数所指定的路径的，并且是被虚拟机所 识别的库到内存中。<br>扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录下或者被 java.ext.dirs 系统变量所指定的路径的所有类库到内存中。<br>应用类加载器（Application ClassLoader）：负责加载用户类路径上的指 定类库，如果应用程序中没有实现自己的类加载器，一般就是这个类加载 器去加载应用程序中的类库。</p>
<p>Android：<br>BootClassLoader（Java 的 BootStrap ClassLoader）： 用于加载 Android Framework 层 class 文件。<br>PathClassLoader（Java 的 App ClassLoader）： 用于加载已经安装到系 统中的 apk 中的 class 文件。<br>DexClassLoader（Java 的 Custom ClassLoader）： 用于加载指定目录中 的 class 文件。 BaseDexClassLoader： 是 PathClassLoader 和 DexClassLoader 的父类。</p>
<h3 id="软引用和弱引用（ReferenceQueue）"><a href="#软引用和弱引用（ReferenceQueue）" class="headerlink" title="软引用和弱引用（ReferenceQueue）"></a>软引用和弱引用（ReferenceQueue）</h3><p>1、软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软 / 弱引用。</p>
<p>2、如果只是想避免 OOM 异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p>
<p>3、可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对 象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p>
<h3 id="强引用置为-null，会不会被回收？"><a href="#强引用置为-null，会不会被回收？" class="headerlink" title="强引用置为 null，会不会被回收？"></a>强引用置为 null，会不会被回收？</h3><p>不会立即释放对象占用的内存。 如果对象的引用被置为 null，只是断开了当前 线程栈帧中对该对象的引用关系，而 垃圾收集器是运行在后台的线程，只有当 用户线程运行到安全点(safe point)或者安全区域才会扫描对象引用关系，扫描到 对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些 对象是可恢复的（在 finalize 方法中恢复引用 ）。只有确定了对象无法恢复引 用的时候才会清除对象内存。</p>
<h3 id="final，finally，finalize"><a href="#final，finally，finalize" class="headerlink" title="final，finally，finalize"></a>final，finally，finalize</h3><p>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代 表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以 重写的（override）。</p>
<p>finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁 等动作。</p>
<p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被 垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。Java 平台目前在逐步使用java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。Cleaner 的实现利用了幻 象引用（PhantomReference），这是一种常见的所谓 post-mortem 清理机制。 利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收 的工作，比如关闭文件描述符（操作系统有限的资源），它比 finalize 更加轻量、 更加可靠。</p>
<h3 id="String（长度）"><a href="#String（长度）" class="headerlink" title="String（长度）"></a>String（长度）</h3><ul>
<li>Java char 不存 UTF-8 的字节，而是 UTF-16。</li>
<li>Unicode 通用字符集占两个字节，例如“中”。</li>
<li>Unicode 扩展字符集需要用一对 char 来表示，例如“表情”。</li>
<li>Unicode 是字符集，不是编码，作用类似于 ASCII 码。</li>
<li>Java String 的 length 不是字符数。</li>
</ul>
<p>Java String 可以有多长？<br>分配到栈：<br>String longString = “aaa…aaa”;<br>分配到堆：<br>byte[] bytes = loadFromFile(new File(“superLongText.txt”); String superLongString = new String(bytes);<br>是否对字符串在内存当中的存储形式有深入了解（高级）<br>是否对Java虚拟机字节码有足够的了解（高级）</p>
<p>Java String 栈分配</p>
<ul>
<li>受字节码限制，字符串最终的 MUTF-8 字节数不超过 65535。</li>
<li>Latin 字符，受 Javac 代码限制，最多 65534 个。</li>
<li>非 Latin 字符最终对应字节个数差异较大，最多字节个数是 65535。</li>
<li>如果运行时方法区设置较小，也会受到方法区大小的限制。</li>
</ul>
<p>Java String 堆分配</p>
<ul>
<li>受虚拟机指令限制，字符数理论上限为 Integer.MAX_VALUE。</li>
<li>受虚拟机实现限制，实际上限可能会小于 Integer.MAX_VALUE。</li>
<li>如果堆内存较小，也会受到堆内存的限制。</li>
</ul>
<p>Java String 字面量形式</p>
<ul>
<li>字节码中 CONSTANT_Utf8_info 的限制，大小为65534（jvm字节码U2的最大长度）</li>
<li>Javac 源码逻辑的限制</li>
<li>方法区大小的限制</li>
</ul>
<p>Java String 运行时创建在堆上的形式</p>
<ul>
<li>Java 虚拟机指令 newarray 的限制</li>
<li>Java 虚拟机堆内存大小的限制</li>
</ul>
<p>String内部是以char数组的形式存储，数组的长度是int类型，那么String允许的最大长度就是Integer.MAX_VALUE了。又由于java中的字符是以16位存储的，因此大概需要4GB的内存才能存储最大长度的字符串。</p>
<p>String 为什么要设计成不可变的？<br>String 是不可变的（修改 String 时，不会在原有的内存地址修改，而是重新指向 一个新对象），String 用 final 修饰，不可继承，String 本质上是个 final 的 char[] 数组，所以 char[]数组的内存地址不会被修改，而且 String 也没有对外暴露修改 char[]数组的方法。不可变性可以保证线程安全以及字符串串常量池的实现。</p>
<p>String，StringBuffer，StringBuilder 有哪些不同<br>三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String<br>String 每次变化一个值就会开辟一个新的内存空间<br>StringBuilder：线程非安全的<br>StringBuffer：线程安全的</p>
<p>对于三者使用的总结：<br>1.如果要操作少量的数据用 String。<br>2.单线程操作字符串缓冲区下操作大量数据用 StringBuilder。<br>3.多线程操作字符串缓冲区下操作大量数据用 StringBuffer。</p>
<h2 id="网络协议相关"><a href="#网络协议相关" class="headerlink" title="网络协议相关"></a>网络协议相关</h2><h3 id="HTTP（区别、TLS握手、缓存）"><a href="#HTTP（区别、TLS握手、缓存）" class="headerlink" title="HTTP（区别、TLS握手、缓存）"></a>HTTP（区别、TLS握手、缓存）</h3><h4 id="Http1-1-和-Http1-0-及-2-0-的区别"><a href="#Http1-1-和-Http1-0-及-2-0-的区别" class="headerlink" title="Http1.1 和 Http1.0 及 2.0 的区别"></a>Http1.1 和 Http1.0 及 2.0 的区别</h4><p>HTTP1.1优点（HTTP1.1 也是当前使用最为广泛的 HTTP 协议）：<br>1、缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做 为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag， If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓 存策略。<br>2、支持断点 续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分， 即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利 用带宽和连接。<br>3、长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线 （Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建 立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一 定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</p>
<p>HTTP2.0优点：多路复用、header 压缩、服务端推送（server push）</p>
<h4 id="Https-请求慢的解决办法"><a href="#Https-请求慢的解决办法" class="headerlink" title="Https 请求慢的解决办法"></a>Https 请求慢的解决办法</h4><p>1、不通过 DNS 解析，直接访问 IP<br>2、解决连接无法复用<br>http/1.0 协议头里可以设置 Connection:Keep-Alive 或者 Connection:Close，选择是否允许 在一定时间内复用连接（时间可由服务器控制）。但是这对 App 端的请求成效不大，因为 App 端的请求比较分散且时间跨度相对较大。<br>基于 tcp 的长连接 (主要） 移动端建立一条自己的长链接通道，通道的实现是基于 tcp 协议。基于 tcp 的 socket 编程技术难度相对复杂很多，而且需要自己定制协议。但信息 的上报和推送变得更及时，请求量爆发的时间点还能减轻服务器压力（避免频繁创建和销毁 连接）</p>
<h4 id="SSL-TLS握手流程"><a href="#SSL-TLS握手流程" class="headerlink" title="SSL/TLS握手流程"></a>SSL/TLS握手流程</h4><p>https是Http+SSL/TLS协议，在tcp连接以后首先使用SSL/TLS，进行握手和交换秘钥，后续依然使用http请求，只不过内容将会使用秘钥加密。</p>
<p>SSL/TLS握手过程：<br>1.Client Hello：自己支持的SSL/TLS版本、支持的加密套件、随机数(Client Random)<br>2.Server Hello：确认使用的SSL/TLS版本、使用的加密套件、随机数(Server Random)和安全证书<br>3.Client：验证安全证书，生成随机数pre-master，使用服务端公钥加密发送给Server，生成对称秘钥secret=F(Client Random,Server Random,pre-master )<br>4.Server：使用私钥解密获得pre-master，也生成对称秘钥secret=F(Client Random,Server Random,pre-master )<br>5.Client发送Finish<br>6.Server发送Finish</p>
<p>如果需要对客户端证书也校验的话，会在Server Hello这一步要求客户端发送自己的证书给服务端校验。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>HTTP 的缓存可以分为两种： 强制缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据是，服务端返 回了缓存的过期时间（Expires 与 Cache-Control），没有过期就可以继续使用缓存，否则则 不适用，无需再向服务端询问。 对比缓存：需要服务端参与判断是否继续使用缓存，当客 户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since 与 Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请 求数据时，客户端将上次备份的缓存 标识发送给服务端，服务端根据缓存标识进行判断， 如果返回 304，则表示通知客户端可以继续使用缓存。 强制缓存优先于对比缓存。</p>
<h3 id="TCP-UDP（3次握手、4次挥手、DNS请求、网络请求）"><a href="#TCP-UDP（3次握手、4次挥手、DNS请求、网络请求）" class="headerlink" title="TCP/UDP（3次握手、4次挥手、DNS请求、网络请求）"></a>TCP/UDP（3次握手、4次挥手、DNS请求、网络请求）</h3><p>为什么 tcp 要经过三次握手，四次挥手？<br>“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生 错误”。主要目的防止 server 端一直等待，浪费资源。换句话说，即是为了保证服务端能收 接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客 户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</p>
<p>“四次挥手”原因是因为 tcp 是全双工模式，接收到 FIN 时意味将没有数据再发来，但是还是 可以继续发送数据。</p>
<p>ACK ： TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的 ACK 必 须为 1。<br>SYN(SYNchronization) ： 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是 一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。<br>FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发 送方的数据已经发送完毕，并要求释放连接。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手：建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务器的确认；<br>第二次握手：服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number+1)；同时， 自己自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将 上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器 进入 SYN_RECV 状态；<br>第三次握手：客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都 进入 ESTABLISHED 状态，完成 TCP 三次握手。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>第一次分手：主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；<br>第二次分手：主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段， Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主 机 2 告诉主机 1，我“同意”你的关闭请求；<br>第三次分手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；<br>第四次分手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭 连接了。</p>
<h4 id="TCP-可靠传输原理实现（滑动窗口）"><a href="#TCP-可靠传输原理实现（滑动窗口）" class="headerlink" title="TCP 可靠传输原理实现（滑动窗口）"></a>TCP 可靠传输原理实现（滑动窗口）</h4><p>确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。 数据校验。<br>数据合理分片与排序，TCP 会对数据进行分片，接收方会缓存为按序到达的数据，重新排序 后再提交给应用层。<br>流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢 失。<br>拥塞控制：当网络发生拥塞时，减少数据的发送。</p>
<h4 id="Tcp-和-Udp-的区别"><a href="#Tcp-和-Udp-的区别" class="headerlink" title="Tcp 和 Udp 的区别"></a>Tcp 和 Udp 的区别</h4><p>1、基于连接与无连接；<br>2、对系统资源的要求（TCP 较多，UDP 少）；<br>3、UDP 程序结构较简单；<br>4、流模式与数据报模式 ；<br>5、TCP 保证数据正确性，UDP 可能丢包；<br>6、TCP 保证数据顺序，UDP 不保证。</p>
<p>常见网络流程问题：<br>浏览器输入地址到返回结果发生了什么？<br>1、DNS 解析，此外还有 DNSy 优化（DNS 缓存、DNS 负载均衡）<br>2、TCP 连接<br>3、发送 HTTP 请求<br>4、服务器处理请求并返回 HTTP 报文<br>5、浏览器解析渲染页面<br>6、连接结束</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>1、在浏览器中输入<a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> 域名，浏览器会检查浏览区缓存，如果没有则先检查本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。<br>2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。<br>3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。<br>4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。<br>5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(<a target="_blank" rel="noopener" href="http://qq.com)给本地dns服务器.当本地dns服务器收到这个地址后,就会找http//qq.com%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E9%87%8D%E5%A4%8D%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%8A%A8%E4%BD%9C%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%EF%BC%8C%E7%9B%B4%E8%87%B3%E6%89%BE%E5%88%B0www.qq.com%E4%B8%BB%E6%9C%BA%E3%80%82">http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找http://qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。</a><br>6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p>
<h2 id="Bitmap（节省内存、Options、BitmapRegionDecoder）"><a href="#Bitmap（节省内存、Options、BitmapRegionDecoder）" class="headerlink" title="Bitmap（节省内存、Options、BitmapRegionDecoder）"></a>Bitmap（节省内存、Options、BitmapRegionDecoder）</h2><p>1、要选择合适的图片规格（bitmap 类型）：<br>ALPHA_8每个像素占用 1byte 内存 ,ARGB_4444 每个像素占用 2byte 内存 ,ARGB_8888 每个像素占用 4byte 内存（默认）,RGB_565 每个像素占用 2byte 内存</p>
<p>2、降低采样率。BitmapFactory.Options 参数 inSampleSize 的使用，先把 options.inJustDecodeBounds 设为 true，只是去读取图片的大小，在拿到图片的 大小之后和要显示的大小做比较通过 calculateInSampleSize()函数计算 inSampleSize 的具体值，得到值之后。options.inJustDecodeBounds 设为 false 读图片资源。</p>
<p>3、复用内存。即，通过软引用(内存不够的时候才会回收掉)，复用内存块，不 需要再重新给这个 bitmap 申请一块新的内存，避免了一次内存的分配和回收， 从而改善了运行效率。</p>
<p>4、使用 recycle()方法及时回收内存。</p>
<p>5、压缩图片。</p>
<p>在 Android 中，Bitmap 的存储分为两部分，一部分是 Bitmap 的数据，一部分是 Bitmap 的引用。 在 Android2.3 时代，Bitmap 的引用是放在堆中的，而 Bitmap 的数据部分是放在栈中的，需要用户调用 recycle 方法手动进行内存回收，而在 Android2.3 之后，整个 Bitmap，包括数据和引用，都放在了堆中，这样，整个 Bitmap 的回收就全部交给 GC 了，这个 recycle 方法就再也不需要使用了。</p>
<p>BitmapFactory 四类方法：<br>decodeFile( 文件系统 )<br>decodeResourece( 资源 )<br>decodeStream( 输入流 )<br>decodeByteArray( 字节数 )</p>
<h4 id="Bitmap-占用内存"><a href="#Bitmap-占用内存" class="headerlink" title="Bitmap 占用内存"></a>Bitmap 占用内存</h4><p>Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存</p>
<p>注：这里 inDensity 表示目标图片的 dpi（放在哪个资源文件夹下）， inTargetDensity 表示目标屏幕的 dpi，所以你可以发现 inDensity 和 inTargetDensity 会对 Bitmap 的宽高进行拉伸，进而改变 Bitmap 占用内存的大 小。 在 Bitmap 里有两个获取内存占用大小的方法。</p>
<p>getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。 getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存 大小，代替了 getByteCount() 方法。 在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片 时，那么 getByteCount() 表示新解码图片占用内存的大 小， getAllocationByteCount() 表示被复用 Bitmap 真实占用的内存大小（即 mBuffer 的长度）。</p>
<p>为了保证在加载 Bitmap 的时候不产生内存溢出，可以使用 BitmapFactory 进行 图片压缩，主要有以下几个参数：<br>BitmapFactory.Options.inPreferredConfig：将 ARGB_8888 改为 RGB_565，改变 编码方式，节约内存。<br>BitmapFactory.Options.inSampleSize：缩放比例，可以 参考 Luban 那个库，根据图片宽高计算出合适的缩放比例。<br>BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。<br>inJustDecodeBounds 获取图片的宽高信息，交给 inSampleSize 参数选 择缩放比</p>
<p>高效加载 Bitmap 的流程:<br>1、将 BitmapFactory.Options 的 inJustDecodeBounds 参数设为 true 并加载图片<br>2、从 BitmapFactory.Options 中取出图片原始的宽高信息， 对应于 outWidth 和 outHeight 参数 3、根据采样率规则并结合目标 view 的大小计算出采样率 inSampleSize<br>4、将 BitmapFactory.Options 的 inJustDecodeBounds 设置为 false 重 新加载图片</p>
<p>针对清明上河图这种大图可以使用 BitmapRegionDecoder 动态加载图片的显示区域。</p>
<p><strong>Bitmap.recycle()会立即回收么？什么时候会回收？如果没有地方使用这个 Bitmap，为什么垃圾回收不会直接回收？</strong></p>
<p>通过源码可以了解到，加载 Bitmap 到内存里以后，是包含两部 分内存区域的。简单的说，一部分是 Java 部分的，一部分是 C 部分的。这个 Bitmap 对象是由 Java 部分分配的，不用的时候 系统就会自动回收了。但是那个对应的 C 可用的内存区域，虚拟机是不能直接回收 的，这个只能调用底层的功能释放。所以需要调用 recycle()方 法来释放 C 部分的内存。bitmap.recycle()方法用于回收该 Bitmap 所占用的内存，接着 将 bitmap 置空，最后使用 System.gc()调用一下系统的垃圾回 收器进行回收，调用 System.gc()并不能保证立即开始进行回收 过程，而只是为了加快回收的到来。</p>
<h2 id="图片框架"><a href="#图片框架" class="headerlink" title="图片框架"></a>图片框架</h2><h4 id="Glide（缓存、生命周期）"><a href="#Glide（缓存、生命周期）" class="headerlink" title="Glide（缓存、生命周期）"></a>Glide（缓存、生命周期）</h4><p>为什么要在项目中使用这个库？<br>1.多样化媒体加载：不仅可以进行图片缓存，还支持 Gif、WebP、缩略图，甚 至是 Video。<br>2.通过设置绑定生命周期：可以使加载图片的生命周期动态管理起来。<br>3.高效的缓存策略：支持内存、Disk 缓存，并且 Picasso 只会缓存原始尺寸的 图片，内 Glide 缓存的是多种规格，也就是 Glide 会根据你 ImageView 的大小来 缓存相应大小的图片尺寸。<br>4.内存开销小：默认的 Bitmap 格式是 RGB_565 格式，而 Picasso 默认的是 ARGB_8888 格式，内存开销小一半。</p>
<p>这个库都有哪些用法？对应什么样的使用场景？<br>1.图片加载Glide.with(this).load(imageUrl).override(800,800).placeholder().error().animate().into()。<br>2.多样式媒体加载：asBitamp、asGif。<br>3.生命周期集成。<br>4.可以配置磁盘缓存策略 ALL、NONE、SOURCE、RESULT。</p>
<p>Glide&amp;with:<br>1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等） 以及 glide 对象。<br>2、将 glide 请求和 application/SupportFragment/Fragment 的生命周期绑定在一块。</p>
<p>Glide&amp;load：<br>设置请求 url，并记录 url 已设置的状态。</p>
<p>Glide&amp;into：<br>1、首先根据转码类 transcodeClass 类型返回不同的 ImageViewTarget：BitmapImageViewTarget、DrawableImageViewTarget。<br>2、递归建立缩略图请求，没有缩略图请求，则直接进行正常请求。<br>3、如果没指定宽高，会根据 ImageView 的宽高计算出图片宽高，最终执行到 onSizeReay()方法中的 engine.load()方法。<br>4、engine 是一个负责加载和管理缓存资源的类</p>
<p>常规三级缓存的流程：强引用-&gt;软引用-&gt;硬盘缓存<br>当我们的APP中想要加载某张图片时，先去LruCache中寻找图片，如果LruCache 中有，则直接取出来使用，如果 LruCache 中没有，则去 SoftReference 中寻找 （软引用适合当 cache，当内存吃紧的时候才会被回收。而 weakReference 在每 次 system.gc（）就会被回收）（当 LruCache 存储紧张时，会把最近最少使用 的数据放到 SoftReference 中），如果 SoftReference 中有，则从 SoftReference 中取出图片使用，同时将图片重新放回到 LruCache 中，如果 SoftReference 中 也没有图片，则去硬盘缓存中中寻找，如果有则取出来使用，同时将图片添加到 LruCache 中，如果没有，则连接网络从网上下载图片。图片下载完成后，将图 片保存到硬盘缓存中，然后放到 LruCache 中。</p>
<p>Glide 缓存机制大致分为三层：内存缓存、弱引用缓存、磁盘缓存。<br>取的顺序是：内存、弱引用、磁盘。<br>存的顺序是：弱引用、内存、磁盘。</p>
<p>三层存储的机制在 Engine 中实现的。先说下 Engine 是什么？Engine 这一层负 责加载时做管理内存缓存的逻辑。持有 MemoryCache、Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;。通过 load（）来加载图片，加载前后 会做内存存储的逻辑。如果内存缓存中没有，那么才会使用 EngineJob 这一层来 进行异步获取硬盘资源或网络资源。EngineJob类似一个异步线程或observable。 Engine 是一个全局唯一的，通过 Glide.getEngine()来获取。</p>
<p>需要一个图片资源，首先先取ActiveResources，activeResources是盛放正在使用的资源，以弱引用的形式存在。同时资源内部有被引用的记录。如果资源没有引用记录了，那么再放回 Lrucache 中，同时从 activeResources 中清除（activeResources开启了一个后台线程专门检测ReferenceQueue）。如果没有，则继续从LruResourceCache中取，取到以后从LruResourceCache删除同时加入ActiveResources中。如果 Lrucache 和 activeResources 中没有，那么进行资源异步请求（网络 /diskLrucache），请求成功后，资源放到 diskLrucache 和 activeResources 中。</p>
<p>缓存：<br>ActiveResources 活跃的内存缓存，使用的是弱引用的方式，用作优化列表反复滑动中Lru频繁清除，然后在重新加载的情况<br>LruResourceCache 内存缓存,不包含正在使用的资源。使用cache.remove(key)从LruResourceCache获取缓存<br>ResourceCacheGenerator:缓存的被加工过的原数据缓存（磁盘)<br>DataCacheGenerator:原文件<br>SourceGenerator:从网络加载数据</p>
<p>Glide源码机制的核心思想：</p>
<p>使用一个弱引用 map activeResources 来盛放项目中正在使用的资源。Lrucache 中不含有正在使用的资源。资源内部有个计数器来显示自己是不是还有被引用的 情况，把正在使用的资源和没有被使用的资源分开有什么好处呢？？因为当 Lrucache 需要移除一个缓存时，会调用 resource.recycle()方法。注意到该方法上 面注释写着只有没有任何 consumer 引用该资源的时候才可以调用这个方法。那 么为什么调用 resource.recycle()方法需要保证该资源没有任何 consumer 引用 呢？glide 中 resource 定义的 recycle（）要做的事情是把这个不用的资源（假设 是 bitmap 或 drawable）放到 bitmapPool 中。bitmapPool 是一个 bitmap 回收 再利用的库，在做 transform 的时候会从这个 bitmapPool 中拿一个 bitmap 进行 再利用。这样就避免了重新创建 bitmap，减少了内存的开支。而既然 bitmapPool 中的 bitmap 会被重复利用，那么肯定要保证回收该资源的时候（即调用资源的 recycle（）时），要保证该资源真的没有外界引用了。这也是为什么 glide 花费 那么多逻辑来保证 Lrucache 中的资源没有外界引用的原因。</p>
<p>相关问题：<br>Glide 如何确定图片加载完毕？<br>Glide 使用什么缓存？<br>Glide 内存缓存如何控制大小？</p>
<h4 id="Fresco（缓存）"><a href="#Fresco（缓存）" class="headerlink" title="Fresco（缓存）"></a>Fresco（缓存）</h4><p>DraweeView：继承于 ImageView，只是简单的读取 xml 文件的一些属性值和做 一些初始化的工作，图层管理交由 Hierarchy 负责，图层数据获取交由负责。<br>DraweeHierarchy：由多层 Drawable 组成，每层 Drawable 提供某种功能（例如： 缩放、圆角）。 DraweeController：控制数据的获取与图片加载，向 pipeline 发出请求，并接收相应事件，并根据不同事件控制 Hierarchy，从 DraweeView 接收用户的事件，然后执行取消网络请求、回收资源等操作。<br>DraweeHolder： 统筹管理 Hierarchy 与 DraweeHolder。<br>ImagePipeline：Fresco 的核心模块，用 来以各种方式（内存、磁盘、网络等）获取图像。 Producer/Consumer：Producer 也有很多种，它用来完成网络数据获取，缓存数据获取、图片解码等多种工作， 它产生的结果由 Consumer 进行消费。<br>IO/Data：这一层便是数据层了，负责实 现内存缓存、磁盘缓存、网络缓存和其他 IO 相关的功能。</p>
<p>具体实现：<br>GenericDraweeHierarchy：负责 SimpleDraweeView 上的图层管理，由多层 Drawable 组成，每层 Drawable 提供某种功能（例如：缩放、圆角）。</p>
<ol>
<li>背景图（backgroundImage）</li>
<li>占位图（placeholderImage=）</li>
<li>加载的图片（actualImage）</li>
<li>进度条（progressBarImage）</li>
<li>重试加载的图片（retryImage）</li>
<li>失败图片（failureImage）</li>
<li>叠加图（overlayImage）</li>
</ol>
<p>内存缓存：</p>
<p>已解码的内存缓存（BitmapMemoryCache）与未解码的内存缓存（EncodedMemoryCache）区别就是已解码内存缓存的数据是CloseableReference<CloseableBitmap>。而未解码内存缓存的数据是CloseableReference<PooledByteBuffer>。即他们的实现方式一样，区别仅仅在于<strong>资源的测量与释放方式不同</strong>。它们使用ValueDescriptor来描述不同资源的数据大小，使用不同的ResourceReleaser来释放资源。</p>
<p>BitmapMemoryCache（已解码的内存缓存）：BitmapMemoryCacheFactory提供工厂方法获取存储缓存的数据结构。<br>EncodedMemoryCache（未解码的内存缓存）：EncodedCountingMemoryCacheFactory提供工厂方法获取存储缓存的数据结构。</p>
<p>CountingLruMap：Fresco中定义的LRU缓存载体，里面使用了LinkedHashMap作为数据存储载体，但是并没有启用LinkedHashMap的accessOrder功能。同时里面封装了map中的总大小mSizeInBytes，还有各个缓存的大小（ValueDescriptor.getSizeInBytes）。</p>
<p>CountingMemoryCache:具体缓存缓存实现<br>Fresco中实现具体内存缓存的类是CountingMemoryCache，它内部维持着几个重要参数：<br>ExclusiveEntries存储着未被使用的对象的CountingLruMap；<br>CachedEntries存储着所有对象的CountingLruMap；<br>MemoryCacheParams存储着最大缓存对象数量、缓存池大小等参数;<br>PARAMS_INTERCHECK_INTERVAL_MS检查缓存参数变化的事件间隔：5分钟；</p>
<p>它使用一个内部类Entry来封装缓存对象，除了记录缓存键、缓存对象之外，它还记录着该对象的引用数量（clientCount）及是否被缓存追踪（isOrphan）。注意：每个缓存对象只有满足clientCount为0并且isOrphan为true时才可以被释放，可从referenceToClose函数中看出此逻辑。</p>
<p>Fresco使用InstrumentedMemoryCache包装了CountingMemoryCache，主要增加的功能就是提供了MemoryCacheTracker，会在缓存命中或未命中时提供回调函数，供使用者实现自定义功能。</p>
<p>Fresco的缓存调用处：</p>
<p>1.BitmapMemoryCacheProducer：已解码的内存缓存的调用处<br>2.EncodedMemoryCacheProducer：未解码的内存缓存的调用处<br>3.DiskCacheReadProducer：磁盘中未解码的内存缓存的调用处<br>4.NetworkFetchProducer:从网络获取图片的调用处</p>
<p>这里提一点Bitmap缓存：在5.0以下系统，Bitmap缓存位于ashmem，这样Bitmap对象的创建和释放将不会引发GC，更少的GC会使你的APP运行得更加流畅。5.0及其以上系统，相比之下，内存管理有了很大改进，所以Bitmap缓存直接位于Java的heap上。</p>
<h4 id="Fresco-与-Glide-的对比："><a href="#Fresco-与-Glide-的对比：" class="headerlink" title="Fresco 与 Glide 的对比："></a>Fresco 与 Glide 的对比：</h4><p>Glide：相对轻量级，用法简单优雅，支持 Gif 动态图，适合用在那些对图片依赖 不大的 App 中。 Fresco：采用匿名共享内存来保存图片，也就是 Native 堆，有 效的的避免了 OOM，功能强大，但是库体积过大，适合用在对图片依赖比较大 的 App 中。</p>
<h4 id="实现一个-ImageLoader-的流程"><a href="#实现一个-ImageLoader-的流程" class="headerlink" title="实现一个 ImageLoader 的流程"></a>实现一个 ImageLoader 的流程</h4><p>同步异步加载、图片压缩、内存硬盘缓存、网络拉取</p>
<p>1.同步加载只创建一个线程然后按照顺序进行图片加载<br>2.异步加载使用线程池，让存在的加载任务都处于不同线程<br>3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载</p>
<p>具体为：</p>
<p>1、ImageLoader 作为一个单例，提供了加载图片到指定控件的方法：直 接从内存缓存中获取对象，如果没有则用一个 ThreadPoolExecutor 去执 行 Runnable 任务来加载图片。ThreadPoolExecutor 的创建需要指定核心 线程数 CPU 数+1，最大线程数 CPU 数*2+1，线程闲置超市时长 10s,这几 个关键数据，还可以加入 ThreadFactory 参数来创建定制化的线程。<br>2、ImageLoader 的具体实现 loadBitmap：先从内存缓存 LruCache 中加 载，如果为空再从磁盘缓存中加载，加载成功后记得存入内存缓存，如果 为空则从网络中直接下载输出流到磁盘缓存，然后再从磁盘中加载，如果 为 空 并 且 磁 盘 缓 存 没 有 被 创 建 的 话 ， 直 接 通 过 BitmapFactory 的 decodeStream 获取网络请求的输入流获取 Bitmap 对象。<br>3、v4 包的 LruCache 可以兼容到 2.2 版本，LruCache 采用 LinkedHashMap 存储缓存对象。创建对象只需要提供缓存容量并重写 sizeOf 方法：作用 是计算缓存对象的大小。有时需要重写 entryRemoved 方法，用于回收一 些资源。<br>4、DiskLruCache 通过 open 方法创建，设置缓存路径，缓存容量。缓存 添加通过 Editor 对象创建输出流，下载资源到输出流完成后，commit， 如果失败则 abort 撤回。然后刷新磁盘缓存。缓存查找通过 Snapshot 对象获取输入流，获取 FileDescriptor，通过 FileDescriptor 解析出 Bitmap 对象。 5、列表中需要加载图片的时候，当列表在滑动中不进行图片加载，当滑 动停止后再去加载图片。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="webview相关（安全、调用方式、性能）"><a href="#webview相关（安全、调用方式、性能）" class="headerlink" title="webview相关（安全、调用方式、性能）"></a>webview相关（安全、调用方式、性能）</h2><p>客户端api通过native://method?para=x的方式出发，主要提供一些小程序和客户端的交互，对小程序屏蔽客户端差异。实现方式：java调用h5：webView.loadUrl(js); h5调用客户端：shouldOverrideUrlLoading拦截请求url。使用注解的方式维护方法名和method的映射关系，同时还可以指定方法是否可以立即返回。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>webview原生的安全漏洞：<br>1.addJavascriptInterface方法导致远程代码执行漏洞，前端可以获取到addJavascriptInterface的java对象的Class对象，Class.forName可以加载java.lang.Runtime 类,通过Runtime可以执行本地命令。该漏洞4.2版本后被修复，使用@JavascriptInterface进行注解从而避免漏洞攻击。<br>2.WebView默认开启密码保存功能，关键是密码会被明文存入 /data/data/com.package.name/databases/webview.db ,解决方案是关闭密码保存提醒<br>3.setAllowFileAccess允许小程序可以访问访问本地文件，容易导致本地隐私文件泄漏，setAllowUniversalAccessFromFileURLs设置是否允许通过 file url 加载的 Javascript 可以访问其他的源(包括http、https等源),setAllowFileAccessFromFileURLs设置是否允许通过 file url 加载的 Js代码读取其他的本地文件，小程序要求setAllowFileAccess(true)和setJavaScriptEnabled(true)让浏览器加载html和js代码，使用setAllowUniversalAccessFromFileURLs(false)和setAllowFileAccessFromFileURLs(false)禁止本地j访问文件。</p>
<p>客户端层面安全：<br>1.客户端api区分安全等级，有些方法需要授权才可以访问<br>2.客户端api白名单，有些api需要后台配置了才能访问<br>3.由于跨域问题，小程序的网络请求必须由客户端转发</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>1.客户端调用h5使用evaluateJavascript，比loadurl速度快<br>2.缓存最近打开的5个小程序，保留每个小程序打开的完整Fragment栈，在栈中的小程序可以做到秒开</p>
<p>###客户端与小程序的相互调用</p>
<p>1.客户端调用小程序：loadUrl与evaluateJavascript<br>2.小程序调用客户端：addJavascriptInterface、shouldOverrideUrlLoading和onJsPrompt三种方式</p>
<p>一个加载网页的过程中，native、网络、后端处理、CPU都会参与，各自都有必要的工作和依赖关系；让他们相互并行处理而不是相互阻塞才可以让网页加载更快：<br>WebView初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。<br>常用 JS 本地化及延迟加载，使用第三方浏览内核<br>后端处理慢，可以让服务器分trunk输出，在后端计算的同时前端也加载网络静态资源。<br>脚本执行慢，就让脚本在最后运行，不阻塞页面解析。<br>同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。<br>WebView初始化慢，就随时初始化好一个WebView待用。<br>DNS和链接慢，想办法复用客户端使用的域名和链接。</p>
<h2 id="应用启动流程"><a href="#应用启动流程" class="headerlink" title="应用启动流程"></a>应用启动流程</h2><p>从Launcher中点击快捷图标到启动根Activity过程中，主要涉及到4个进程的交互：Launcher所在应用进程、ActivityManagerService（后文简称AMS）所在的SystemServe系统进程、Zygote系统进程、目标根Activity所在的应用程序进程。</p>
<p>  （1）Launcher进程请求AMS创建根Activity。我们知道，在系统启动过程中，会启动SystemServer进程， AMS、PackageManagerService（后文简称PMS）也是在这个环节中启动的，所以AMS是运行在SystemServer进程当中的。应用的根Activity会在AndroidManifest.xml文件中注册，PMS解析出这些信息，并在Launcher中对这些包名、Activity路径及名称等信息进行封装，当点击快捷图标时，Launcher会调用startActivity方法去启动该图标所对应的根Activity。然后在Luancher进程中通过层层调用，直到通过Binder方式实现IPC，流程就进入到AMS中，也就是SystemServer进程中。</p>
<p>  （2）AMS请求创建根Activity所在的进程。AMS收到Launcher进程启动根Activity的请求后，会先判断根Activity所在的进程是否已经创建过了，如果没有创建过，则会向Zygote进程请求创建该进程，我们目前讨论的情形就是根Activity所在进程没有创建过的情况。我们知道，Zygote进程在启动的时候，会作为服务端创建一个名为“zygote”的Socket，用于监听AMS发起的创建新应用进程请求，所以此时流程进入到Zygote进程中。</p>
<p>  （3）Zygote进程fork出目标进程。Zygote收到AMS的请求后，会以fork的方式创建这个新的应用进程，此过程中会实例化一个ActivityThread对象，也就是一般所说的主线程，运行其入口main方法。</p>
<p>  （4）AMS调度应用进程创建和启动根Activity。根Activity所在的应用程序进程被创建后，AMS在SystemServer进程中也经过层层调用，最终又通过Binder方式实现IPC，将启动Activity的任务交给应用程序进程中的ApplicationThread本地代理，此后，流程进入到根Activity所在的应用程序进程中。这部分流程中，SystemServer中所做的工作主要是根Actifity创建和启动前的一些准备工作，比如判单当前用户权限，判断目标进程是否存在，判断activity是否已经创建，判断启动模式，判断是否注册等。</p>
<p>  （5）在应用进程中完成根Activity的创建和启动。在这里将创建根Activity实例、Applicaiton实例，调用各个生命周期方法，并将DecorView（布局文件中的View会添加到DecorView中）添加到Window中显示出来。 </p>
<h3 id="AMS相关"><a href="#AMS相关" class="headerlink" title="AMS相关"></a>AMS相关</h3><p>Activity的attach中生成PhoneWindow对象;PhoneWindow的setContentView中初始化DecorView（ViewGroup），同时使用LayoutInflater解析布局文件。在view中有一个getViewRootImpl，获取ViewRootImpl。在WindowmanagerGlobal中addView时创建ViewRootImpl,同时新建View.AttachInfo，viewrootImpl在performTraversals时将View.AttachInfo传给view。</p>
<p>ViewRootImp 在 onCreate() 时还没创建；在 onResume()时，即ActivityThread 的 handleResumeActivity() 执 行后才创建，调用 requestLayout()，走到 checkThread() 时就报错了。</p>
<p>Activity中持有WindowManager，addview是通过WindowManager调用到WindowManagerGlobal中的。</p>
<h3 id="WMS相关"><a href="#WMS相关" class="headerlink" title="WMS相关"></a>WMS相关</h3><p>Activity有一个phonewindow和WindowManager，phonewindow有一个decorView。activitythread在handleResumeActivity时从activity中取出WindowManager，调用addView（decorview），此时创建viewrootImpl，同时调用viewrootImpl.setView(decorview)，调用mWindowSession.addToDisplay将window添加到屏幕。</p>
<p>WindowManagerImpl代理给WindowManagerGlobal。WindowManagerGlobal中有IWindowSession和IWindowManager两个binder客户端，static修饰。WindowManagerGlobal中有三个List，分别为View、ViewRootImpl、WindowManager.LayoutParams，管理窗口级view的增删更新等，虽然最终的操作都是转发到ViewrootImpl中，在这里通过mWindowSession做ipc,然后结果通知回来更新WindowManagerGlobal中管理的参数。</p>
<p>Window定义了三种窗口类型：系统Window、应用程序Window、子Window。每一种窗口类型定义了一种对应的type。<br>应用类型的窗口的type范围是１<del>99，子窗口的type范围是1000</del>1999，系统的窗口的type范围是2000以上。</p>
<p>WindowState是WMS中事实的窗口，而不是Window，WindowState是在WMS的addWindow方法中创建，包含了一个窗口的所有的属性，其中一个属性为mLayer，表示窗口在Ｚ轴的位置，mLayer值越小，窗口越靠后，mLayer值越大，窗口越靠前，最前面的一个窗口就作为焦点窗口，可以接收触摸事件。因为窗口的切换，切换后的Ｚ序(窗口的显示次序称为 Z 序)就可能不同，所以mLayer的值不是固定不变的。mLayer是通过WindowState的另一个成员变量mBaseLayer的值计算得到，mBaseLayer的值是固定不变的，只和窗口类型有关。mBaseLayer(称为主序)是WindowState的构造方法中赋值。mBaseLayer =窗口类型×10000+1000。</p>
<h2 id="系统的启动过程"><a href="#系统的启动过程" class="headerlink" title="系统的启动过程"></a>系统的启动过程</h2><ol>
<li>linux内核启动后会启动第一个用户空间进程Init(pId=1),Init进程会解析和分析init.rc文件，rc文件中配置了各种程序和服务的启动项</li>
<li>在init.rc中也配置了Zygote进程的启动项，Zygote进程的执行文件/system/bin/app_process，实现代码为app_main.cpp，在main方法中启动了AndroidRuntime虚拟机，同时指定虚拟机执行com.android.internal.os.ZygoteInit，进入java世界</li>
<li>ZygoteInit的main方法中registerZygoteSocket(注册socket长连接)、preloadClasses、preloadResources、startSystemServer（开启system_server进程）、runSelectLoop(Zygote执行死循环监听socket)</li>
<li>startSystemServer中fork出system_server进程后执行handleSystemServerProcess初始化相关信息，其中层层调用到app_main.cpp中的onZygoteInit方法来初始化binder线程池。其中的RuntimeInit.zygoteInit故意抛出异常，ZygoteInit的main方法中捕获该异常，然后使用反射的方式执行异常中指定的class和method（system_server进程是SystemServer.main,该参数在startSystemServer方法中由代码指定；普通应用进程是ActivityThread.main，该参数从socket中读取）。SystemServer.main中启动system_server进程中的各种系统服务。</li>
</ol>
<h2 id="View相关（绘制、事件、MeasureSpec）"><a href="#View相关（绘制、事件、MeasureSpec）" class="headerlink" title="View相关（绘制、事件、MeasureSpec）"></a>View相关（绘制、事件、MeasureSpec）</h2><p>事件分发流程：<br>1.内核将原始事件写入到设备节点中，<br>2.IMS与AMS、WMS等一样都是是SyetemServer进程中创建，他的InputReader在其线程循环中不断地从EventHub中抽取原始输入事件，进行加工处理后将加工所得的事件放入InputDispatcher的派发发队列中。<br>3.InputDispatcher则在其线程循环中将派发队列中的事件取出，查找合适的窗口，将事件写入到窗口的事件接收管道中。<br>4.app进程：NativeInputReceiver::handleEvent()开始输入事件的接收，从InputEventReceiver开始输入事件被派发到用户界面；最终上传的java层的ViewRootImpl.WindowInputEventReceiver.dispatchInputEvent中。<br>5.ViewRootImpl经过处理将事件分发给DecorView.dispatchTouchEvent，DecorView然后转发给Activity，Activity调用Decor.superDispatchTouchEvent将事件转发回DecorView；<br>6.view层事件转发流程：dispatchTouchEvent—&gt;onInterceptTouchEvent–&gt;onTouchEvent，如果View都没有处理的话，则会回调到activity.onTouchEvent方法中。</p>
<p>view中requestLayout层层调用parent.requestLayout,其实最终是调用viewrootImpl.requestLayout的。requestLayout中检测了线程，只要创建viewrootImpl的线程和执行requestLayout线程是相同即可。</p>
<p>viewrootImpl.setView(decorview)时将调用view.assignParent(this);将viewrootImpl设置为view的parent。</p>
<p>viewrootImpl中requestLayout调用scheduleTraversals，mHandler.getLooper().postSyncBarrier()插入屏障消息, mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);为mTraversalRunnable注册16ms回调。mTraversalRunnable中执行performTraversals，大致为三个步骤performMeasure，performLayout，performDraw。</p>
<p>viewrootImpl的scheduleTraversals向Choreographer注册了CALLBACK_INPUT和CALLBACK_TRAVERSAL两种类型callback</p>
<h3 id="MeasureSpec的原理和计算规则"><a href="#MeasureSpec的原理和计算规则" class="headerlink" title="MeasureSpec的原理和计算规则"></a>MeasureSpec的原理和计算规则</h3><p>MeasureSpec 表示的是一个 32 位的整形值，它的高 2 位表示测量模式 SpecMode，低 30 位表示某种测量模式下的规格大小 SpecSize。MeasureSpec是 View 类的一个静态内部类，用来说明应该如何测量这个 View。它由三种测量 模式，如下：</p>
<p>EXACTLY：精确测量模式，视图宽高指定为 match_parent 或具体数值时生效，表示父视图已经决定了子视图的精确大小，这种模式下 View 的测量值就是 SpecSize 的值。</p>
<p>AT_MOST：最大值测量模式，当视图的宽高指定为 wrap_content 时生效， 此时子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。 </p>
<p>UNSPECIFIED：不指定测量模式, 父视图没有限制子视图的大小，子视图 可以是想要的任何尺寸，通常用于系统内部，应用开发中很少用到。</p>
<p>普通 View 的 MeasureSpec 的创建规则如下：<br>对于 DecorView 而言，它的 MeasureSpec 由窗口尺寸和其自身的 LayoutParams共同决定；对于普通的 View，它的 MeasureSpec 由父视图的 MeasureSpec 和其自身的 LayoutParams 共同决定。</p>
<h2 id="binder相关（binder背景、servicemanager、细节）"><a href="#binder相关（binder背景、servicemanager、细节）" class="headerlink" title="binder相关（binder背景、servicemanager、细节）"></a>binder相关（binder背景、servicemanager、细节）</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>1.Binder线程池的初始化是在其进程创建中完成的，Zygote进程调用Zygote.forkAndSpecialize()来fork出新进程，新进程会调用RuntimeInit.nativeZygoteInit初始化，其中binder的初始化的入口在app_main.cpp中的onZygoteInit方法中<br>2.初始化的第一步是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间；<br>3.启动Binder线程池，创建一个binder主线程（非主线程出现timeout则线程退出）。其余binder线程池中的线程都是由Binder驱动来控制创建的。<br>4.binder线程不断循环进行talkWithDriver()与binder驱动进行交互、使用executeCommand()执行Binder返回的响应码<br>5.talkWithDriver执行ioctl方法，这是一个系统调用，最终调用到Binder驱动中的Binder的ioctl，执行代码为binder_thread_write。驱动会调用copy_from_user()将用户空间IPC数据拷贝到内核态binder_write_read结构体；<br>6.executeCommand()也是和talkWithDriver类似，最终执行binder驱动的binder_thread_read<br>方法，copy_to_user()将用内核态binder_write_read结构体数据拷贝到用户空间；<br>注意：<br>1.默认地，每个进程的binder线程池的线程个数上限为16（15个非主线程和1个主线程），因为线程池数量的控制是在binder驱动层，驱动层发送创建新线程时会判断是否达到线程最大数，但是这个无法限制应用层创建binder线程和让线程加入binder线程池中。<br>2.Binder内存大小限制为1M-8K。普通app在初始化时调用mmap申请了1M-8K，虽然在内核中是限制了4M，但是依然还是1M-8K。ServiceManager进程binder仅仅申请了128K的内存，因为他不需要传输大量数据。<br>3.发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也 就相当于把数据发送到了接收进程的用户空间。</p>
<p>binder驱动层：<br>设备初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。分别对应应用程序的open、mmap、ioctl的调用。</p>
<p><a target="_blank" rel="noopener" href="http://gityuan.com/2016/10/29/binder-thread-pool/">http://gityuan.com/2016/10/29/binder-thread-pool/</a></p>
<h3 id="新建binder线程的条件-必须全部满足-："><a href="#新建binder线程的条件-必须全部满足-：" class="headerlink" title="新建binder线程的条件(必须全部满足)："></a>新建binder线程的条件(必须全部满足)：</h3><ol>
<li>当前进程中没有请求创建binder线程，即requested_threads = 0；</li>
<li>当前进程没有空闲可用的binder线程，即ready_threads = 0；（线程进入休眠状态的个数就是空闲线程数）</li>
<li>当前进程已启动线程个数小于最大上限(默认15)；</li>
<li>当前线程已接收到BC_ENTER_LOOPER或者BC_REGISTER_LOOPER命令，即当前处于BINDER_LOOPER_STATE_REGISTERED或者BINDER_LOOPER_STATE_ENTERED状态。</li>
</ol>
<h3 id="如何找到目标binder："><a href="#如何找到目标binder：" class="headerlink" title="如何找到目标binder："></a>如何找到目标binder：</h3><p>首先Service会通过addService将binder实体注册到ServiceManager中去，Client如果想要使用Servcie，就需要通过getService向ServiceManager请求该服务。在Service通过addService向ServiceManager注册的时候，ServiceManager会将服务相关的信息存储到自己进程的Service列表中去，同时在ServiceManager进程的binder_ref红黑树中为Service添加binder_ref节点，这样ServiceManager就能获取Service的Binder实体信息。而当Client通过getService向ServiceManager请求该Service服务的时候，ServiceManager会在注册的Service列表中查找该服务，如果找到就将该服务返回给Client，在这个过程中，ServiceManager会在Client进程的binder_ref红黑树中添加binder_ref节点，可见本进程中的binder_ref红黑树节点都不是本进程自己创建的，要么是Service进程将binder_ref插入到ServiceManager中去，要么是ServiceManager进程将binder_ref插入到Client中去。之后，Client就能通过Handle句柄获取binder_ref，进而访问Service服务。</p>
<p>注意：Client端的binder请求线程，比如我们APP的主线程，在startActivity请求AMS的时候，APP的主线程成其实就是Binder请求线程，在进行Binder通信的过程中，Client的Binder请求线程会一直阻塞，知道Service处理完毕返回处理结果。如果使用ONE_WAY方式请求，Client则不需要阻塞等待服务端响应，这种场景一般主要是用来通知，至于通知被谁消费，是否被消费压根不会关心。拿ContentService服务为例子，它是一个全局的通知中心，负责转发通知，而且，一般是群发，由于在转发的时候，ContentService被看做Client，如果这个时候采用普通的同步阻塞势必会造成通知的延时发送送，所以这里的Client采用了oneway，异步。</p>
<h3 id="系统服务与bindService"><a href="#系统服务与bindService" class="headerlink" title="系统服务与bindService"></a>系统服务与bindService</h3><p>系统服务一般都是SystemServer进程负责启动，比如AMS，WMS，PKMS，电源管理等，这些服务本身其实实现了Binder接口，作为Binder实体注册到ServiceManager中，被ServiceManager管理，而SystemServer进程里面会启动一些Binder线程，主要用于监听Client的请求，并分发给响应的服务实体类，可以看出，这些系统服务是位于SystemServer进程中（有例外，比如Media服务）。这些服务一般都是需要拥有特定的权限才能注册到ServiceManager，普通的进程是没有权限注册到ServiceManager中的。</p>
<p>Activity的bindService流程，可以按以下几步来分析</p>
<ul>
<li><p>1、Activity调用bindService：通过Binder通知ActivityManagerService，要启动哪个Service</p>
</li>
<li><p>2、ActivityManagerService创建ServiceRecord，并利用ApplicationThreadProxy回调，通知Service App端新建并启动Service启动起来</p>
</li>
<li><p>3、ActivityManagerService把Service启动起来后，启动后service会调用writeStrongBinder将binder传入给AMS</p>
</li>
<li><p>4、ActivityManagerService把从Service处得到这个Binder对象传给Activity，这里是通过IServiceConnection binder实现。</p>
</li>
<li><p>5、Activity被唤醒后通过Binder Stub的asInterface函数将Binder转换为代理Proxy，完成业务代理的转换，之后就能利用Proxy进行通信了。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9128f1b65586">https://www.jianshu.com/p/9128f1b65586</a></p>
</li>
</ul>
<h3 id="ipc种类"><a href="#ipc种类" class="headerlink" title="ipc种类"></a>ipc种类</h3><p>为什么选用 Binder，在讨论这个问题之前，我们知道 Android 也是基于 Linux 内核，Linux 现有的进程通信手段有以下几种：<br>1.管道：在创建时分配一个 page 大小的内存，缓存区大小比较有限；<br>2.消息队列：信息复制两次，额外的 CPU 消耗；不合适频繁或信息量大的通信；<br>3.共享内存：无须复制，共享缓冲区直接附加到进程虚拟地址空间，速度快； 但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；<br>4.套接字：作为更通用的接口，传输效率低，主要用于不同机器或跨网络的 通信；<br>5.信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程 也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同 步手段。 不适用于信息交换，更适用于进程中断控制，比如非法内存访 问，杀死某个进程等；</p>
<h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><p> 大量数据使用binder的传递的方式：</p>
<ul>
<li>非跨进程，使用静态变量来避免大量数据的拷贝，或者使用Eventbus等框架进行引用传递。</li>
<li>分批次传输，例如分页</li>
<li>对效率要求不高，可以使用socket或者文件方式。</li>
<li>使用ashmem匿名共享内存。使用例子Bundle.putBinder、ContentProvider、MemoryFile。推荐使用这个方式。</li>
</ul>
<p>tip：Intent如果允许传输文件符，则可以避免大量数据拷贝。但是startActivity时会调用 setAllowFds(false)禁止掉文件符传输。</p>
<p>binder是为了ipc(进程间通信)设计的，并不是为了数据传输设计的。</p>
<h2 id="handler相关"><a href="#handler相关" class="headerlink" title="handler相关"></a>handler相关</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p>1.以主线程handler为例，在ActivityThread的main方法中调用Looper.prepareMainLooper()，初始化与当前线程关联的Looper对象，Looper对象优先从ThreadLocal中获取，如果没有则为当前线程创建新对象。Looper初始化中会创建MessageQueen队列，这个一个基于Message的执行时间when排序的队列；<br>2.Looper.loop()，让当前线程死循环运行，每一次循环都是从MessageQueen.next()中获取Message，当message为null时，说明线程想结束当前死循环，结束消息队列。不为null时，则执行message.target.dispatchMessage分发消息；<br>3.handler分发消息的流程是：msg有自己的callback时，执行callback;否则执行通用分发流程，首先如果handler的mCallback不为空，执行mCallback.handleMessage(msg)，如果msg被处理掉，则结束分发流程。如果没有被处理掉，则执行handler的handleMessage方法，对msg做处理。</p>
<p>补充：<br>1.next获取消息流程：MessageQueen队列是基于消息的执行时间排序的队列，是使用链表方式实现的，当在遍历链表时遇到屏障消息（target为null的消息）时，此时只会从队列中获取异步消息来处理，当屏障消息被移除时，则会按照队列顺序获取消息，其实也是按照执行时间大小获取消息；<br>2.当消息队列为null或者当前消息还没有到执行时间时，此时会执行IdleHandler列表，这个列表，这就是所谓的闲时handler机制，当idleHandler返回false时，表示该idleHandler只执行一次，在执行完以后将该idlehandler会从列表中移除。<br>3.当队列中没有消息或者消息还没有到执行时间，next方法会调用nativePollOnce()进入堵塞状态。<br>4.message维护了一个sPoolSync的消息回收池，当消息需要recycle时，将当前回收的消息清除掉相关数据然后加入缓存池中，而Message.obtain创建消息时，则可以从缓存池中获取，这种做法可以避免频繁的创建Message对象。缓存池默认大小为50。<br>5.注意使用Handler关联线程，该线程必须Looper.prepare()做好了初始化。子线程中Toast和Dialog的show发生crash原因：Toast和dialog里面有使用到new Handler()，如果子线程没有Looper.prepare();则会导致crash。</p>
<h3 id="屏障消息使用场景："><a href="#屏障消息使用场景：" class="headerlink" title="屏障消息使用场景："></a>屏障消息使用场景：</h3><p>UI的刷新消息为什么不会被其他消息阻塞：在ViewRootImpl中scheduleTraversals里面先调用postSyncBarrier发送同步屏障消息(message中没有target)，然后向Choreographer注册同步回调监听接口，收到同步回调后向handler发送异步消息。在messagequeue中next取消息时，一旦发现没有target的消息，则优先执行异步消息。设置了屏障消息，此时只会处理异步消息，处理完异步消息后就会堵塞。如果想要恢复同步消息，需要调用 removeSyncBarrier()移除。postSyncBarrier是一个系统hide的方法，他是在插入了一个when为当前时间的消息。</p>
<h3 id="idleHandler的使用场景："><a href="#idleHandler的使用场景：" class="headerlink" title="idleHandler的使用场景："></a>idleHandler的使用场景：</h3><p>dleHandler 是 Handler 提供的一种在消息队列空闲时，执行任务的时机。但它执行的时机依赖消息队列的情况，那么如果 MessageQueue 一直有待执行的消息时，IdleHandler 就一直得不到执行，也就是它的执行时机是不可控的，不适合执行一些对时机要求比较高的任务。ActivityThread.GcIdler 是在内存不足时，强行 GC；在ActivityThread中的H收到GC_WHEN_IDLE消息后，会执行scheduleGcIdler，将GcIdler添加到MessageQueue中的空闲任务集合中。<br>Instrumentation.Idler 调用的时机就比较多了，是键盘相关的调用；<br>Instrumentation.ActivityGoing 在 Activity onCreate() 执行前添加；<br>ActivityThread.Idler 在 ActivityThread.handleResumeActivity() 中调用。</p>
<h3 id="native层的消息机制："><a href="#native层的消息机制：" class="headerlink" title="native层的消息机制："></a>native层的消息机制：</h3><p>1.java层的Looper创建时会创建MessageQueue，MessageQueue构造方法中调用nativeInit方法到native层，此方法主要作用是创建native层的MessageQueue，并创建native层的Looper，在Looper构造函数中创建了唤醒事件文件描述符mWakeEventFd，并调用rebuildEpollLocked函数创建epoll，epoll创建之后会添加mWakeEventFd以及mRequests中的所有fd(这里主要添加的是Input事件，如键盘、传感器输入)进行监听。这里一定要明白的是，添加这些fd除了mWakeEventFd负责解除阻塞让程序继续运行，从而处理Native Message和Java Message外，其他fd与Message的处理其实毫无关系。<br>2.java层Looper通过loop方法死循环调用MessageQueue的next方法获取msg，在next方法中会先调用nativePollOnce到native层去处理native的msg，首先会处理没有Callback方法的Response事件，接着调用pollInner函数，此函数里调用epoll_wait陷入等待，唤醒条件有三个：（1）超时唤醒，（2）发生异常唤醒，（3）收到事件上报，无论mWakeEventFd事件还是其他事件，epoll被唤醒后会根据eventCount事件数量遍历处理事件，处理顺序是，首先MessageEnvelope中的msg，其次mResponses中的request的callback，最后返回java层，处理java的msg<br>3.nativeWake用作唤醒epoll，简单的向mWakeEventFd写入一个字符，起到通知的作用。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34211365/article/details/104376066">https://blog.csdn.net/qq_34211365/article/details/104376066</a></p>
<p>与java层消息机制的比较：</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><h3 id="BlockCanary"><a href="#BlockCanary" class="headerlink" title="BlockCanary"></a>BlockCanary</h3><p>在Looper类中有一个Printer，在Looper.loop()方法中在取出一个msg后，在调用dispatchMessage进行消息分发的前后都会调用Printer输出日志。BlockCanary就是通过分析这两次日志来检测是否出现消息分发处理不及时的情况，这种情况往往会导致界面卡顿。</p>
<p>流程<br>BlockCanary.install().start()<br>install时：<br>1.构建线程堆栈信息的采集类 StackSampler。<br>2.构建 CPU 使用信息的采集类 CpuSampler。<br>3.构建 Looper 内日志打印的类 LooperMonitor。如果主线程发生了卡顿，就会触发 LooperMonitor.onBlockEvent() 方法。在 LooperMonitor.onBlockEvent() 中获取指定时间范围内的堆栈信息和CPU信息，并写入日志文件。并且触发外部的回调，将采集到的数据提供给外部进行自定义的操作。<br>start时将将自定义的 Printer（LooperMonitor） 赋值给主线程的 Looper。</p>
<p>StackSampler和CpuSampler执行任务采集功能是在子线程中执行的，他是每间隔 mSampleInterval （默认300毫秒）时间，就会执行采集任务。</p>
<p>StackSampler：<br>1.通过 Thread.getStackTrace() 方法获取当前线程的堆栈信息。<br>2.采集的堆栈信息大于指定条数就移除最早的数据。<br>3.将当前采集时间作为Key进行存储，便于后面根据线程阻塞时间来进行堆栈数据的筛选。</p>
<p>CpuSampler：读取并解析 /proc/stat 和 /proc/ + mPid + /stat 文件里的数据信息。CPU 信息默认只缓存10条，所以在获取的时候，不做时间区间的过滤。</p>
<p>缺点：<br>1.准确性，由于其使用0.8倍的卡顿阈值作为采样点，仍可能出现不能准确识别卡顿函数的情况。<br>2.细粒度的函数耗时评估，BlockCanary只能告诉我们当前的卡顿函数是哪个，但不能准确的告知到底卡顿了多久</p>
<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p>HandlerThread 本质上是一个线程类，它继承了 Thread。<br>HandlerThread.start()后执行run方法，执行 Looper.prepare()和Looper.loop()，可以使用quit 或者 quitSafely 方法停止Looper循环。</p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>IntentService 是一个抽象类，封装了 HandlerThread。</p>
<p>当 IntentService 被 第一次启动时，它的 onCreate()方法会被调用，onCreat()方法会创建一个 HandlerThread，在onStartCommand()中传入的Intent对象会被发送到HandlerThread处理。在所有的请求(Intent) 都被执行完以后会自动停止服务，所以，你不需要自己去调用 stopSelf()方法来 停止。 该服务提供了一个 onBind()方法的默认实现，它返回 null。</p>
<p>为什么在 mServiceHandler 的 handleMessage()回调方法中执行完 onHandlerIntent()方法后要使用带 参数的 stopSelf()方法？<br>因为 stopSel()方法会立即停止服务，而 stopSelf（int startId）会等待所有的消 息都处理完毕后才终止服务，一般来说，stopSelf(int startId)在尝试停止服务之 前会判断最近启动服务的次数是否和 startId 相等，如果相等就立刻停止服务， 不相等则不停止服务。</p>
<p>1.不建议通过bindService()启动IntentService<br>如果采用bindService()启动IntentService的声明周期：onCreate() -&gt;&gt; onBind() -&gt;&gt; onunbind()-&gt;&gt; onDestory()即，并不会调用onStart或onStartCommand，所以不会将消息发送给消息队列，那么onHandleIntent将不会调用。即无法实现多线程的操作。<br>2.若服务停止，则会清除消息队列中的消息，后续的事件不执行。再调用了startService，将重新开启一个新的IntentService。<br>3.Android 8.0 启动后台service 出错 IllegalStateException: Not allowed to start service Intent</p>
<h2 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h2><h3 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h3><p>在 Android 上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户 显示一个对话框，这个对话框称作应 用程序无响应（ANR：Application NotResponding）对话框。 用户可以选择让程序继续运行，但是，他们在使用 你的 应用程序时，并不希望每次都要处理这个对话框。因此 ，在程序里对响应 性能的设计很重要这样，这样系统就不会显 示 ANR 给用户。</p>
<ul>
<li>InputDispatching Timeout：5秒内无法响应屏幕触摸事件或键盘输入事件</li>
<li>BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的onReceive()函数时10秒没有处理完成，后台为60秒。有序广播的总执行时间超过 2* receiver个数 * timeout时长，则会触发anr。</li>
<li>Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。</li>
<li>ContentProvider Timeout ：ContentProvider的publish在10s内没进行完。</li>
</ul>
<p>对于Service, Broadcast, Input发生ANR之后,最终都会调用AMS.appNotResponding;对于provider,在其进程启动时publish过程可能会出现ANR, 则会直接杀进程以及清理相应信息,而不会弹出ANR的对话框. </p>
<p>实现原理：<br>Service：ActiveServices的realStartServiceLocked在scheduleCreateService前bumpServiceExecutingLocked埋下一颗炸弹(其实就是发送delay消息)，如果不能在指定时间前移除消息，则会炸弹引爆，执行appNotResponding逻辑。ActivityThread中handleCreateService中在service.onCreate();执行完就会向AMS回调serviceDoneExecuting拆除炸弹。同理service的onBind、onStartCommand等方法。</p>
<p>前台广播队列与后台广播队列的区别：<br>1.前台广播队列的超时时间比后台广播队列短很多<br>2.后台广播队列在当前用户后台启动服务超过阈值时会暂停广播<br>3.前台广播允许接收者以前台优先级运行</p>
<h3 id="ANR排查"><a href="#ANR排查" class="headerlink" title="ANR排查"></a>ANR排查</h3><p>发生anr后会在/data/anr/traces.txt 输出相关信息。无论哪种类型的ANR发生以后，最终都会调用 AppErrors.appNotResponding() 方法，方法中就包含了ANR报告生成格式。</p>
<p>除了主体逻辑，发生ANR时还会输出各种类别的日志：<br><strong>event log</strong>：通过检索”am_anr”关键字，可以找到发生ANR的应用<br><strong>main log</strong>：通过检索”ANR in “关键字，可以找到ANR的信息，日志的上下文会包含CPU的使用情况<br><strong>dropbox</strong>：通过检索”anr”类型，可以找到ANR的信息<br><strong>traces</strong>：发生ANR时，各进程的函数调用栈信息</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huansky/p/13944132.html">https://www.cnblogs.com/huansky/p/13944132.html</a></p>
<h2 id="构建与安装"><a href="#构建与安装" class="headerlink" title="构建与安装"></a>构建与安装</h2><h3 id="打包流程（流程、app组成）"><a href="#打包流程（流程、app组成）" class="headerlink" title="打包流程（流程、app组成）"></a>打包流程（流程、app组成）</h3><p>1.通过 AAPT 工具进行资源文件（包括 AndroidManifest.xml、布局文件、 各种 xml 资源等）的打包，生成 R.java 文件。<br>2.通过 AIDL 工具处理 AIDL 文件，生成相应的 Java 文件。<br>3.通过 Java Compiler 编译 R.java、Java 接口文件、Java 源文件，生成.class 文件。<br>4.通 过 dex 命 令 ， 将 .class 文 件 和第 三 方 库 中 的 .class 文 件 处 理生成 classes.dex，该过程主要完成 Java 字节码转换成 Dalvik 字节码，压缩常 量池以及清除冗余信息等工作。<br>5.通过 ApkBuilder 工具将资源文件、DEX 文件打包生成 APK 文件。<br>6.通过 Jarsigner 工具，利用 KeyStore 对生成的 APK 文件进行签名。<br>7.如果是正式版的 APK，还会利用 ZipAlign 工具进行对齐处理，对齐的过 程就是将 APK 文件中所有的资源文件距离文件的起始距位置都偏移 4 字 节的整数倍，这样通过内存映射访问 APK 文件的速度会更快，并且会减 少其在设备上运行时的内存占用。 </p>
<p>apk 组成<br>1.dex：最终生成的 Dalvik 字节码。<br>2.res：存放资源文件的目录。<br>3.asserts：额外建立的资源文件夹。<br>4.lib：如果存在的话，存放的是 ndk 编出来的 so 库。<br>5.META-INF：存放签名信息 MANIFEST.MF（清单文件）：其中每一个资源文件都有一个 SHA-256-Digest 签 名，MANIFEST.MF 文件的 SHA256（SHA1）并 base64 编码的结果即为 CERT.SF 中的 SHA256-Digest-Manifest 值。</p>
<p>CERT.SF（待签名文件）：除了开头处定义的 SHA256（SHA1）-Digest-Manifest 值，后面几项的值是对 MANIFEST.MF 文件中的每项再次 SHA256 并 base64 编 码后的值。<br>CERT.RSA（签名结果文件）：其中包含了公钥、加密算法等信息。首先对前一 步生成的 MANIFEST.MF 使用了 SHA256（SHA1）-RSA 算法，用开发者私钥签 名，然后在安装时使用公钥解密。最后，将其与未加密的摘要信息（MANIFEST.MF 文件）进行对比，如果相符，则表明内容没有被修改。</p>
<p>androidManifest：程序的全局清单配置文件。<br>resources.arsc：编译后的二进制资源文件</p>
<h3 id="APK安装"><a href="#APK安装" class="headerlink" title="APK安装"></a>APK安装</h3><p>复制 APK 到/data/app 目录下，解压并扫描安装包。</p>
<p>资源管理器解析 APK 里的资源文件。</p>
<p>解析 AndroidManifest 文件，并在/data/data/目录下创建对应的应用数据目录。</p>
<p>然后对 dex 文件进行优化，并保存在 dalvik-cache 目录下。</p>
<p>将 AndroidManifest 文件解析出的四大组件信息注册到 PackageManagerService 中。</p>
<p>安装完成后，发送广播。</p>
<h2 id="Service保活（保活、复活）"><a href="#Service保活（保活、复活）" class="headerlink" title="Service保活（保活、复活）"></a>Service保活（保活、复活）</h2><p>Android 进程不死从 3 个层面入手：</p>
<p>A.提供进程优先级，降低进程被杀死的概率 </p>
<p>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动 1 个像素的 Activity，在用 户解锁时将 Activity 销毁掉。</p>
<p>方法二：启动前台 service。</p>
<p>方法三：提升 service 优先级：</p>
<p>在 AndroidManifest.xml 文件中对于 intent-filter 可以通过 android:priority = “1000”这个属性设置最高优先级，1000 是最高值，如果数字越小则优先级越低， 同时适用于广播。 </p>
<p>B. 在进程被杀死后，进行拉活 </p>
<p>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等 </p>
<p>方法二：双进程相互唤起。</p>
<p> 方法三：依靠系统唤起。 </p>
<p>方法四：onDestroy 方法里重启 service：service + broadcast 方式，就是当 service 走 ondestory 的时候，发送一个自定义的广播，当收到广播的时候，重新启动 service；</p>
<p>C. 依靠第三方</p>
<p>根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推 送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。</p>
<h3 id="保活方案"><a href="#保活方案" class="headerlink" title="保活方案"></a>保活方案</h3><p>1、AIDL 方式单进程、双进程方式保活 Service。（基于 onStartCommand() return START_STICKY）<br>START_STICKY 在运行 onStartCommand 后 service 进程被 kill 后，那将保留在 开始状态，但是不保留那些传入的 intent。不久后 service 就会再次尝试重新创 建，因为保留在开始状态，在创建 service 后将保证调用 onstartCommand。如 果没有传递任何开始命令给 service，那将获取到 null 的 intent。<br>除了华为此方案无效以及未更改底层的厂商不起作用外（START_STICKY 字段就 可以保持 Service 不被杀）。此方案可以与其他方案混合使用</p>
<p>2、降低 oom_adj 的值（提升 service 进程优先级）：<br>Android 中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进 行进程的回收。Android 将进程分为 5 个等级,它们按优先级顺序由高到低依次是:<br>1.前台进程 (Foreground process)<br>2.可见进程 (Visible process)<br>3.服务进程 (Service process)<br>4.后台进程 (Background process)<br>5.空进程 (Empty process)</p>
<p>当 service 运行在低内存的环境时，将会 kill 掉一些存在的进程。因此进程的优 先级将会很重要，可以使用 startForeground 将 service 放到前台状态。这样在 低内存时被 kill 的几率会低一些。</p>
<p>常驻通知栏（可通过启动另外一个服务关闭 Notification，不对 oom_adj 值有影响）。<br>使用”1 像素“的 Activity 覆盖在 getWindow()的 view 上。此方案无效果<br>循环播放无声音频（黑科技，7.0 下杀不掉）。<br>成功对华为手机保活。小米 8 下也成功突破 20 分钟<br>3、监听锁屏广播：使 Activity 始终保持前台。<br>4、使用自定义锁屏界面：覆盖了系统锁屏界面。<br>5、通过 android:process 属性来为 Service 创建一个进程。<br>6、跳转到系统白名单界面让用户自己添加 app 进入白名单</p>
<p>复活方案:<br>1、onDestroy 方法里重启 service<br>service + broadcast 方式，就是当 service 走 onDestory 的时候，发送一个自定 义的广播，当收到广播的时候，重新启动 service。</p>
<p>2、JobScheduler：原理类似定时器，5.0,5.1,6.0 作用很大，7.0 时候有一定影响 （可以在电源管理中给 APP 授权）。只对 5.0，5.1、6.0 起作用。</p>
<p>3、推送互相唤醒复活：极光、友盟、以及各大厂商的推送。</p>
<p>4、同派系 APP 广播互相唤醒：比如今日头条系、阿里系。</p>
<p>此外还可以监听系统广播判断 Service 状态，通过系统的一些广播，比如：手机 重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的 Service 是 否还存活。<br>结论：高版本情况下可以使用弹出通知栏、双进程、无声音乐提高后台服务的 保活概率。</p>
<h2 id="ListView-amp-RecyclerView（缓存）"><a href="#ListView-amp-RecyclerView（缓存）" class="headerlink" title="ListView &amp; RecyclerView（缓存）"></a>ListView &amp; RecyclerView（缓存）</h2><p>ListView 的基础使用：<br>1.继承重写 BaseAdapter 类<br>2.自定义 ViewHolder 和 convertView 一起完成复用优化工作</p>
<p>RecyclerView 基础使用关键点同样有两点：<br>1.继承重写 RecyclerView.Adapter 和 RecyclerView.ViewHolder<br>2.设置布局管理器，控制布局效果</p>
<p>缓存：<br>RecyclerView比ListView多两级缓存，支持多个离ItemView缓存，支持开发者自定义缓存处理逻辑，支持所有RecyclerView共用同一个RecyclerViewPool(缓存池)。<br>具体来说：<br>ListView(两级缓存)：<br>RecyclerView(四级缓存)：</p>
<p>列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。</p>
<p>问题：<br>1.RecyclerView 与 ListView 缓存机制的不同？<br>2.想改变 listview 的高度，怎么做？<br>3.listview 跟 recyclerview 上拉加载的时候分别应该如何处理？<br>4.如何自己实现 RecyclerView 的侧滑删除？<br>5.RecyclerView 的 ItemTouchHelper 的实现原理</p>
<h3 id="Davilk、ART区别"><a href="#Davilk、ART区别" class="headerlink" title="Davilk、ART区别"></a>Davilk、ART区别</h3><p>Dalvik:从安卓诞生之初到4.4版本，最开始使用解析器解析字节码，在2.2中引入JIT编译器，使得Dalvik 的性能提升了 3~6 倍。但是由于JIT每次启动应用都要重新编译，导致耗电严重。在4.4中引入ART虚拟机的预览版和AOT编译策略，此时Davilk和ART是共存的，用户可以自由选择。</p>
<p>ART：5.0时正式取代Dalvik，AOT也成为唯一的编译策略，同时也改成了GC的过程。AOT虽然解决了每次都要重新编译和耗电的问题，但是也引入了新问题：应用安装和系统升级之后的应用优化比较耗时、优化后的文件会占用额外的存储空间。于是在7.0的时候JIT编译器回归，这种混合编译的特点：</p>
<ol>
<li>应用在安装的时候 dex 不会被编译；</li>
<li>应用在运行时 dex 文件先通过解析器（Interpreter）后会被直接执行，与此同时，热点函数（Hot Code）会被识别并被 JIT 编译后存储在 jit code cache 中并生成 profile 文件以记录热点函数的信息；</li>
<li>手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译。</li>
</ol>
<p>混合编译模式综合了 AOT 和 JIT 的各种优点，使得应用在安装速度加快的同时，运行速度、存储空间和耗电量等指标都得到了优化。</p>
<p>OT 和 JIT 的不同之处在于：JIT 是在运行时进行编译，是动态编译，并且每次运行程序的时候都需要对 odex 重新进行编译；而 AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex 预编译成 ELF 文件，每次运行程序的时候不用重新编译，是真正意义上的本地应用。</p>
<h2 id="热修复与插件化（历史、流程、）"><a href="#热修复与插件化（历史、流程、）" class="headerlink" title="热修复与插件化（历史、流程、）"></a>热修复与插件化（历史、流程、）</h2><p>热修复流程：</p>
<p>资源和代码的热修复；资源热修复：新建AssetManager，使用addAssetPath指向新路径，然后替换AssetManager 类型的 mAssets 字段的引用全部替换为新创建的 AssetManager。代码热修复分为dex和so，dex修复分三种 1类加载方案（QQ 空间的超级补丁和微信Tinker）2底层替换方案，ArtMethod变动（AndFix、Dexposed、阿里百川、Sophix）3 Instant Run 借助ASM变更字节码（Robust 和 Aceso）。so库的话重新加载即可。</p>
<p>插件化：</p>
<p>主流的插件化方案有滴滴任玉刚的 VirtualApk、360 的 DroidPlugin、 RePlugin、Wequick 的 Small 框架，Alibaba 的 Atlas。</p>
<p>四大组件的插件：Activity 插件化：1.反射：对性能有影响，主流的插件化框架没有采用此方式。2.接口：dynamic-load-apk 采用。3.Hook：主流。Hook 实现方式有两种：Hook IActivityManager（ActivityManager中的IActivityManagerSingleton修改，ActivityThread 的 H 处恢复） 和 Hook Instrumentation（Instrumentation的execStartActivity修改，performLaunchActivity出恢复）。流程：1、占坑、通过校验：2.还原插件 Activity 3、插件 Activity 的生命周期：<br>Service：通过代理Service的方式去分发，VirtualAPK使用了两个代理Service，即LocalService和RemoteService。<br>BroadcastReceiver：将静态广播转为动态广播。<br>ContentProvider：通过一个代理Provider进行操作的分发。</p>
<p>资源插件化：<br>资源的插件化和热修复的资源修复都借助了 AssetManager。<br>资源的插件化方案主要有两种：<br>1.合并资源方案，将插件的资源全部添加到宿主的 Resources 中，这种 方案插件可以访问宿主的资源。<br>2.构建插件资源方案，每个插件都构造出独立的 Resources，这种方案 插件不可以访问宿主资源。</p>
<h2 id="OkHttp-实现原理（好处、拦截器）"><a href="#OkHttp-实现原理（好处、拦截器）" class="headerlink" title="OkHttp 实现原理（好处、拦截器）"></a>OkHttp 实现原理（好处、拦截器）</h2><p>** 什么是动态代理？和静态代理的区别是什么？JDK中动态代理是怎么实现的？</p>
<p>在项目中你有用到哪些设计模式？解决了什么问题？</p>
<p>怎么使用OkHttp或者Retrofit完成文件下载上传？</p>
<p>如果网络比较差，2G/3G，怎么进行弱网优化？</p>
<p>Http1和Http2的区别是什么?</p>
<p>谈谈TCP与UDP的理解</p>
<p>okhttp为什么会使用okio而不是用普通io</p>
<p>socket连接池怎么复用的</p>
<p>tcp怎么拥塞控制？SSL的握手和采用的加密算法</p>
<p>okHttp进行网络请求优化的原理? **</p>
<p>网络底层库，它是基于 http 协议封装的一套请求客户端，虽然它也可以开线程， 但根本上它更偏向真正的请求，跟 HttpClient, HttpUrlConnection 的职责是一样 的。其中封装了网络请求 get、post 等底层操作的实现。</p>
<p>为什么要在项目中使用这个库？</p>
<p>1.OkHttp 提供了对最新的 HTTP 协议版本 HTTP/2 和 SPDY 的支持，这 使得对同一个主机发出的所有请求都可以共享相同的套接字连接。<br>2.如果 HTTP/2 和 SPDY 不可用，OkHttp 会使用连接池来复用连接以提 高效率。<br>3.OkHttp 提供了对 GZIP 的默认支持来降低传输内容的大小。<br>4.OkHttp 也提供了对 HTTP 响应的缓存机制，可以避免不必要的网络请求。<br>5.当网络出现问题时，OkHttp 会自动重试一个主机的多个 IP 地址。</p>
<p>OkHttp 内部的请求流程：使用 OkHttp 会在请求的时候初始化一个 Call 的实例， 然后执行它的 execute()方法或 enqueue()方法，内部最后都会执行到 getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任 链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、 连接拦截器和用户自定义网络拦截器以及访问服务器拦截器等拦截处理过程，来 获取到一个响应并交给用户。其中，除了 OKHttp 的内部请求流程这点之外，缓存和连接这两部分内容也是两个很重要的点，掌握了这 3 点就说明你理解了OkHttp。</p>
<p>各个拦截器的作用：</p>
<p>interceptors：用户自定义拦截器<br>retryAndFollowUpInterceptor：重试拦截器，负责失败重试以及重定向<br>BridgeInterceptor：桥接拦截器，请求时，对必要的 Header 进行一些添加，接收响应时，移除必要的 Header<br>CacheInterceptor：缓存拦截器，负责读取缓存直接返回（根据请求的信息和缓存的响 应的信息来判断是否存在缓存可用）、更新缓存<br>ConnectInterceptor：连接拦截器，负责和服务器建立连接</p>
<p>ConnectionPool：</p>
<p>1、判断连接是否可用，不可用则从 ConnectionPool 获取连接，ConnectionPool</p>
<p>无连接，创建新连接，握手，放入 ConnectionPool。</p>
<p>2、它是一个 Deque，add 添加 Connection，使用线程池负责定时清理缓存。</p>
<p>3、使用连接复用省去了进行 TCP 和 TLS 握手的一个过程。</p>
<p>networkInterceptors：用户定义网络拦截器</p>
<p>CallServerInterceptor：负责向服务器发送请求数据、从服务器读取响应 数据</p>
<p>你从这个库中学到什么有价值的或者说可借鉴的设计思想？</p>
<p>使用责任链模式实现拦截器的分层设计，每一个拦截器对应一个功能，充分实现 了功能解耦，易维护。</p>
<h4 id="HttpUrlConnection-和-okhttp-关系"><a href="#HttpUrlConnection-和-okhttp-关系" class="headerlink" title="HttpUrlConnection 和 okhttp 关系"></a>HttpUrlConnection 和 okhttp 关系</h4><p>从Android4.4开始HttpURLConnection的底层实现采用的是okHttp。</p>
<h4 id="Volley-与-OkHttp-的对比："><a href="#Volley-与-OkHttp-的对比：" class="headerlink" title="Volley 与 OkHttp 的对比："></a>Volley 与 OkHttp 的对比：</h4><p>Volley：支持 HTTPS。缓存、异步请求，不支持同步请求。协议类型是 Http/1.0, Http/1.1，网络传输使用的是 HttpUrlConnection/HttpClient，数据读写使用的 IO。 OkHttp：支持 HTTPS。缓存、异步请求、同步请求。协议类型是 Http/1.0, Http/1.1, SPDY, Http/2.0, WebSocket，网络传输使用的是封装的 Socket，数据 读写使用的 NIO（Okio）。 SPDY 协议类似于 HTTP，但旨在缩短网页的加载时 间和提高安全性。SPDY 协议通过压缩、多路复用和优先级来缩短加载时间。</p>
<h4 id="衍生问题："><a href="#衍生问题：" class="headerlink" title="衍生问题："></a>衍生问题：</h4><p>自己去设计网络请求框架，怎么做？</p>
<p>从网络加载一个 10M 的图片，说下注意事项？</p>
<p>http怎么知道文件过大是否传输完毕的响应？</p>
<p>谈谈你对 WebSocket 的理解？</p>
<p>WebSocket 与 socket 的区别？</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>启动流程源码、ViewRootImpl深入结合view的绘制、OkHttp、Glide源码流程、RecyclerView源码</p>
<p>Handler步骤<br>工作原理<br>异步消息、屏障消息、native层消息<br>HandlerThread的使用</p>
<p>Binder<br>ipc的种类与选择<br>工作原理<br>Proxy、Server、ServiceManager<br>注意事项</p>
<p>ViewRootImpl<br>窗口的添加流程<br>View的重绘</p>
<p>OkHttp<br>工作流程<br>优点<br>缓存</p>
<p>Glide<br>工作流程<br>缓存逻辑</p>
<p>WebView</p>
<p>ANR、OOM等排查</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Summer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://skyskiper.github.io/2021/%E5%9B%9E%E7%AD%94%E6%80%9D%E8%B7%AF/">https://skyskiper.github.io/2021/%E5%9B%9E%E7%AD%94%E6%80%9D%E8%B7%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://skyskiper.github.io">阿七笔记</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84/"><span>算法小抄</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Summer</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>