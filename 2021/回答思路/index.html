<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="回答思路"><meta name="keywords" content=""><meta name="author" content="Summer"><meta name="copyright" content="Summer"><title>回答思路 | 阿七笔记</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.1.1'
} </script><meta name="generator" content="Hexo 5.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">热修复与插件化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmap"><span class="toc-number">2.</span> <span class="toc-text">Bitmap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="toc-number">2.0.1.</span> <span class="toc-text">Bitmap 占用内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%A1%86%E6%9E%B6"><span class="toc-number">3.</span> <span class="toc-text">图片框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Glide"><span class="toc-number">3.0.1.</span> <span class="toc-text">Glide</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco"><span class="toc-number">3.0.2.</span> <span class="toc-text">Fresco</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco-%E4%B8%8E-Glide-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">3.0.3.</span> <span class="toc-text">Fresco 与 Glide 的对比：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-ImageLoader-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.0.4.</span> <span class="toc-text">实现一个 ImageLoader 的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.0.5.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webview%E7%9B%B8%E5%85%B3"><span class="toc-number">4.</span> <span class="toc-text">webview相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">4.1.</span> <span class="toc-text">安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">4.2.</span> <span class="toc-text">性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMS%E7%9B%B8%E5%85%B3"><span class="toc-number">5.</span> <span class="toc-text">AMS相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WMS%E7%9B%B8%E5%85%B3"><span class="toc-number">6.</span> <span class="toc-text">WMS相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View%E7%9B%B8%E5%85%B3"><span class="toc-number">7.</span> <span class="toc-text">View相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder%E7%9B%B8%E5%85%B3"><span class="toc-number">8.</span> <span class="toc-text">binder相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">8.0.0.1.</span> <span class="toc-text">常见问题：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handler%E7%9B%B8%E5%85%B3"><span class="toc-number">9.</span> <span class="toc-text">handler相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UI%E7%9A%84%E5%88%B7%E6%96%B0%E6%B6%88%E6%81%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%85%B6%E4%BB%96%E6%B6%88%E6%81%AF%E9%98%BB%E5%A1%9E"><span class="toc-number">9.0.0.1.</span> <span class="toc-text">UI的刷新消息为什么不会被其他消息阻塞:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E4%BF%9D%E6%B4%BB"><span class="toc-number">10.</span> <span class="toc-text">Service保活</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%B4%BB%E6%96%B9%E6%A1%88"><span class="toc-number">10.1.</span> <span class="toc-text">保活方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9B%B8%E5%85%B3"><span class="toc-number">11.</span> <span class="toc-text">锁相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">12.</span> <span class="toc-text">网络协议相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ListView-amp-RecyclerView"><span class="toc-number">13.</span> <span class="toc-text">ListView &amp; RecyclerView</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Summer</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">84</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">阿七笔记</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/menu">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">回答思路</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-22</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="热修复与插件化"><a href="#热修复与插件化" class="headerlink" title="热修复与插件化"></a>热修复与插件化</h2><p>热修复流程：</p>
<p>资源和代码的热修复；资源热修复：新建AssetManager，使用addAssetPath指向新路径，然后替换AssetManager 类型的 mAssets 字段的引用全部替换为新创建的 AssetManager。代码热修复分为dex和so，dex修复分三种 1类加载方案（QQ 空间的超级补丁和微信Tinker）2底层替换方案，ArtMethod变动（AndFix、Dexposed、阿里百川、Sophix）3 Instant Run 借助ASM变更字节码（Robust 和 Aceso）。so库的话重新加载即可。</p>
<p>插件化：</p>
<p>主流的插件化方案有滴滴任玉刚的 VirtualApk、360 的 DroidPlugin、 RePlugin、Wequick 的 Small 框架，Alibaba 的 Atlas。</p>
<p>四大组件的插件：Activity 插件化：1.反射：对性能有影响，主流的插件化框架没有采用此方式。2.接口：dynamic-load-apk 采用。3.Hook：主流。Hook 实现方式有两种：Hook IActivityManager（ActivityManager中的IActivityManagerSingleton修改，ActivityThread 的 H 初恢复） 和 Hook Instrumentation（Instrumentation的execStartActivity修改，performLaunchActivity出恢复）。流程：1、占坑、通过校验：2.还原插件 Activity 3、插件 Activity 的生命周期：<br>Service：通过代理Service的方式去分发，VirtualAPK使用了两个代理Service，即LocalService和RemoteService。<br>BroadcastReceiver：将静态广播转为动态广播。<br>ContentProvider：通过一个代理Provider进行操作的分发。</p>
<p>资源插件化：<br>资源的插件化和热修复的资源修复都借助了 AssetManager。<br>资源的插件化方案主要有两种：<br>1.合并资源方案，将插件的资源全部添加到宿主的 Resources 中，这种 方案插件可以访问宿主的资源。<br>2.构建插件资源方案，每个插件都构造出独立的 Resources，这种方案 插件不可以访问宿主资源。</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>1、要选择合适的图片规格（bitmap 类型）：</p>
<p>ALPHA_8每个像素占用 1byte 内存 ,ARGB_4444 每个像素占用 2byte 内存 ,ARGB_8888 每个像素占用 4byte 内存（默认）,RGB_565 每个像素占用 2byte 内存</p>
<p>2、降低采样率。BitmapFactory.Options 参数 inSampleSize 的使用，先把 options.inJustDecodeBounds 设为 true，只是去读取图片的大小，在拿到图片的 大小之后和要显示的大小做比较通过 calculateInSampleSize()函数计算 inSampleSize 的具体值，得到值之后。options.inJustDecodeBounds 设为 false 读图片资源。</p>
<p>3、复用内存。即，通过软引用(内存不够的时候才会回收掉)，复用内存块，不 需要再重新给这个 bitmap 申请一块新的内存，避免了一次内存的分配和回收， 从而改善了运行效率。</p>
<p>4、使用 recycle()方法及时回收内存。</p>
<p>5、压缩图片。</p>
<p>在 Android 中，Bitmap 的存储分为两部分，一部分是 Bitmap 的数据，一部分是 Bitmap 的引用。 在 Android2.3 时代，Bitmap 的引用是放在堆中的，而 Bitmap 的数据部分是放在栈中的，需要用户调用 recycle 方法手动进行内存回收，而在 Android2.3 之后，整个 Bitmap，包括数据和引用，都放在了堆中，这样，整个 Bitmap 的回收就全部交给 GC 了，这个 recycle 方法就再也不需要使用了。</p>
<p>bitmap recycler 引发的问题：当图像的旋转角度小余两个像素点之间的夹角时， 图像即使旋转也无法显示，因此，系统完全可以认为图像没有发生变化。这时系 统就直接引用同一个对象来进行操作，避免内存浪费。</p>
<p>BitmapFactory 四类方法：<br>decodeFile( 文件系统 )<br>decodeResourece( 资源 )<br>decodeStream( 输入流 )<br>decodeByteArray( 字节数 )</p>
<h4 id="Bitmap-占用内存"><a href="#Bitmap-占用内存" class="headerlink" title="Bitmap 占用内存"></a>Bitmap 占用内存</h4><p>Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存</p>
<p>注：这里 inDensity 表示目标图片的 dpi（放在哪个资源文件夹下）， inTargetDensity 表示目标屏幕的 dpi，所以你可以发现 inDensity 和 inTargetDensity 会对 Bitmap 的宽高进行拉伸，进而改变 Bitmap 占用内存的大 小。 在 Bitmap 里有两个获取内存占用大小的方法。</p>
<p>getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。 getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存 大小，代替了 getByteCount() 方法。 在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片 时，那么 getByteCount() 表示新解码图片占用内存的大 小， getAllocationByteCount() 表示被复用 Bitmap 真实占用的内存大小（即 mBuffer 的长度）。</p>
<p>为了保证在加载 Bitmap 的时候不产生内存溢出，可以使用 BitmapFactory 进行 图片压缩，主要有以下几个参数：<br>BitmapFactory.Options.inPreferredConfig：将 ARGB_8888 改为 RGB_565，改变 编码方式，节约内存。<br>BitmapFactory.Options.inSampleSize：缩放比例，可以 参考 Luban 那个库，根据图片宽高计算出合适的缩放比例。<br>BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。<br>inJustDecodeBounds 获取图片的宽高信息，交给 inSampleSize 参数选 择缩放比</p>
<p>高效加载 Bitmap 的流程:<br>1、将 BitmapFactory.Options 的 inJustDecodeBounds 参数设为 true 并加载图片<br>2、从 BitmapFactory.Options 中取出图片原始的宽高信息， 对应于 outWidth 和 outHeight 参数 3、根据采样率规则并结合目标 view 的大小计算出采样率 inSampleSize<br>4、将 BitmapFactory.Options 的 inJustDecodeBounds 设置为 false 重 新加载图片</p>
<p>针对清明上河图这种大图可以使用 BitmapRegionDecoder 动态加载图片的显示区域。</p>
<p><strong>Bitmap.recycle()会立即回收么？什么时候会回收？如果没有地方使用这个 Bitmap，为什么垃圾回收不会直接回收？</strong></p>
<p>通过源码可以了解到，加载 Bitmap 到内存里以后，是包含两部 分内存区域的。简单的说，一部分是 Java 部分的，一部分是 C 部分的。这个 Bitmap 对象是由 Java 部分分配的，不用的时候 系统就会自动回收了。但是那个对应的 C 可用的内存区域，虚拟机是不能直接回收 的，这个只能调用底层的功能释放。所以需要调用 recycle()方 法来释放 C 部分的内存。bitmap.recycle()方法用于回收该 Bitmap 所占用的内存，接着 将 bitmap 置空，最后使用 System.gc()调用一下系统的垃圾回 收器进行回收，调用 System.gc()并不能保证立即开始进行回收 过程，而只是为了加快回收的到来。</p>
<h2 id="图片框架"><a href="#图片框架" class="headerlink" title="图片框架"></a>图片框架</h2><h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h4><p>为什么要在项目中使用这个库？<br>1.多样化媒体加载：不仅可以进行图片缓存，还支持 Gif、WebP、缩略图，甚 至是 Video。<br>2.通过设置绑定生命周期：可以使加载图片的生命周期动态管理起来。<br>3.高效的缓存策略：支持内存、Disk 缓存，并且 Picasso 只会缓存原始尺寸的 图片，内 Glide 缓存的是多种规格，也就是 Glide 会根据你 ImageView 的大小来 缓存相应大小的图片尺寸。<br>4.内存开销小：默认的 Bitmap 格式是 RGB_565 格式，而 Picasso 默认的是 ARGB_8888 格式，内存开销小一半。</p>
<p>这个库都有哪些用法？对应什么样的使用场景？<br>1.图片加载Glide.with(this).load(imageUrl).override(800,800).placeholder().error().animate().into()。<br>2.多样式媒体加载：asBitamp、asGif。<br>3.生命周期集成。<br>4.可以配置磁盘缓存策略 ALL、NONE、SOURCE、RESULT。</p>
<p>Glide&amp;with:<br>1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等） 以及 glide 对象。<br>2、将 glide 请求和 application/SupportFragment/Fragment 的生命周期绑定在一块。</p>
<p>Glide&amp;load：<br>设置请求 url，并记录 url 已设置的状态。</p>
<p>Glide&amp;into：<br>1、首先根据转码类 transcodeClass 类型返回不同的 ImageViewTarget：BitmapImageViewTarget、DrawableImageViewTarget。<br>2、递归建立缩略图请求，没有缩略图请求，则直接进行正常请求。<br>3、如果没指定宽高，会根据 ImageView 的宽高计算出图片宽高，最终执行到 onSizeReay()方法中的 engine.load()方法。<br>4、engine 是一个负责加载和管理缓存资源的类</p>
<p>常规三级缓存的流程：强引用-&gt;软引用-&gt;硬盘缓存<br>当我们的APP中想要加载某张图片时，先去LruCache中寻找图片，如果LruCache 中有，则直接取出来使用，如果 LruCache 中没有，则去 SoftReference 中寻找 （软引用适合当 cache，当内存吃紧的时候才会被回收。而 weakReference 在每 次 system.gc（）就会被回收）（当 LruCache 存储紧张时，会把最近最少使用 的数据放到 SoftReference 中），如果 SoftReference 中有，则从 SoftReference 中取出图片使用，同时将图片重新放回到 LruCache 中，如果 SoftReference 中 也没有图片，则去硬盘缓存中中寻找，如果有则取出来使用，同时将图片添加到 LruCache 中，如果没有，则连接网络从网上下载图片。图片下载完成后，将图 片保存到硬盘缓存中，然后放到 LruCache 中。</p>
<p>Glide 缓存机制大致分为三层：内存缓存、弱引用缓存、磁盘缓存。<br>取的顺序是：内存、弱引用、磁盘。<br>存的顺序是：弱引用、内存、磁盘。</p>
<p>三层存储的机制在 Engine 中实现的。先说下 Engine 是什么？Engine 这一层负 责加载时做管理内存缓存的逻辑。持有 MemoryCache、Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;。通过 load（）来加载图片，加载前后 会做内存存储的逻辑。如果内存缓存中没有，那么才会使用 EngineJob 这一层来 进行异步获取硬盘资源或网络资源。EngineJob类似一个异步线程或observable。 Engine 是一个全局唯一的，通过 Glide.getEngine()来获取。</p>
<p>需要一个图片资源，首先先取ActiveResources，activeResources是盛放正在使用的资源，以弱引用的形式存在。同时资源内部有被引用的记录。如果资源没有引用记录了，那么再放回 Lrucache 中，同时从 activeResources 中清除（activeResources开启了一个后台线程专门检测ReferenceQueue）。如果没有，则继续从LruResourceCache中取，取到以后从LruResourceCache删除同时加入ActiveResources中。如果 Lrucache 和 activeResources 中没有，那么进行资源异步请求（网络 /diskLrucache），请求成功后，资源放到 diskLrucache 和 activeResources 中。</p>
<p>缓存：<br>ActiveResources 活跃的内存缓存，使用的是弱引用的方式，用作优化列表反复滑动中Lru频繁清除，然后在重新加载的情况<br>LruResourceCache 内存缓存,不包含正在使用的资源。使用cache.remove(key)从LruResourceCache获取缓存<br>ResourceCacheGenerator:缓存的被加工过的原数据缓存（磁盘)<br>DataCacheGenerator:原文件<br>SourceGenerator:从网络加载数据</p>
<p>Glide源码机制的核心思想：</p>
<p>使用一个弱引用 map activeResources 来盛放项目中正在使用的资源。Lrucache 中不含有正在使用的资源。资源内部有个计数器来显示自己是不是还有被引用的 情况，把正在使用的资源和没有被使用的资源分开有什么好处呢？？因为当 Lrucache 需要移除一个缓存时，会调用 resource.recycle()方法。注意到该方法上 面注释写着只有没有任何 consumer 引用该资源的时候才可以调用这个方法。那 么为什么调用 resource.recycle()方法需要保证该资源没有任何 consumer 引用 呢？glide 中 resource 定义的 recycle（）要做的事情是把这个不用的资源（假设 是 bitmap 或 drawable）放到 bitmapPool 中。bitmapPool 是一个 bitmap 回收 再利用的库，在做 transform 的时候会从这个 bitmapPool 中拿一个 bitmap 进行 再利用。这样就避免了重新创建 bitmap，减少了内存的开支。而既然 bitmapPool 中的 bitmap 会被重复利用，那么肯定要保证回收该资源的时候（即调用资源的 recycle（）时），要保证该资源真的没有外界引用了。这也是为什么 glide 花费 那么多逻辑来保证 Lrucache 中的资源没有外界引用的原因。</p>
<p>相关问题：<br>Glide 如何确定图片加载完毕？<br>Glide 使用什么缓存？<br>Glide 内存缓存如何控制大小？</p>
<h4 id="Fresco"><a href="#Fresco" class="headerlink" title="Fresco"></a>Fresco</h4><p>DraweeView：继承于 ImageView，只是简单的读取 xml 文件的一些属性值和做 一些初始化的工作，图层管理交由 Hierarchy 负责，图层数据获取交由负责。<br>DraweeHierarchy：由多层 Drawable 组成，每层 Drawable 提供某种功能（例如： 缩放、圆角）。 DraweeController：控制数据的获取与图片加载，向 pipeline 发出请求，并接收相应事件，并根据不同事件控制 Hierarchy，从 DraweeView 接收用户的事件，然后执行取消网络请求、回收资源等操作。<br>DraweeHolder： 统筹管理 Hierarchy 与 DraweeHolder。<br>ImagePipeline：Fresco 的核心模块，用 来以各种方式（内存、磁盘、网络等）获取图像。 Producer/Consumer：Producer 也有很多种，它用来完成网络数据获取，缓存数据获取、图片解码等多种工作， 它产生的结果由 Consumer 进行消费。<br>IO/Data：这一层便是数据层了，负责实 现内存缓存、磁盘缓存、网络缓存和其他 IO 相关的功能。</p>
<p>具体实现：<br>GenericDraweeHierarchy：负责 SimpleDraweeView 上的图层管理，由多层 Drawable 组成，每层 Drawable 提供某种功能（例如：缩放、圆角）。</p>
<ol>
<li>背景图（backgroundImage）</li>
<li>占位图（placeholderImage=）</li>
<li>加载的图片（actualImage）</li>
<li>进度条（progressBarImage）</li>
<li>重试加载的图片（retryImage）</li>
<li>失败图片（failureImage）</li>
<li>叠加图（overlayImage）</li>
</ol>
<p>内存缓存：</p>
<p>已解码的内存缓存（BitmapMemoryCache）与未解码的内存缓存（EncodedMemoryCache）区别就是已解码内存缓存的数据是CloseableReference<CloseableBitmap>。而未解码内存缓存的数据是CloseableReference<PooledByteBuffer>。即他们的实现方式一样，区别仅仅在于<strong>资源的测量与释放方式不同</strong>。它们使用ValueDescriptor来描述不同资源的数据大小，使用不同的ResourceReleaser来释放资源。</p>
<p>BitmapMemoryCache（已解码的内存缓存）：BitmapMemoryCacheFactory提供工厂方法获取存储缓存的数据结构。<br>EncodedMemoryCache（未解码的内存缓存）：EncodedCountingMemoryCacheFactory提供工厂方法获取存储缓存的数据结构。</p>
<p>CountingLruMap：Fresco中定义的LRU缓存载体，里面使用了LinkedHashMap作为数据存储载体，但是并没有启用LinkedHashMap的accessOrder功能。同时里面封装了map中的总大小mSizeInBytes，还有各个缓存的大小（ValueDescriptor.getSizeInBytes）。</p>
<p>CountingMemoryCache:具体缓存缓存实现<br>Fresco中实现具体内存缓存的类是CountingMemoryCache，它内部维持着几个重要参数：<br>ExclusiveEntries存储着未被使用的对象的CountingLruMap；<br>CachedEntries存储着所有对象的CountingLruMap；<br>MemoryCacheParams存储着最大缓存对象数量、缓存池大小等参数;<br>PARAMS_INTERCHECK_INTERVAL_MS检查缓存参数变化的事件间隔：5分钟；</p>
<p>它使用一个内部类Entry来封装缓存对象，除了记录缓存键、缓存对象之外，它还记录着该对象的引用数量（clientCount）及是否被缓存追踪（isOrphan）。注意：每个缓存对象只有满足clientCount为0并且isOrphan为true时才可以被释放，可从referenceToClose函数中看出此逻辑。</p>
<p>Fresco使用InstrumentedMemoryCache包装了CountingMemoryCache，主要增加的功能就是提供了MemoryCacheTracker，会在缓存命中或未命中时提供回调函数，供使用者实现自定义功能。</p>
<p>Fresco的缓存调用处：</p>
<p>1.BitmapMemoryCacheProducer：已解码的内存缓存的调用处<br>2.EncodedMemoryCacheProducer：未解码的内存缓存的调用处<br>3.DiskCacheReadProducer：磁盘中未解码的内存缓存的调用处<br>4.NetworkFetchProducer:从网络获取图片的调用处</p>
<p>这里提一点Bitmap缓存：在5.0以下系统，Bitmap缓存位于ashmem，这样Bitmap对象的创建和释放将不会引发GC，更少的GC会使你的APP运行得更加流畅。5.0及其以上系统，相比之下，内存管理有了很大改进，所以Bitmap缓存直接位于Java的heap上。</p>
<h4 id="Fresco-与-Glide-的对比："><a href="#Fresco-与-Glide-的对比：" class="headerlink" title="Fresco 与 Glide 的对比："></a>Fresco 与 Glide 的对比：</h4><p>Glide：相对轻量级，用法简单优雅，支持 Gif 动态图，适合用在那些对图片依赖 不大的 App 中。 Fresco：采用匿名共享内存来保存图片，也就是 Native 堆，有 效的的避免了 OOM，功能强大，但是库体积过大，适合用在对图片依赖比较大 的 App 中。</p>
<h4 id="实现一个-ImageLoader-的流程"><a href="#实现一个-ImageLoader-的流程" class="headerlink" title="实现一个 ImageLoader 的流程"></a>实现一个 ImageLoader 的流程</h4><p>同步异步加载、图片压缩、内存硬盘缓存、网络拉取</p>
<p>1.同步加载只创建一个线程然后按照顺序进行图片加载<br>2.异步加载使用线程池，让存在的加载任务都处于不同线程<br>3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载</p>
<p>具体为：</p>
<p>1、ImageLoader 作为一个单例，提供了加载图片到指定控件的方法：直 接从内存缓存中获取对象，如果没有则用一个 ThreadPoolExecutor 去执 行 Runnable 任务来加载图片。ThreadPoolExecutor 的创建需要指定核心 线程数 CPU 数+1，最大线程数 CPU 数*2+1，线程闲置超市时长 10s,这几 个关键数据，还可以加入 ThreadFactory 参数来创建定制化的线程。<br>2、ImageLoader 的具体实现 loadBitmap：先从内存缓存 LruCache 中加 载，如果为空再从磁盘缓存中加载，加载成功后记得存入内存缓存，如果 为空则从网络中直接下载输出流到磁盘缓存，然后再从磁盘中加载，如果 为 空 并 且 磁 盘 缓 存 没 有 被 创 建 的 话 ， 直 接 通 过 BitmapFactory 的 decodeStream 获取网络请求的输入流获取 Bitmap 对象。<br>3、v4 包的 LruCache 可以兼容到 2.2 版本，LruCache 采用 LinkedHashMap 存储缓存对象。创建对象只需要提供缓存容量并重写 sizeOf 方法：作用 是计算缓存对象的大小。有时需要重写 entryRemoved 方法，用于回收一 些资源。<br>4、DiskLruCache 通过 open 方法创建，设置缓存路径，缓存容量。缓存 添加通过 Editor 对象创建输出流，下载资源到输出流完成后，commit， 如果失败则 abort 撤回。然后刷新磁盘缓存。缓存查找通过 Snapshot 对象获取输入流，获取 FileDescriptor，通过 FileDescriptor 解析出 Bitmap 对象。 5、列表中需要加载图片的时候，当列表在滑动中不进行图片加载，当滑 动停止后再去加载图片。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="webview相关"><a href="#webview相关" class="headerlink" title="webview相关"></a>webview相关</h2><p>客户端api通过native://method?para=x的方式出发，主要提供一些小程序和客户端的交互，对小程序屏蔽客户端差异。实现方式：java调用h5：webView.loadUrl(js); h5调用客户端：shouldOverrideUrlLoading拦截请求url。使用注解的方式维护方法名和method的映射关系，同时还可以指定方法是否可以立即返回。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>webview原生的安全漏洞：<br>1.addJavascriptInterface方法导致远程代码执行漏洞，前端可以获取到addJavascriptInterface的java对象的Class对象，Class.forName可以加载java.lang.Runtime 类,通过Runtime可以执行本地命令。该漏洞4.2版本后被修复，使用@JavascriptInterface进行注解从而避免漏洞攻击。<br>2.WebView默认开启密码保存功能，关键是密码会被明文存入 /data/data/com.package.name/databases/webview.db ,解决方案是关闭密码保存提醒<br>3.setAllowFileAccess允许小程序可以访问访问本地文件，容易导致本地隐私文件泄漏，setAllowUniversalAccessFromFileURLs设置是否允许通过 file url 加载的 Javascript 可以访问其他的源(包括http、https等源),setAllowFileAccessFromFileURLs设置是否允许通过 file url 加载的 Js代码读取其他的本地文件，小程序要求setAllowFileAccess(true)和setJavaScriptEnabled(true)让浏览器加载html和js代码，使用setAllowUniversalAccessFromFileURLs(false)和setAllowFileAccessFromFileURLs(false)禁止本地j访问文件。</p>
<p>客户端层面安全：<br>1.客户端api区分安全等级，有些方法需要授权才可以访问<br>2.客户端api白名单，有些api需要后台配置了才能访问<br>3.由于跨域问题，小程序的网络请求必须由客户端转发</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>1.客户端调用h5使用evaluateJavascript，比loadurl速度快<br>2.缓存最近打开的5个小程序，保留每个小程序打开的完整Fragment栈，在栈中的小程序可以做到秒开</p>
<p>###客户端与小程序的相互调用</p>
<p>1.客户端调用小程序：loadUrl与evaluateJavascript<br>2.小程序调用客户端：addJavascriptInterface、shouldOverrideUrlLoading和onJsPrompt三种方式</p>
<h2 id="AMS相关"><a href="#AMS相关" class="headerlink" title="AMS相关"></a>AMS相关</h2><p>Activity的attach中生成PhoneWindow对象;PhoneWindow的setContentView中初始化DecorView（ViewGroup），同时使用LayoutInflater解析布局文件。在view中有一个getViewRootImpl，获取ViewRootImpl。在WindowmanagerGlobal中addView时创建ViewRootImpl,同时新建View.AttachInfo，viewrootImpl在performTraversals时将View.AttachInfo传给view。</p>
<p>ViewRootImp 在 onCreate() 时还没创建；在 onResume()时，即ActivityThread 的 handleResumeActivity() 执 行后才创建，调用 requestLayout()，走到 checkThread() 时就报错了。</p>
<p>Activity中持有WindowManager，addview是通过WindowManager调用到WindowManagerGlobal中的。</p>
<h2 id="WMS相关"><a href="#WMS相关" class="headerlink" title="WMS相关"></a>WMS相关</h2><p>Activity有一个phonewindow和WindowManager，phonewindow有一个decorView。activitythread在handleResumeActivity时从activity中取出WindowManager，调用addView（decorview），此时创建viewrootImpl，同时调用viewrootImpl.setView(decorview)，调用mWindowSession.addToDisplay将window添加到屏幕。</p>
<p>WindowManagerImpl代理给WindowManagerGlobal。WindowManagerGlobal中有IWindowSession和IWindowManager两个binder客户端，static修饰。WindowManagerGlobal中有三个List，分别为View、ViewRootImpl、WindowManager.LayoutParams，管理窗口级view的增删更新等，虽然最终的操作都是转发到ViewrootImpl中，在这里通过mWindowSession做ipc,然后结果通知回来更新WindowManagerGlobal中管理的参数。</p>
<p>Window定义了三种窗口类型：系统Window、应用程序Window、子Window。每一种窗口类型定义了一种对应的type。<br>应用类型的窗口的type范围是１<del>99，子窗口的type范围是1000</del>1999，系统的窗口的type范围是2000以上。</p>
<p>WindowState是WMS中事实的窗口，而不是Window，WindowState是在WMS的addWindow方法中创建，包含了一个窗口的所有的属性，其中一个属性为mLayer，表示窗口在Ｚ轴的位置，mLayer值越小，窗口越靠后，mLayer值越大，窗口越靠前，最前面的一个窗口就作为焦点窗口，可以接收触摸事件。因为窗口的切换，切换后的Ｚ序(窗口的显示次序称为 Z 序)就可能不同，所以mLayer的值不是固定不变的。mLayer是通过WindowState的另一个成员变量mBaseLayer的值计算得到，mBaseLayer的值是固定不变的，只和窗口类型有关。mBaseLayer(称为主序)是WindowState的构造方法中赋值。mBaseLayer =窗口类型×10000+1000。</p>
<h2 id="View相关"><a href="#View相关" class="headerlink" title="View相关"></a>View相关</h2><p>view中requestLayout层层调用parent.requestLayout,其实最终是调用viewrootImpl.requestLayout的。requestLayout中检测了线程，只要创建viewrootImpl的线程和执行requestLayout线程是相同即可。</p>
<p>viewrootImpl.setView(decorview)时将调用view.assignParent(this);将viewrootImpl设置为view的parent。</p>
<p>viewrootImpl中requestLayout调用scheduleTraversals，mHandler.getLooper().postSyncBarrier()插入屏障消息, mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);为mTraversalRunnable注册16ms回调。mTraversalRunnable中执行performTraversals，大致为三个步骤performMeasure，performLayout，performDraw。</p>
<p>viewrootImpl的scheduleTraversals向Choreographer注册了CALLBACK_INPUT和CALLBACK_TRAVERSAL两种类型callback</p>
<p>Choreographer在doframe时执行doCallbacks时，执行的CALLBACK_INPUT回调时，会回调到viewrootImpl的doConsumeBatchedInput。然后执行viewrootImpl中的WindowInputEventReceiver.onInputEvent()。转发给viewrootImpl中的InputStage（有5个实现，应该使用不同策略处理InputEvent（包含KeyEvent和MotionEvent）），InputStage调用view.dispatchPointerEvent,然后dispatchTouchEvent方法。DecorView的dispatchTouchEvent会将事件转发到mWindow.getCallback()中（其实就是activity中）。activity中getWindow().superDispatchTouchEvent(ev)将时间转发给mDecor.superDispatchTouchEvent(event);继续view层的事件转发。如果都没有处理，最后回调activity.onTouchEvent方法。</p>
<p>view层事件转发流程：dispatchTouchEvent—&gt;onInterceptTouchEvent–&gt;onTouchEvent</p>
<h2 id="binder相关"><a href="#binder相关" class="headerlink" title="binder相关"></a>binder相关</h2><p>驱动层：<br>设备初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。分别对应应用程序的open、mmap、ioctl的调用。</p>
<p>write_buffer和read_buffer都是包含Binder协议命令和binder_transaction_data结构体。</p>
<ul>
<li>copy_from_user()将用户空间IPC数据拷贝到内核态binder_write_read结构体；</li>
<li>copy_to_user()将用内核态binder_write_read结构体数据拷贝到用户空间；</li>
</ul>
<p>应用程序层：</p>
<p>在native层由BBinder和BpBinder，在java层由Binder和BinderProxy。</p>
<h5 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h5><ol>
<li>binder的线程池最大数量默认为16，system_service进程就有16个线程程。</li>
<li>Binder内存大小限制为1M-8K。普通app在初始化时调用mmap申请了1M-8K，虽然在内核中是限制了4M，但是依然还是1M-8K。ServiceManager进程binder仅仅申请了128K的内存，因为他不需要传输大量数据。</li>
<li>大量数据使用binder的传递的方式：</li>
</ol>
<ul>
<li>非跨进程，使用静态变量来避免大量数据的拷贝，或者使用Eventbus等框架进行引用传递。</li>
<li>分批次传输，例如分页</li>
<li>对效率要求不高，可以使用socket或者文件方式。</li>
<li>使用ashmem匿名共享内存。使用例子Bundle.putBinder、ContentProvider、MemoryFile。推荐使用这个方式。</li>
</ul>
<p>tip：Intent如果允许传输文件符，则可以避免大量数据拷贝。但是startActivity时会调用 setAllowFds(false)禁止掉文件符传输。</p>
<p>binder是为了ipc(进程间通信)设计的，并不是为了数据传输设计的。</p>
<h2 id="handler相关"><a href="#handler相关" class="headerlink" title="handler相关"></a>handler相关</h2><ol>
<li>消息是通过 MessageQueen 中的 enqueueMessage()方法加入消息队列中的，并 且它在放入中就进行好排序，链表头的延迟时间小，尾部延迟时间最大</li>
<li>Looper.loop()通过 MessageQueue 中的 next()去取消息</li>
<li>next()中如果当前链表头部消息是延迟消息，则根据延迟时间进行消息队列会 阻塞，不返回给 Looper message，直到时间到了，返回给 message</li>
<li>如果在阻塞中有新的消息插入到链表头部则唤醒线程</li>
<li>Looper 将新消息交给回调给 handler 中的 handleMessage 后，继续调用MessageQueen 的 next()方法，如果刚刚的延迟消息还是时间未到，则计算时间 继续阻塞</li>
</ol>
<h5 id="UI的刷新消息为什么不会被其他消息阻塞"><a href="#UI的刷新消息为什么不会被其他消息阻塞" class="headerlink" title="UI的刷新消息为什么不会被其他消息阻塞:"></a>UI的刷新消息为什么不会被其他消息阻塞:</h5><p>在ViewRootImpl中scheduleTraversals里面先调用postSyncBarrier发送同步消息(message中没有target)，然后向Choreographer注册同步回调监听接口，收到同步回调后向handler发送异步消息。在messagequeue中next取消息时，一旦发现没有target的消息，则优先执行异步消息。</p>
<p>设置了屏障消息，此时只会处理异步消息，处理完异步消息后就会堵塞。如果想要恢复同步消息，需要调用 removeSyncBarrier()移除。</p>
<p>子线程中Toast和Dialog的show发生crash原因：Toast和dialog里面有使用到new Handler()，如果子线程没有Looper.prepare();则会导致crash。</p>
<h2 id="Service保活"><a href="#Service保活" class="headerlink" title="Service保活"></a>Service保活</h2><p>Android 进程不死从 3 个层面入手：</p>
<p>A.提供进程优先级，降低进程被杀死的概率 </p>
<p>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动 1 个像素的 Activity，在用 户解锁时将 Activity 销毁掉。</p>
<p>方法二：启动前台 service。</p>
<p>方法三：提升 service 优先级：</p>
<p>在 AndroidManifest.xml 文件中对于 intent-filter 可以通过 android:priority = “1000”这个属性设置最高优先级，1000 是最高值，如果数字越小则优先级越低， 同时适用于广播。 </p>
<p>B. 在进程被杀死后，进行拉活 </p>
<p>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等 </p>
<p>方法二：双进程相互唤起。</p>
<p> 方法三：依靠系统唤起。 </p>
<p>方法四：onDestroy 方法里重启 service：service + broadcast 方式，就是当 service 走 ondestory 的时候，发送一个自定义的广播，当收到广播的时候，重新启动 service；</p>
<p>C. 依靠第三方</p>
<p>根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推 送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。</p>
<h3 id="保活方案"><a href="#保活方案" class="headerlink" title="保活方案"></a>保活方案</h3><p>1、AIDL 方式单进程、双进程方式保活 Service。（基于 onStartCommand() return START_STICKY）<br>START_STICKY 在运行 onStartCommand 后 service 进程被 kill 后，那将保留在 开始状态，但是不保留那些传入的 intent。不久后 service 就会再次尝试重新创 建，因为保留在开始状态，在创建 service 后将保证调用 onstartCommand。如 果没有传递任何开始命令给 service，那将获取到 null 的 intent。<br>除了华为此方案无效以及未更改底层的厂商不起作用外（START_STICKY 字段就 可以保持 Service 不被杀）。此方案可以与其他方案混合使用</p>
<p>2、降低 oom_adj 的值（提升 service 进程优先级）：<br>Android 中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进 行进程的回收。Android 将进程分为 5 个等级,它们按优先级顺序由高到低依次是:<br>1.前台进程 (Foreground process)<br>2.可见进程 (Visible process)<br>3.服务进程 (Service process)<br>4.后台进程 (Background process)<br>5.空进程 (Empty process)</p>
<p>当 service 运行在低内存的环境时，将会 kill 掉一些存在的进程。因此进程的优 先级将会很重要，可以使用 startForeground 将 service 放到前台状态。这样在 低内存时被 kill 的几率会低一些。</p>
<p>常驻通知栏（可通过启动另外一个服务关闭 Notification，不对 oom_adj 值有影响）。<br>使用”1 像素“的 Activity 覆盖在 getWindow()的 view 上。此方案无效果<br>循环播放无声音频（黑科技，7.0 下杀不掉）。<br>成功对华为手机保活。小米 8 下也成功突破 20 分钟<br>3、监听锁屏广播：使 Activity 始终保持前台。<br>4、使用自定义锁屏界面：覆盖了系统锁屏界面。<br>5、通过 android:process 属性来为 Service 创建一个进程。<br>6、跳转到系统白名单界面让用户自己添加 app 进入白名单</p>
<p>复活方案:<br>1、onDestroy 方法里重启 service<br>service + broadcast 方式，就是当 service 走 onDestory 的时候，发送一个自定 义的广播，当收到广播的时候，重新启动 service。</p>
<p>2、JobScheduler：原理类似定时器，5.0,5.1,6.0 作用很大，7.0 时候有一定影响 （可以在电源管理中给 APP 授权）。只对 5.0，5.1、6.0 起作用。</p>
<p>3、推送互相唤醒复活：极光、友盟、以及各大厂商的推送。</p>
<p>4、同派系 APP 广播互相唤醒：比如今日头条系、阿里系。</p>
<p>此外还可以监听系统广播判断 Service 状态，通过系统的一些广播，比如：手机 重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的 Service 是 否还存活。<br>结论：高版本情况下可以使用弹出通知栏、双进程、无声音乐提高后台服务的 保活概率。</p>
<h2 id="锁相关"><a href="#锁相关" class="headerlink" title="锁相关"></a>锁相关</h2><h2 id="网络协议相关"><a href="#网络协议相关" class="headerlink" title="网络协议相关"></a>网络协议相关</h2><h2 id="ListView-amp-RecyclerView"><a href="#ListView-amp-RecyclerView" class="headerlink" title="ListView &amp; RecyclerView"></a>ListView &amp; RecyclerView</h2><p>ListView 的基础使用：<br>1.继承重写 BaseAdapter 类<br>2.自定义 ViewHolder 和 convertView 一起完成复用优化工作</p>
<p>RecyclerView 基础使用关键点同样有两点：<br>1.继承重写 RecyclerView.Adapter 和 RecyclerView.ViewHolder<br>2.设置布局管理器，控制布局效果</p>
<p>缓存：<br>RecyclerView比ListView多两级缓存，支持多个离ItemView缓存，支持开发者自定义缓存处理逻辑，支持所有RecyclerView共用同一个RecyclerViewPool(缓存池)。<br>具体来说：<br>ListView(两级缓存)：<br>RecyclerView(四级缓存)：</p>
<p>列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。</p>
<p>问题：<br>1.RecyclerView 与 ListView 缓存机制的不同？<br>2.想改变 listview 的高度，怎么做？<br>3.listview 跟 recyclerview 上拉加载的时候分别应该如何处理？<br>4.如何自己实现 RecyclerView 的侧滑删除？<br>5.RecyclerView 的 ItemTouchHelper 的实现原理</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Summer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://skyskiper.github.io/2021/%E5%9B%9E%E7%AD%94%E6%80%9D%E8%B7%AF/">https://skyskiper.github.io/2021/%E5%9B%9E%E7%AD%94%E6%80%9D%E8%B7%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://skyskiper.github.io">阿七笔记</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84/"><span>算法小抄</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Summer</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>