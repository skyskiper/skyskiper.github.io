<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="回答思路"><meta name="keywords" content=""><meta name="author" content="Summer"><meta name="copyright" content="Summer"><title>回答思路 | 阿七笔记</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.1.1'
} </script><meta name="generator" content="Hexo 5.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">重点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%93%E4%B8%9A%E5%8D%95%E8%AF%8D"><span class="toc-number">2.</span> <span class="toc-text">专业单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8EGC"><span class="toc-number">3.</span> <span class="toc-text">内存模型与GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC"><span class="toc-number">3.2.</span> <span class="toc-text">GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-GC"><span class="toc-number">3.3.</span> <span class="toc-text">Android GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E4%B8%8ECollection"><span class="toc-number">4.</span> <span class="toc-text">锁与Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized"><span class="toc-number">4.1.</span> <span class="toc-text">Synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">4.2.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-number">4.3.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">4.4.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">4.5.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E3%80%81List%E3%80%81SparseArray"><span class="toc-number">4.6.</span> <span class="toc-text">Map、List、SparseArray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-1"><span class="toc-number">5.2.</span> <span class="toc-text">线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">6.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">软引用和弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E7%BD%AE%E4%B8%BA-null%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">强引用置为 null，会不会被回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%EF%BC%8Cfinally%EF%BC%8Cfinalize"><span class="toc-number">6.4.</span> <span class="toc-text">final，finally，finalize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">6.5.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">7.</span> <span class="toc-text">网络协议相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Http1-1-%E5%92%8C-Http1-0-%E5%8F%8A-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.1.</span> <span class="toc-text">Http1.1 和 Http1.0 及 2.0 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Https-%E8%AF%B7%E6%B1%82%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">7.0.2.</span> <span class="toc-text">Https 请求慢的解决办法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">7.0.3.</span> <span class="toc-text">缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmap"><span class="toc-number">8.</span> <span class="toc-text">Bitmap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="toc-number">8.0.1.</span> <span class="toc-text">Bitmap 占用内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%A1%86%E6%9E%B6"><span class="toc-number">9.</span> <span class="toc-text">图片框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Glide"><span class="toc-number">9.0.1.</span> <span class="toc-text">Glide</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco"><span class="toc-number">9.0.2.</span> <span class="toc-text">Fresco</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco-%E4%B8%8E-Glide-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">9.0.3.</span> <span class="toc-text">Fresco 与 Glide 的对比：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-ImageLoader-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">9.0.4.</span> <span class="toc-text">实现一个 ImageLoader 的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">9.0.5.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webview%E7%9B%B8%E5%85%B3"><span class="toc-number">10.</span> <span class="toc-text">webview相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">10.1.</span> <span class="toc-text">安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">10.2.</span> <span class="toc-text">性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMS%E7%9B%B8%E5%85%B3"><span class="toc-number">11.</span> <span class="toc-text">AMS相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WMS%E7%9B%B8%E5%85%B3"><span class="toc-number">12.</span> <span class="toc-text">WMS相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View%E7%9B%B8%E5%85%B3"><span class="toc-number">13.</span> <span class="toc-text">View相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder%E7%9B%B8%E5%85%B3"><span class="toc-number">14.</span> <span class="toc-text">binder相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">14.0.0.1.</span> <span class="toc-text">常见问题：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handler%E7%9B%B8%E5%85%B3"><span class="toc-number">15.</span> <span class="toc-text">handler相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UI%E7%9A%84%E5%88%B7%E6%96%B0%E6%B6%88%E6%81%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%85%B6%E4%BB%96%E6%B6%88%E6%81%AF%E9%98%BB%E5%A1%9E"><span class="toc-number">15.0.0.1.</span> <span class="toc-text">UI的刷新消息为什么不会被其他消息阻塞:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E4%BF%9D%E6%B4%BB"><span class="toc-number">16.</span> <span class="toc-text">Service保活</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%B4%BB%E6%96%B9%E6%A1%88"><span class="toc-number">16.1.</span> <span class="toc-text">保活方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ListView-amp-RecyclerView"><span class="toc-number">17.</span> <span class="toc-text">ListView &amp; RecyclerView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%8C%96"><span class="toc-number">18.</span> <span class="toc-text">热修复与插件化</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Summer</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">84</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">阿七笔记</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/menu">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">回答思路</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-22</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>内存模型与GC</p>
<p>锁与并发</p>
<p>线程与线程池</p>
<p>bitmap</p>
<p>图片框架</p>
<p>http与https区别、tcp的三次握手与四次挥手</p>
<p>View的绘制、事件处理</p>
<p>RecyclerView与ListView</p>
<p>WebView</p>
<p>Binder</p>
<p>Handler</p>
<p>打开app流程与系统启动流程</p>
<p>打包流程</p>
<p>Davilk、ART</p>
<p>IM、Socket与保活</p>
<p>kotlin基础知识</p>
<h2 id="专业单词"><a href="#专业单词" class="headerlink" title="专业单词"></a>专业单词</h2><p>ReentrantLock： [riː’entrənt]<br>ConcurrentHashMap：[kənˈkʌrənt]<br>segment：[ˈseɡmənt]<br>Zygote<br>Region<br>Dalvik</p>
<h2 id="内存模型与GC"><a href="#内存模型与GC" class="headerlink" title="内存模型与GC"></a>内存模型与GC</h2><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>JVM 主要包括四个部分：<br>1.类加载器（ClassLoader）:在 JVM 启动时或者在类运行将需要的 class 加载到 JVM 中。<br>2.执行引擎：负责执行 class 文件中包含的字节码指令；<br>3.内存区（也叫运行时数据区）：是在 JVM 运行的时候操作所分配的内存区。 运行时内存区主要可以划分为 5 个区域，</p>
<ul>
<li>方法区(MethodArea)：用于存储类结构信息的地方，包括常量池、静态常量、 构造函数等。虽然 JVM 规范把方法区描述为堆的一个辑部分， 但它却有个别名 non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。</li>
<li>java 堆(Heap)：存储 java 实例或者对象的地方。这块是 GC 的主要区域。从存储 的内容我们可以很容易知道，方法和堆是被所有 java 线程共享的。</li>
<li>java 栈(Stack)：java 栈总是和线程关联在一起，每当创一个线程时，JVM 就会为 这个线程创建一个对应的 java 栈在这个 java 栈中,其中又会包含多个栈帧，每运 行一个方法就建一个栈帧，用于存储局部变量表、操作栈、方法返回等。每一个 方法从调用直至执行完成的过程，就对应一栈帧在 java 栈中入栈到出栈的过程。 所以 java 栈是现成有的。</li>
<li>程序计数器(PCRegister)：用于保存当前线程执行的内存地址。由于 JVM 程序是 多线程执行的（线程轮流切换），所以为了保证程切换回来后，还能恢复到原先 状态，就需要一个独立计数器，记录之前中断的地方，可见程序计数器也是线程 私有的。</li>
<li>本地方法栈(Native MethodStack)：和 java 栈的作用差不多，只不过是为 JVM 使 用到 native 方法服务的。</li>
</ul>
<p>4.本地方法接口：主要是调用 C 或 C++实现的本地方法及回调结果。</p>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>可达性分析：<br>可达性分析算法通过一系列称为 GCRoots 的对象作为起始点，从这些节点从上 向下搜索，所走过的路径称为引用链，当一个对象没有任何引用链与 GCRoots 连接时就说明此对象不可用，也就是对象不可达。<br>GC Roots 对象通常包括：</p>
<ul>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表） </li>
<li>方法中类的静态属性引用的对象 </li>
<li>方法区中常量引用的对象 </li>
<li>Native 方法引用的对象</li>
</ul>
<p>可达性分析算法整个流程如下所示：<br>第一次标记：对象在经过可达性分析后发现没有与 GC Roots 有引用链，则进行 第一次标记并进行一次筛选，筛选条件是：该对象是否有必要执行 finalize()方法。 没有覆盖 finalize()方法或者 finalize()方法已经被执行过都会被认为没有必要执行。 如果有必要执行：则该对象会被放在一个 F-Queue 队列，并稍后在由虚拟机建立的低优先级 Finalizer 线程中触发该对象的 finalize()方法，但不保证一定等待它执行结束，因为如果这个对象的 finalize()方法发生了死循环或者执行时间较长的情况，会阻塞 F-Queue 队列里的其他对象，影响 GC。<br>第二次标记：GC 对 F-Queue 队列里的对象进行第二次标记，如果在第二次标记 时该对象又成功被引用，则会被移除即将回收的集合，否则会被回收。<br>总之，JVM 在做垃圾回收的时候，会检查堆中的所有对象否会被这些根集对象 引用，不能够被引用的对象就会被圾收集器回收。</p>
<p>一般回收算法也有如下几种：</p>
<p>1).标记-清除（Mark-sweep）<br>标记-清除算法采用从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象 的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效， 但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>
<p>2).标记-整理（Mark-Compact）<br>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不 同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移 动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了 对象的移动，因此成本更高，但是却解决了内存碎片的问题。该垃圾回收算法适 用于对象存活率高的场景（老年代）。</p>
<p>3).复制（Copying）<br>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已 使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存 碎片等复杂情况。</p>
<p>4).分代收集算法<br>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中 不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的 执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就 采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。Java 堆内存一般可以分为新生代、老年代和永久代三个模块：</p>
<p>新生代：<br>1.所有新生成的对象首先都是放在新生代的。新生代的目标就是尽可能快速的收 集掉那些生命周期短的对象。<br>2.新生代内存按照 8:1:1 的比例分为一个 eden 区和两个survivor(survivor0,survivor1)区。大部分对象在 Eden 区中生成。回收时先将 eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区，当这个 survivor0 区也 存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区， 然后清空 eden 和这个 survivor0 区，此时 survivor0 区是空的，然后将 survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。<br>3.当 survivor1 区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次 Full GC，也就是新生代、老 年代都进行回收。<br>4.新生代发生的 GC 也叫做 Minor GC，MinorGC 发生频率比较高(不一定等 Eden 区满了才触发)。</p>
<p>老年代：<br>1.在老年代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到老年代中。因 此，可以认为老年代中存放的都是一些生命周期较长的对象。<br>2.内存比新生代也大很多(大概比例是 1:2)，当老年代内存满时触发 Major GC， 即 Full GC。Full GC 发生频率比较低，老年代对象存活时间比较长。</p>
<p>永久代：<br>永久代主要存放静态文件，如 Java 类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如使用反射、动态代理、CGLib 等 bytecode 框架时，在这种时候需要设置一个比较大的永久代空间来存 放这些运行过程中新增的类。</p>
<p>垃圾收集器：</p>
<ul>
<li>Serial 收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程， 优点是简单高效；</li>
<li>Serial Old 收集器 (标记-整理算法): 老年代单线程收集器，Serial 收集器 的老年代版本；</li>
<li>ParNew 收集器 (复制算法): 新生代收并行集器，实际上是 Serial 收集器 的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现；</li>
<li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行 收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿 的特点，追求最短 GC 回收停顿时间。</li>
<li>Parallel Scavenge 收集器 (复制算法): 新生代并行收集器，追求高吞吐量， 高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC 线程时间)， 高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合 后台应用等对交互相应要求不高的场景；</li>
<li>Parallel Old 收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先， Parallel Scavenge 收集器的老年代版本；</li>
<li>G1(Garbage First)收集器 (标记-整理算法)： Java 堆并行收集器，G1 收 集器是 JDK1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实 现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器 的一个重要特点是：G1 回收的范围是整个 Java 堆(包括新生代，老年代)， 而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<p>Garbage-First（G1，垃圾优先）收集器是服务类型的收集器，目标是多处理器 机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。 Oracle JDK 7 update 4 以及更新发布版完全支持 G1 垃圾收集器。它是将堆内存被划分为多个大小相等的 heap 区,每个 heap 区都是逻辑上连续 的一段内存(virtual memory). 其中一部分区域被当成老一代收集器相同的角色 (eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提 供了更多的灵活性。</p>
<p>JAVA 自动内存管理：给对象分配内存 以及 回收分配给对象的内存。<br>1、对象优先在 Eden 分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起 一次 MinorGC。<br>2、大对象直接进入老年代。如很长的字符串以及数组。很长的字符串以及数组。<br>3、长期存活的对象将进入老年代。当对象在新生代中经历过一定次数（默认为 15）的 Minor GC 后，就会被晋升到老年代中。<br>4、动态对象年龄判定。为了更好地适应不同程序的内存状况，虚拟机并不是永 远地要求对象年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大 于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="Android-GC"><a href="#Android-GC" class="headerlink" title="Android GC"></a>Android GC</h3><p>Dalvik时期，对象的内存分配和回收都比较慢。因为Dalvik使用的GC是单线程的（早期的），在垃圾回收期间要暂停虚拟机上的其他所有线程。</p>
<p>Dalvik GC采用了并发标记-清除（CMS）算法。标记-清除算法的特点是，不用的对象不会马上回收，而是等到可用内存用尽之后才回收。这样导致了很多对象在用完之后还会在内存中存活较长时间，不能及时释放。</p>
<p>而且Dalvik GC只对后台的App进行内存整理（压缩），导致（前台App）堆中出现大量内存碎片，这些碎片往往都比较小，无法被分配给新对象，因为新的对象需要大块的连续内存空间。造成了严重的内存浪费。</p>
<p>Dalvik中GC的问题如下:</p>
<ol>
<li>GC时挂起所有线程</li>
<li>大而连续的空间紧张</li>
<li>内存碎片化严重</li>
</ol>
<p>ART</p>
<ol>
<li>在ART中标记不需要挂起所有程序的线程：在ART中GC会要求程序在分配空间的时候标记自身的堆栈，这个过程非常短，不需要挂起所有程序的线程（解决问题1）</li>
<li>提供 LOS ：large object space 专供Bitmap使用，从而提高了GC的管理效率和整体性能（解决问题2）</li>
<li>ART里有moving collector来压缩活动对象，使得内存空间更加紧凑 （解决问题3）</li>
</ol>
<p>整体来看，我们可以把Android的GC演变总结为四个阶段：</p>
<ol>
<li><p>Dalvik GC : 第一阶段的GC，对应系统版本为Android KitKat之前。Dalvik GC使用了比较旧的”stop the world”设计，在垃圾回收期间会暂停虚拟机上的所有线程。</p>
</li>
<li><p>ART GC (Lollipop &amp; Marshamllow) : GC发展历程中最大的一次改动，ART/Dalvik的开发团队重写了整个GC。这一阶段的GC也被叫做“分代GC”，因为对象会因存活时间不同而具有不同的“代”（或者叫年龄），另外还有其他方面的大的改进，比如分配内存的方式等。</p>
</li>
<li><p>ART GC(Nougat) : ART/Dalvik团队用汇编重写了整个内存分配的过程。</p>
</li>
<li><p>ART GC(Oreo) : 对第一版ART GC进行了优化，最明显的改进是把垃圾回收过程改为并发执行。这一代的GC也叫“并发复制垃圾回收器（Concurrent Copying Garbage Collector）”，同时在其他方面也做了不少优化。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/89536376">Android ART 并行拷贝垃圾回收</a></p>
</li>
</ol>
<p>   ART 有多个不同的 GC 方案，涉及运行不同的垃圾回收器。从 Android 8 (Oreo) 开始，默认方案是并发复制 (CC)。另一个 GC 方案是并发标记清除 (CMS)。</p>
<p>   ART 仍然支持的另一个 GC 方案是 CMS。此 GC 方案还支持压缩，但不是以并发方式。在应用进入后台之前，它会避免执行压缩，应用进入后台后，它会暂停应用线程以执行压缩。如果对象分配因碎片而失败，也必须执行压缩操作。在这种情况下，应用可能会在一段时间内没有响应。</p>
<p>CC GC 通过运行新生代 GC 或全堆 GC 来回收垃圾。理想情况下，新生代 GC 的运行频率更高。GC 会一直执行新生代 CC 回收，直到刚结束的回收周期的吞吐量（计算公式是：释放的字节数除以 GC 持续秒数）小于全堆 CC 回收的平均吞吐量。发生这种情况时，将为下一次并发 GC 选择全堆 CC（而不是新生代 CC）。全堆回收完成后，下一次 GC 将切换回新生代 CC。新生代 CC 在完成后不会调整堆占用空间限制，这是此策略发挥作用的一个关键因素。这使得新生代 CC 运行得越来越频繁，直到吞吐量低于全堆 CC，最终导致堆增大。</p>
<p>ART回收区分前后台,前台默认使用CC, 后台使用CCBackground.</p>
<p>区分回收力度GcType：<br>kGcTypeSticky：只回收上次GC后在Allocation Space中新分配的垃圾对象<br>kGcTypePartial：只回收Allocation Space的垃圾对象<br>kGcTypeFull：同时回收Zygote Space和Allocation Space的垃圾对象<br>kGcTypeMax</p>
<p>区分堆：<br>ImageSpace 主要用来管理加载到内存中的art文件<br>Zygote Space Zygote进程的heap区<br>LargeObjeactSpace  主要管理存放大对象的内存区域<br>RegionSpace 常规内存对象的分配区域</p>
<p>区分回收器：并发标记-清除CMS、半空间压缩SS、标记-压缩MC（Q已经移除）、并发复制回收CC、后台并发复制回收CCBackground等</p>
<p>区分内存分配器：线程私有分配区TLAB、专门分配大对象的LOS等</p>
<h2 id="锁与Collection"><a href="#锁与Collection" class="headerlink" title="锁与Collection"></a>锁与Collection</h2><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>synchronized 代码块是由一对儿 monitorenter/monitorexit 指令实现的， Monitor 对象是同步的基本实现，而 synchronized 同步方法使用了 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行 相应的同步调用。 在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要 进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。 现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同 的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、 轻量级锁和重量级锁，大大改进了其性能。 所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检 测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、 降级。</p>
<p>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作，在对象头上 的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不 涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周 期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。 如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销 （revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升 级为重量级锁（可能会先进行自旋锁升级，如果失败再尝试重量级锁升级）。 我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是 会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</p>
<p>synchronized 修饰静态方法获取的是类锁(类的字节码文件对象)。<br>synchronized 修饰普通方法或代码块获取的是对象锁。这种机制确保了同一时刻 对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处 于可执行状态，从而有效避免了类成员变量的访问冲突。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock 实现的前提就是 AbstractQueuedSynchronizer，简称 AQS，是 java.util.concurrent 的核心，CountDownLatch、FutureTask、Semaphore、 ReentrantLock 等都有一个内部类是这个抽象类的子类。由于 AQS 是基于 FIFO 队列的实现，因此必然存在一个个节点，Node 就是一个节点，Node 有两种模 式：共享模式和独占模式。ReentrantLock 是基于 AQS 的，AQS 是 Java 并发包中众多同步组件的构建基础，它通过一个 int 类型的状态变量 state 和一个 FIFO 队列来完成共享资源的获取，线程的排队等待等。AQS 是个底层框架，采用模 板方法模式，它定义了通用的较为复杂的逻辑骨架，比如线程的排队，阻塞，唤 醒等，将这些复杂但实质通用的部分抽取出来，这些都是需要构建同步组件的使 用者无需关心的，使用者仅需重写一些简单的指定的方法即可（其实就是对于共 享变量 state 的一些简单的获取释放的操作）。AQS 的子类一般只需要重写 tryAcquire(int arg)和 tryRelease(int arg)两个方法即可。</p>
<p>ReentrantLock的处理逻辑：</p>
<p>其内部定义了三个重要的静态内部类，Sync，NonFairSync，FairSync。Sync 作 为 ReentrantLock 中公用的同步组件，继承了 AQS（要利用 AQS 复杂的顶层逻 辑嘛，线程排队，阻塞，唤醒等等）；NonFairSync 和 FairSync 则都继承 Sync， 调用 Sync 的公用逻辑，然后再在各自内部完成自己特定的逻辑（公平或非公平）。<br>接着说下这两者的 lock()方法实现原理：</p>
<p>NonFairSync（非公平可重入锁）<br>1.先获取 state 值，若为 0，意味着此时没有线程获取到资源，CAS 将其设置为 1， 设置成功则代表获取到排他锁了；<br>2.若 state 大于 0，肯定有线程已经抢占到资源了，此时再去判断是否就是自己 抢占的，是的话，state 累加，返回 true，重入成功，state 的值即是线程重入的 次数；<br>3.其他情况，则获取锁失败。</p>
<p>FairSync（公平可重入锁）<br>可以看到，公平锁的大致逻辑与非公平锁是一致的，不同的地方在于了!hasQueuedPredecessors()这个判断逻辑，即便 state 为 0，也不能贸然直接去获取，要先去看有没有还在排队的线程，若没有，才能尝试去获取，做后面的处理。反之，返回 false，获取失败。</p>
<p>最后，说下 ReentrantLock 的 tryRelease()方法实现原理：<br>若 state 值为 0，表示当前线程已完全释放干净，返回 true，上层的 AQS 会意识到资源已空出。若不为 0，则表示线程还占有资源，只不过将此次重入的资源的释放了而已，返回 false。</p>
<p>ReentrantLock 是一种可重入的，可实现公平性的互斥锁，它的设计基于 AQS框架，可重入和公平性的实现逻辑都不难理解，每重入一次，state 就加 1，当然在释放的时候，也得一层一层释放。至于公平性，在尝试获取锁的时候多了一 个判断：是否有比自己申请早的线程在同步队列中等待，若有，去等待；若没有， 才允许去抢占。</p>
<p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数 据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每 次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。Java中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。<br>乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁， 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版 本号机制和 CAS 算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
<p>乐观锁适用于写比较少的情况下（多读场景），而一般多写的场景下用悲观锁就 比较合适。</p>
<p>乐观锁常见的两种实现方式：<br>1、版本号机制<br>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数， 当数据被修改时，version 值会加 1。当线程 A 要更新数据值时，在读取数据的 同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数 据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>2、CAS 算法<br>即 compare and swap（比较与交换），是一种有名的无锁算法。CAS 有 3 个操 作数，内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。 一般情况下是一个自旋操 作，即不断的重试。</p>
<p>比较：<br>Lock（ReentrantLock）的底层实现主要是 Volatile + CAS（乐观锁），而 Synchronized 是一种悲观锁，比较耗性能。但是在 JDK1.6 以后对 Synchronized 的锁机制进行了优化，加入了偏向锁、轻量级锁、自旋锁、重量级锁，在并发量 不大的情况下，性能可能优于 Lock 机制。所以建议一般请求并发量不大的情况 下使用 synchronized 关键字。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Unsafe 是 CAS 的核心类。因为 Java 无法直接访问底层操作系统，而是通过本地 （native）方法来访问。不过尽管如此，JVM 还是开了一个后门，JDK 中有一个 类 Unsafe，它提供了硬件级别的原子操作。</p>
<p>CAS，Compare and Swap 即比较并交换，设计并发算法时常用到的一种技术， java.util.concurrent 包全完建立在 CAS 之上，没有 CAS 也就没有此包，可见 CAS 的重要性。当前的处理器基本都支持 CAS，只不过不同的厂家的实现不一样罢了。 并且 CAS 也是通过 Unsafe 实现的，由于 CAS 都是硬件级别的操作，因此效率 会比普通加锁高一些。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile 有两条关键的语义：</p>
<ul>
<li>保证被 volatile 修饰的变量对所有线程都是可见的</li>
<li>禁止进行指令重排序</li>
</ul>
<p>什么是指令重排序？<br>指令重排序是指指令乱序执行，即在条件允许的情况下直接运行当前有能 力立即执行的后续指令，避开为获取一条指令所需数据而造成的等待，通 过乱序执行的技术提供执行效率。<br>指令重排序会在被 volatile 修饰的变量的赋值操作前，添加一个内存屏障，指令重排序时不能把后面的指令重排序移到内存屏障之前的位置。</p>
<p>synchronized 和 volatile 关键字的作用和区别。<br>Volatile：<br>1）保证了不同线程对这个变量进行操作时的可见性即一个线程修改了某个变量 的值，这新值对其他线程来是立即可见的。 2）禁止进行指令重排序。</p>
<p>volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的， 需从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变 量，其它线程被阻塞住。</p>
<p>1.volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类 级别的。<br>2.volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可 以保证变量的修改可见性和原子性。<br>3.volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。<br>4.volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译 器优化。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 1.7 原理：<br>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同 步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量) 的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。<br>put 方法:首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。<br>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保 证并发的原子性，所以 put 操作时仍然需要加锁处理。 首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞 争，则利用 scanAndLockForPut() 自旋获取锁:<br>尝试自旋获取锁。 如果重试的次数达到了 MAX_SCAN_RETRIES 则改为 阻塞锁获取，保证能获取成功。<br>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是 否相等，相等则覆盖旧的 value。为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断 是否需要扩容。最后会使用 unlock()解除当前 Segment 的锁。<br>get 方法：只需要将 Key 通过 Hash 之后定位到具体的 Segment ， 再通过一次 Hash 定位到具体的元素上。由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内 存可见性，所以每次获取时都是最新值。ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要 加锁。</p>
<p>ConcurrentHashMap 1.8 原理：<br>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但 依然存在 HashMap 在 1.7 版本中的问题：那就是查询遍历链表效率太低。和1.8 HashMap 结构类似：其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p>
<p>AtomicStampedReference：解 决 ABA 问题。这个类的 compareAndSet 方法作用是首先检查当前引用是 否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以 原子方式将该引用和该标志的值设置为给定的更新值。如果 CAS 不成功，则会原地自旋，如果长时间自旋会给 CPU 带来非常大 的执行开销。</p>
<p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率 （O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出 在新版的 JDK 中对 synchronized 优化是很到位的。</p>
<p>HashMap 何时扩容：<br>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值–即大于当前数组的长度乘以加载因子的值的时候，就要自动扩容。</p>
<p>扩容的算法是什么：<br>扩容(resize)就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度， 以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法是使用一 个新的数组代替已有的容量小的数组。</p>
<h3 id="Map、List、SparseArray"><a href="#Map、List、SparseArray" class="headerlink" title="Map、List、SparseArray"></a>Map、List、SparseArray</h3><p>ArrayList 和 LinkedList 怎么动态扩容的吗？<br>ArrayList 初始化大小是 10 （如果你知道你的 arrayList 会达到多少容量，可以 在初始化的时候就指定，能节省扩容的性能开支） 扩容点规则是，新增的时候 发现容量不够用了，就去扩容 扩容大小规则是，扩容后的大小= 原始大小+原始大小/2 + 1。（例如：原始大小是 10 ，扩容后的大小就是 10 + 5+1 = 16）</p>
<p>HashMap 1.7 的原理：<br>HashMap 底层是基于 数组 + 链表 组成的，不过在 jdk1.7 和 1.8 中具体实 现稍有不同。<br>负载因子：给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往 里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量 进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常 消耗性能。因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来 的性能损耗。</p>
<p>HashMap 1.8 的原理：<br>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效 率就会越来越低；时间复杂度为 O(N)，因此 1.8 中重点优化了这个查询效率。TREEIFY_THRESHOLD 用于判断是否需要将链表转换为红黑树的阈值。<br>修改为红黑树之后查询效率直接提高到了 O(logn)。但是 HashMap 原有的问题 也都存在，比如在并发场景下使用时容易出现死循环：<br>在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容 易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出 的 index 正好是环形链表的下标就会出现死循环：在 1.7 中 hash 冲突 采用的头插法形成的链表，在并发条件下会形成循环链表，一旦有查询落 到了这个链表上，当获取不到值时就会死循环。</p>
<p>ArrayMap、SparseArray<br>SparseArray 比 HashMap 更省内存，在某些条件下性能更好，主要是因为它避 免了对 key 的自动装箱（int 转为 Integer 类型），它内部则是通过两个数组来进 行数据存储的，一个存储 key，另外一个存储 value，为了优化性能，它内部对 数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源 码中可以看到 key 和 value 分别是用数组表示；同时，SparseArray 在存储和读取数据时候，使用的是二分查找法。也就是在 put 添加数据的时候，会使用二分查找法和之前的 key 比较当前我们添加的元素的 key 的大小，然后按照从小到大的顺序排列好，所以，SparseArray 存储的元素 都是按元素的 key 值从小到大排列好的。 而在获取数据的时候，也是使用二分 查找法判断元素的位置，所以，在获取数据的时候非常快，比 HashMap 快的多。</p>
<p>ArrayMap:<br>ArrayMap 利用两个数组，mHashes 用来保存每一个 key 的 hash 值，mArrray 大小为 mHashes 的 2 倍，依次保存 key 和 value。当插入时，根据 key 的 hashcode()方法得到 hash 值，计算出在 mArrays 的 index 位置，然后利用二分查找找到对应的位置进行插入，当出现哈希冲突时，会在 index 的相邻位置插入。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到 CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试 发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。<br>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生 的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结 果后，调用 resume() 使其恢复。<br>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果 等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。<br>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它 有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数， 前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙 述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法 则相反。</p>
<p>线程的生命周期：</p>
<ul>
<li>NEW：创建状态，线程创建之后，但是还未启动。</li>
<li>RUNNABLE：运行状态，处于运行状态的线程，但有可能处于等待状态， 例如等待 CPU、IO 等。</li>
<li>WAITING：等待状态，一般是调用了 wait()、join()、LockSupport.spark() 等方法。</li>
<li>TIMED_WAITING：超时等待状态，也就是带时间的等待状态。一般是调 用 了 wait(time) 、 join(time) 、 LockSupport.sparkNanos() 、 LockSupport.sparkUnit()等方法。</li>
<li>BLOCKED：阻塞状态，等待锁的释放，例如调用了 synchronized 增加了 锁。</li>
<li>TERMINATED：终止状态，一般是线程完成任务后退出或者异常终止。</li>
</ul>
<h3 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h3><p>核心参数:<br>corePoolSize:核心线程数<br>maximumPoolSize:最大线程数<br>keepAliveTime:非核心线程的闲置时间限制，超过则回收该非核心线程<br>workQueue:BlockingQueue类型，阻塞队列<br>threadFactory：线程的工厂类<br>handler：RejectedExecutionHandler线程池的饱和策略，默认策略是抛出运行时exception</p>
<p>在execute提交时：<br>1.如果线程数小于核心线程，则新建核心线程去执行任务Runable<br>2.将任务Runable加入workQueue中，然后检查是否可以新建线程<br>3.如果队列无法加入Runnable，检查是否可以新建线程(防止线程有回收的),如果不能，执行handler的拒绝策略</p>
<p>thread执行的对象是Worker对象，在worker中run方法会从queue中不停的取任务执行。</p>
<p>Runnable、Callable、Future是三个基础interface，分别是不带结果的运行，带结果的运行，对异步任务整个生命周期的表示。</p>
<p>FutureTask是class，继承了Runnable与Future，内部持有callable。一般外部传入callable。</p>
<p>java内置5中线程池：在Executors中提供静态方法<br>newCachedThreadPool：核心线程0，最大Integer.MAX_VALUE, keepAliveTime为60秒,SynchronousQueue同步阻塞队列。只有非核心线程,最大线程数非常大,所有线程都活动时会为新任务创建新线程, 否则会利用空闲线程(60s 空闲时间,过了就会被回收,所以线程池中有 0 个线程的 可能)处理任务。优点:任何任务都会被立即执行(任务队列 SynchronousQuue 相当于一个空集合); 比较适合执行大量的耗时较少的任务.<br>newSingleThreadExecutor：核心1，最大1，keepAliveTime为0，LinkedBlockingQueue。只有一个核心线程,确保所有的任务都在同一线程中按序完成.因此不需要处理线 程同步的问题.<br>newFixedThreadPool：核心n,最大n，keepAliveTime为0，LinkedBlockingQueue。只有核心线程,并且数量固定的,也不会被回收,所有线程都活动时,因为队列没有 限制大小,新任务会等待执行。优点:更快的响应外界请求。<br>newScheduledThreadPool：线程池为ScheduledThreadPoolExecutor，核心n，最大Integer.MAX_VALUE，keepAliveTime为10秒,DelayedWorkQueue（利用数组模拟堆实现）。主要处理定时任务，和Timer功能类似。核心线程数固定,非核心线程（闲着没活干会被立即回收数）没有限制.优点:执行定时任务以及有固定周期的重复任务<br>newWorkStealingPool：ForkJoinPool，使用一个无限队列来保存需要执行的任务，可以传入线程的数量，不传入，则默认使用当前计算机中可用的cpu数量，使用分治法来解决问题，使用fork()和join()来进行调用.</p>
<p>可以引入rxjava、kotlin线程池框架的比较？</p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>启动类加载器（Bootstrap ClassLoader）：负责加载<JAVA_HOME>\lib目录下或者被-Xbootclasspath 参数所指定的路径的，并且是被虚拟机所 识别的库到内存中。<br>扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录下或者被 java.ext.dirs 系统变量所指定的路径的所有类库到内存中。<br>应用类加载器（Application ClassLoader）：负责加载用户类路径上的指 定类库，如果应用程序中没有实现自己的类加载器，一般就是这个类加载 器去加载应用程序中的类库。</p>
<p>Android：<br>BootClassLoader（Java 的 BootStrap ClassLoader）： 用于加载 Android Framework 层 class 文件。<br>PathClassLoader（Java 的 App ClassLoader）： 用于加载已经安装到系 统中的 apk 中的 class 文件。<br>DexClassLoader（Java 的 Custom ClassLoader）： 用于加载指定目录中 的 class 文件。 BaseDexClassLoader： 是 PathClassLoader 和 DexClassLoader 的父类。</p>
<h3 id="软引用和弱引用"><a href="#软引用和弱引用" class="headerlink" title="软引用和弱引用"></a>软引用和弱引用</h3><p>1、软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软 / 弱引用。</p>
<p>2、如果只是想避免 OOM 异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p>
<p>3、可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对 象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p>
<h3 id="强引用置为-null，会不会被回收？"><a href="#强引用置为-null，会不会被回收？" class="headerlink" title="强引用置为 null，会不会被回收？"></a>强引用置为 null，会不会被回收？</h3><p>不会立即释放对象占用的内存。 如果对象的引用被置为 null，只是断开了当前 线程栈帧中对该对象的引用关系，而 垃圾收集器是运行在后台的线程，只有当 用户线程运行到安全点(safe point)或者安全区域才会扫描对象引用关系，扫描到 对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些 对象是可恢复的（在 finalize 方法中恢复引用 ）。只有确定了对象无法恢复引 用的时候才会清除对象内存。</p>
<h3 id="final，finally，finalize"><a href="#final，finally，finalize" class="headerlink" title="final，finally，finalize"></a>final，finally，finalize</h3><p>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代 表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以 重写的（override）。</p>
<p>finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁 等动作。</p>
<p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被 垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。Java 平台目前在逐步使用java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。Cleaner 的实现利用了幻 象引用（PhantomReference），这是一种常见的所谓 post-mortem 清理机制。 利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收 的工作，比如关闭文件描述符（操作系统有限的资源），它比 finalize 更加轻量、 更加可靠。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>Java char 不存 UTF-8 的字节，而是 UTF-16。</li>
<li>Unicode 通用字符集占两个字节，例如“中”。</li>
<li>Unicode 扩展字符集需要用一对 char 来表示，例如“表情”。</li>
<li>Unicode 是字符集，不是编码，作用类似于 ASCII 码。</li>
<li>Java String 的 length 不是字符数。</li>
</ul>
<p>Java String 可以有多长？<br>分配到栈：<br>String longString = “aaa…aaa”;<br>分配到堆：<br>byte[] bytes = loadFromFile(new File(“superLongText.txt”); String superLongString = new String(bytes);<br>是否对字符串在内存当中的存储形式有深入了解（高级）<br>是否对Java虚拟机字节码有足够的了解（高级）</p>
<p>Java String 栈分配</p>
<ul>
<li>受字节码限制，字符串最终的 MUTF-8 字节数不超过 65535。</li>
<li>Latin 字符，受 Javac 代码限制，最多 65534 个。</li>
<li>非 Latin 字符最终对应字节个数差异较大，最多字节个数是 65535。</li>
<li>如果运行时方法区设置较小，也会受到方法区大小的限制。</li>
</ul>
<p>Java String 堆分配</p>
<ul>
<li>受虚拟机指令限制，字符数理论上限为 Integer.MAX_VALUE。</li>
<li>受虚拟机实现限制，实际上限可能会小于 Integer.MAX_VALUE。</li>
<li>如果堆内存较小，也会受到堆内存的限制。</li>
</ul>
<p>Java String 字面量形式</p>
<ul>
<li>字节码中 CONSTANT_Utf8_info 的限制，大小为65534（jvm字节码U2的最大长度）</li>
<li>Javac 源码逻辑的限制</li>
<li>方法区大小的限制</li>
</ul>
<p>Java String 运行时创建在堆上的形式</p>
<ul>
<li>Java 虚拟机指令 newarray 的限制</li>
<li>Java 虚拟机堆内存大小的限制</li>
</ul>
<p>String内部是以char数组的形式存储，数组的长度是int类型，那么String允许的最大长度就是Integer.MAX_VALUE了。又由于java中的字符是以16位存储的，因此大概需要4GB的内存才能存储最大长度的字符串。</p>
<p>String 为什么要设计成不可变的？<br>String 是不可变的（修改 String 时，不会在原有的内存地址修改，而是重新指向 一个新对象），String 用 final 修饰，不可继承，String 本质上是个 final 的 char[] 数组，所以 char[]数组的内存地址不会被修改，而且 String 也没有对外暴露修改 char[]数组的方法。不可变性可以保证线程安全以及字符串串常量池的实现。</p>
<p>String，StringBuffer，StringBuilder 有哪些不同<br>三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String<br>String 每次变化一个值就会开辟一个新的内存空间<br>StringBuilder：线程非安全的<br>StringBuffer：线程安全的</p>
<p>对于三者使用的总结：<br>1.如果要操作少量的数据用 String。<br>2.单线程操作字符串缓冲区下操作大量数据用 StringBuilder。<br>3.多线程操作字符串缓冲区下操作大量数据用 StringBuffer。</p>
<h2 id="网络协议相关"><a href="#网络协议相关" class="headerlink" title="网络协议相关"></a>网络协议相关</h2><h4 id="Http1-1-和-Http1-0-及-2-0-的区别"><a href="#Http1-1-和-Http1-0-及-2-0-的区别" class="headerlink" title="Http1.1 和 Http1.0 及 2.0 的区别"></a>Http1.1 和 Http1.0 及 2.0 的区别</h4><p>HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络 请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：<br>1、缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做 为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag， If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓 存策略。<br>2、带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户 端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点 续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分， 即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利 用带宽和连接。<br>3、错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict） 表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资 源被永久性的删除。<br>4、Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此， 请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展， 在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它 们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求 消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。<br>5、长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线 （Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建 立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一 定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</p>
<p>SPDY<br>在讲 Http1.1 和 Http2.0 的区别之前，还需要说下 SPDY，它是 HTTP1.x 的优化方案：<br>2012 年 google 如一声惊雷提出了 SPDY 的方案，优化了 HTTP1.X 的请求延迟，解决了 HTTP1.X 的安全性，具体如下：<br>1、降低延迟，针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。 多路复用通过多个请求 stream 共享一个 tcp 连接的方式，解决了 HOL blocking 的 问题，降低了延迟同时提高了带宽的利用率。<br>2、请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接 共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先 级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应 该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能 第一时间看到网页内容。<br>3、header 压缩。前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适 的压缩算法可以减小包的大小和数量。<br>4、基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性。<br>5、服务端推送（server push），采用了 SPDY 的网页，例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户 端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。<br>SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议(将 HTTP1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能。</p>
<p>HTTP2.0 和 HTTP1.X 相比的新特性<br>新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本。基于文本协议的 格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然 很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定 采用二进制格式，实现方便且健壮。<br>多路复用（MultiPlexing），即连接共享，即每一个 request 都是是用作连接共享机 制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属 到各自不同的服务端请求里面。<br>header 压缩，如上文中所言，对前面提到过 HTTP1.x 的 header 带有大量信息，而 且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯 双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需 要传输的大小。<br>服务端推送（server push），同 SPDY 一样，HTTP2.0 也具有 server push 功能。</p>
<h4 id="Https-请求慢的解决办法"><a href="#Https-请求慢的解决办法" class="headerlink" title="Https 请求慢的解决办法"></a>Https 请求慢的解决办法</h4><p>1、不通过 DNS 解析，直接访问 IP<br>2、解决连接无法复用<br>http/1.0 协议头里可以设置 Connection:Keep-Alive 或者 Connection:Close，选择是否允许 在一定时间内复用连接（时间可由服务器控制）。但是这对 App 端的请求成效不大，因为 App 端的请求比较分散且时间跨度相对较大。<br>基于 tcp 的长连接 (主要） 移动端建立一条自己的长链接通道，通道的实现是基于 tcp 协议。基于 tcp 的 socket 编程技术难度相对复杂很多，而且需要自己定制协议。但信息 的上报和推送变得更及时，请求量爆发的时间点还能减轻服务器压力（避免频繁创建和销毁 连接）</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>HTTP 的缓存可以分为两种： 强制缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据是，服务端返 回了缓存的过期时间（Expires 与 Cache-Control），没有过期就可以继续使用缓存，否则则 不适用，无需再向服务端询问。 对比缓存：需要服务端参与判断是否继续使用缓存，当客 户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since 与 Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请 求数据时，客户端将上次备份的缓存 标识发送给服务端，服务端根据缓存标识进行判断， 如果返回 304，则表示通知客户端可以继续使用缓存。 强制缓存优先于对比缓存。</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>1、要选择合适的图片规格（bitmap 类型）：</p>
<p>ALPHA_8每个像素占用 1byte 内存 ,ARGB_4444 每个像素占用 2byte 内存 ,ARGB_8888 每个像素占用 4byte 内存（默认）,RGB_565 每个像素占用 2byte 内存</p>
<p>2、降低采样率。BitmapFactory.Options 参数 inSampleSize 的使用，先把 options.inJustDecodeBounds 设为 true，只是去读取图片的大小，在拿到图片的 大小之后和要显示的大小做比较通过 calculateInSampleSize()函数计算 inSampleSize 的具体值，得到值之后。options.inJustDecodeBounds 设为 false 读图片资源。</p>
<p>3、复用内存。即，通过软引用(内存不够的时候才会回收掉)，复用内存块，不 需要再重新给这个 bitmap 申请一块新的内存，避免了一次内存的分配和回收， 从而改善了运行效率。</p>
<p>4、使用 recycle()方法及时回收内存。</p>
<p>5、压缩图片。</p>
<p>在 Android 中，Bitmap 的存储分为两部分，一部分是 Bitmap 的数据，一部分是 Bitmap 的引用。 在 Android2.3 时代，Bitmap 的引用是放在堆中的，而 Bitmap 的数据部分是放在栈中的，需要用户调用 recycle 方法手动进行内存回收，而在 Android2.3 之后，整个 Bitmap，包括数据和引用，都放在了堆中，这样，整个 Bitmap 的回收就全部交给 GC 了，这个 recycle 方法就再也不需要使用了。</p>
<p>bitmap recycler 引发的问题：当图像的旋转角度小余两个像素点之间的夹角时， 图像即使旋转也无法显示，因此，系统完全可以认为图像没有发生变化。这时系 统就直接引用同一个对象来进行操作，避免内存浪费。</p>
<p>BitmapFactory 四类方法：<br>decodeFile( 文件系统 )<br>decodeResourece( 资源 )<br>decodeStream( 输入流 )<br>decodeByteArray( 字节数 )</p>
<h4 id="Bitmap-占用内存"><a href="#Bitmap-占用内存" class="headerlink" title="Bitmap 占用内存"></a>Bitmap 占用内存</h4><p>Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存</p>
<p>注：这里 inDensity 表示目标图片的 dpi（放在哪个资源文件夹下）， inTargetDensity 表示目标屏幕的 dpi，所以你可以发现 inDensity 和 inTargetDensity 会对 Bitmap 的宽高进行拉伸，进而改变 Bitmap 占用内存的大 小。 在 Bitmap 里有两个获取内存占用大小的方法。</p>
<p>getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。 getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存 大小，代替了 getByteCount() 方法。 在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片 时，那么 getByteCount() 表示新解码图片占用内存的大 小， getAllocationByteCount() 表示被复用 Bitmap 真实占用的内存大小（即 mBuffer 的长度）。</p>
<p>为了保证在加载 Bitmap 的时候不产生内存溢出，可以使用 BitmapFactory 进行 图片压缩，主要有以下几个参数：<br>BitmapFactory.Options.inPreferredConfig：将 ARGB_8888 改为 RGB_565，改变 编码方式，节约内存。<br>BitmapFactory.Options.inSampleSize：缩放比例，可以 参考 Luban 那个库，根据图片宽高计算出合适的缩放比例。<br>BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。<br>inJustDecodeBounds 获取图片的宽高信息，交给 inSampleSize 参数选 择缩放比</p>
<p>高效加载 Bitmap 的流程:<br>1、将 BitmapFactory.Options 的 inJustDecodeBounds 参数设为 true 并加载图片<br>2、从 BitmapFactory.Options 中取出图片原始的宽高信息， 对应于 outWidth 和 outHeight 参数 3、根据采样率规则并结合目标 view 的大小计算出采样率 inSampleSize<br>4、将 BitmapFactory.Options 的 inJustDecodeBounds 设置为 false 重 新加载图片</p>
<p>针对清明上河图这种大图可以使用 BitmapRegionDecoder 动态加载图片的显示区域。</p>
<p><strong>Bitmap.recycle()会立即回收么？什么时候会回收？如果没有地方使用这个 Bitmap，为什么垃圾回收不会直接回收？</strong></p>
<p>通过源码可以了解到，加载 Bitmap 到内存里以后，是包含两部 分内存区域的。简单的说，一部分是 Java 部分的，一部分是 C 部分的。这个 Bitmap 对象是由 Java 部分分配的，不用的时候 系统就会自动回收了。但是那个对应的 C 可用的内存区域，虚拟机是不能直接回收 的，这个只能调用底层的功能释放。所以需要调用 recycle()方 法来释放 C 部分的内存。bitmap.recycle()方法用于回收该 Bitmap 所占用的内存，接着 将 bitmap 置空，最后使用 System.gc()调用一下系统的垃圾回 收器进行回收，调用 System.gc()并不能保证立即开始进行回收 过程，而只是为了加快回收的到来。</p>
<h2 id="图片框架"><a href="#图片框架" class="headerlink" title="图片框架"></a>图片框架</h2><h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h4><p>为什么要在项目中使用这个库？<br>1.多样化媒体加载：不仅可以进行图片缓存，还支持 Gif、WebP、缩略图，甚 至是 Video。<br>2.通过设置绑定生命周期：可以使加载图片的生命周期动态管理起来。<br>3.高效的缓存策略：支持内存、Disk 缓存，并且 Picasso 只会缓存原始尺寸的 图片，内 Glide 缓存的是多种规格，也就是 Glide 会根据你 ImageView 的大小来 缓存相应大小的图片尺寸。<br>4.内存开销小：默认的 Bitmap 格式是 RGB_565 格式，而 Picasso 默认的是 ARGB_8888 格式，内存开销小一半。</p>
<p>这个库都有哪些用法？对应什么样的使用场景？<br>1.图片加载Glide.with(this).load(imageUrl).override(800,800).placeholder().error().animate().into()。<br>2.多样式媒体加载：asBitamp、asGif。<br>3.生命周期集成。<br>4.可以配置磁盘缓存策略 ALL、NONE、SOURCE、RESULT。</p>
<p>Glide&amp;with:<br>1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等） 以及 glide 对象。<br>2、将 glide 请求和 application/SupportFragment/Fragment 的生命周期绑定在一块。</p>
<p>Glide&amp;load：<br>设置请求 url，并记录 url 已设置的状态。</p>
<p>Glide&amp;into：<br>1、首先根据转码类 transcodeClass 类型返回不同的 ImageViewTarget：BitmapImageViewTarget、DrawableImageViewTarget。<br>2、递归建立缩略图请求，没有缩略图请求，则直接进行正常请求。<br>3、如果没指定宽高，会根据 ImageView 的宽高计算出图片宽高，最终执行到 onSizeReay()方法中的 engine.load()方法。<br>4、engine 是一个负责加载和管理缓存资源的类</p>
<p>常规三级缓存的流程：强引用-&gt;软引用-&gt;硬盘缓存<br>当我们的APP中想要加载某张图片时，先去LruCache中寻找图片，如果LruCache 中有，则直接取出来使用，如果 LruCache 中没有，则去 SoftReference 中寻找 （软引用适合当 cache，当内存吃紧的时候才会被回收。而 weakReference 在每 次 system.gc（）就会被回收）（当 LruCache 存储紧张时，会把最近最少使用 的数据放到 SoftReference 中），如果 SoftReference 中有，则从 SoftReference 中取出图片使用，同时将图片重新放回到 LruCache 中，如果 SoftReference 中 也没有图片，则去硬盘缓存中中寻找，如果有则取出来使用，同时将图片添加到 LruCache 中，如果没有，则连接网络从网上下载图片。图片下载完成后，将图 片保存到硬盘缓存中，然后放到 LruCache 中。</p>
<p>Glide 缓存机制大致分为三层：内存缓存、弱引用缓存、磁盘缓存。<br>取的顺序是：内存、弱引用、磁盘。<br>存的顺序是：弱引用、内存、磁盘。</p>
<p>三层存储的机制在 Engine 中实现的。先说下 Engine 是什么？Engine 这一层负 责加载时做管理内存缓存的逻辑。持有 MemoryCache、Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;。通过 load（）来加载图片，加载前后 会做内存存储的逻辑。如果内存缓存中没有，那么才会使用 EngineJob 这一层来 进行异步获取硬盘资源或网络资源。EngineJob类似一个异步线程或observable。 Engine 是一个全局唯一的，通过 Glide.getEngine()来获取。</p>
<p>需要一个图片资源，首先先取ActiveResources，activeResources是盛放正在使用的资源，以弱引用的形式存在。同时资源内部有被引用的记录。如果资源没有引用记录了，那么再放回 Lrucache 中，同时从 activeResources 中清除（activeResources开启了一个后台线程专门检测ReferenceQueue）。如果没有，则继续从LruResourceCache中取，取到以后从LruResourceCache删除同时加入ActiveResources中。如果 Lrucache 和 activeResources 中没有，那么进行资源异步请求（网络 /diskLrucache），请求成功后，资源放到 diskLrucache 和 activeResources 中。</p>
<p>缓存：<br>ActiveResources 活跃的内存缓存，使用的是弱引用的方式，用作优化列表反复滑动中Lru频繁清除，然后在重新加载的情况<br>LruResourceCache 内存缓存,不包含正在使用的资源。使用cache.remove(key)从LruResourceCache获取缓存<br>ResourceCacheGenerator:缓存的被加工过的原数据缓存（磁盘)<br>DataCacheGenerator:原文件<br>SourceGenerator:从网络加载数据</p>
<p>Glide源码机制的核心思想：</p>
<p>使用一个弱引用 map activeResources 来盛放项目中正在使用的资源。Lrucache 中不含有正在使用的资源。资源内部有个计数器来显示自己是不是还有被引用的 情况，把正在使用的资源和没有被使用的资源分开有什么好处呢？？因为当 Lrucache 需要移除一个缓存时，会调用 resource.recycle()方法。注意到该方法上 面注释写着只有没有任何 consumer 引用该资源的时候才可以调用这个方法。那 么为什么调用 resource.recycle()方法需要保证该资源没有任何 consumer 引用 呢？glide 中 resource 定义的 recycle（）要做的事情是把这个不用的资源（假设 是 bitmap 或 drawable）放到 bitmapPool 中。bitmapPool 是一个 bitmap 回收 再利用的库，在做 transform 的时候会从这个 bitmapPool 中拿一个 bitmap 进行 再利用。这样就避免了重新创建 bitmap，减少了内存的开支。而既然 bitmapPool 中的 bitmap 会被重复利用，那么肯定要保证回收该资源的时候（即调用资源的 recycle（）时），要保证该资源真的没有外界引用了。这也是为什么 glide 花费 那么多逻辑来保证 Lrucache 中的资源没有外界引用的原因。</p>
<p>相关问题：<br>Glide 如何确定图片加载完毕？<br>Glide 使用什么缓存？<br>Glide 内存缓存如何控制大小？</p>
<h4 id="Fresco"><a href="#Fresco" class="headerlink" title="Fresco"></a>Fresco</h4><p>DraweeView：继承于 ImageView，只是简单的读取 xml 文件的一些属性值和做 一些初始化的工作，图层管理交由 Hierarchy 负责，图层数据获取交由负责。<br>DraweeHierarchy：由多层 Drawable 组成，每层 Drawable 提供某种功能（例如： 缩放、圆角）。 DraweeController：控制数据的获取与图片加载，向 pipeline 发出请求，并接收相应事件，并根据不同事件控制 Hierarchy，从 DraweeView 接收用户的事件，然后执行取消网络请求、回收资源等操作。<br>DraweeHolder： 统筹管理 Hierarchy 与 DraweeHolder。<br>ImagePipeline：Fresco 的核心模块，用 来以各种方式（内存、磁盘、网络等）获取图像。 Producer/Consumer：Producer 也有很多种，它用来完成网络数据获取，缓存数据获取、图片解码等多种工作， 它产生的结果由 Consumer 进行消费。<br>IO/Data：这一层便是数据层了，负责实 现内存缓存、磁盘缓存、网络缓存和其他 IO 相关的功能。</p>
<p>具体实现：<br>GenericDraweeHierarchy：负责 SimpleDraweeView 上的图层管理，由多层 Drawable 组成，每层 Drawable 提供某种功能（例如：缩放、圆角）。</p>
<ol>
<li>背景图（backgroundImage）</li>
<li>占位图（placeholderImage=）</li>
<li>加载的图片（actualImage）</li>
<li>进度条（progressBarImage）</li>
<li>重试加载的图片（retryImage）</li>
<li>失败图片（failureImage）</li>
<li>叠加图（overlayImage）</li>
</ol>
<p>内存缓存：</p>
<p>已解码的内存缓存（BitmapMemoryCache）与未解码的内存缓存（EncodedMemoryCache）区别就是已解码内存缓存的数据是CloseableReference<CloseableBitmap>。而未解码内存缓存的数据是CloseableReference<PooledByteBuffer>。即他们的实现方式一样，区别仅仅在于<strong>资源的测量与释放方式不同</strong>。它们使用ValueDescriptor来描述不同资源的数据大小，使用不同的ResourceReleaser来释放资源。</p>
<p>BitmapMemoryCache（已解码的内存缓存）：BitmapMemoryCacheFactory提供工厂方法获取存储缓存的数据结构。<br>EncodedMemoryCache（未解码的内存缓存）：EncodedCountingMemoryCacheFactory提供工厂方法获取存储缓存的数据结构。</p>
<p>CountingLruMap：Fresco中定义的LRU缓存载体，里面使用了LinkedHashMap作为数据存储载体，但是并没有启用LinkedHashMap的accessOrder功能。同时里面封装了map中的总大小mSizeInBytes，还有各个缓存的大小（ValueDescriptor.getSizeInBytes）。</p>
<p>CountingMemoryCache:具体缓存缓存实现<br>Fresco中实现具体内存缓存的类是CountingMemoryCache，它内部维持着几个重要参数：<br>ExclusiveEntries存储着未被使用的对象的CountingLruMap；<br>CachedEntries存储着所有对象的CountingLruMap；<br>MemoryCacheParams存储着最大缓存对象数量、缓存池大小等参数;<br>PARAMS_INTERCHECK_INTERVAL_MS检查缓存参数变化的事件间隔：5分钟；</p>
<p>它使用一个内部类Entry来封装缓存对象，除了记录缓存键、缓存对象之外，它还记录着该对象的引用数量（clientCount）及是否被缓存追踪（isOrphan）。注意：每个缓存对象只有满足clientCount为0并且isOrphan为true时才可以被释放，可从referenceToClose函数中看出此逻辑。</p>
<p>Fresco使用InstrumentedMemoryCache包装了CountingMemoryCache，主要增加的功能就是提供了MemoryCacheTracker，会在缓存命中或未命中时提供回调函数，供使用者实现自定义功能。</p>
<p>Fresco的缓存调用处：</p>
<p>1.BitmapMemoryCacheProducer：已解码的内存缓存的调用处<br>2.EncodedMemoryCacheProducer：未解码的内存缓存的调用处<br>3.DiskCacheReadProducer：磁盘中未解码的内存缓存的调用处<br>4.NetworkFetchProducer:从网络获取图片的调用处</p>
<p>这里提一点Bitmap缓存：在5.0以下系统，Bitmap缓存位于ashmem，这样Bitmap对象的创建和释放将不会引发GC，更少的GC会使你的APP运行得更加流畅。5.0及其以上系统，相比之下，内存管理有了很大改进，所以Bitmap缓存直接位于Java的heap上。</p>
<h4 id="Fresco-与-Glide-的对比："><a href="#Fresco-与-Glide-的对比：" class="headerlink" title="Fresco 与 Glide 的对比："></a>Fresco 与 Glide 的对比：</h4><p>Glide：相对轻量级，用法简单优雅，支持 Gif 动态图，适合用在那些对图片依赖 不大的 App 中。 Fresco：采用匿名共享内存来保存图片，也就是 Native 堆，有 效的的避免了 OOM，功能强大，但是库体积过大，适合用在对图片依赖比较大 的 App 中。</p>
<h4 id="实现一个-ImageLoader-的流程"><a href="#实现一个-ImageLoader-的流程" class="headerlink" title="实现一个 ImageLoader 的流程"></a>实现一个 ImageLoader 的流程</h4><p>同步异步加载、图片压缩、内存硬盘缓存、网络拉取</p>
<p>1.同步加载只创建一个线程然后按照顺序进行图片加载<br>2.异步加载使用线程池，让存在的加载任务都处于不同线程<br>3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载</p>
<p>具体为：</p>
<p>1、ImageLoader 作为一个单例，提供了加载图片到指定控件的方法：直 接从内存缓存中获取对象，如果没有则用一个 ThreadPoolExecutor 去执 行 Runnable 任务来加载图片。ThreadPoolExecutor 的创建需要指定核心 线程数 CPU 数+1，最大线程数 CPU 数*2+1，线程闲置超市时长 10s,这几 个关键数据，还可以加入 ThreadFactory 参数来创建定制化的线程。<br>2、ImageLoader 的具体实现 loadBitmap：先从内存缓存 LruCache 中加 载，如果为空再从磁盘缓存中加载，加载成功后记得存入内存缓存，如果 为空则从网络中直接下载输出流到磁盘缓存，然后再从磁盘中加载，如果 为 空 并 且 磁 盘 缓 存 没 有 被 创 建 的 话 ， 直 接 通 过 BitmapFactory 的 decodeStream 获取网络请求的输入流获取 Bitmap 对象。<br>3、v4 包的 LruCache 可以兼容到 2.2 版本，LruCache 采用 LinkedHashMap 存储缓存对象。创建对象只需要提供缓存容量并重写 sizeOf 方法：作用 是计算缓存对象的大小。有时需要重写 entryRemoved 方法，用于回收一 些资源。<br>4、DiskLruCache 通过 open 方法创建，设置缓存路径，缓存容量。缓存 添加通过 Editor 对象创建输出流，下载资源到输出流完成后，commit， 如果失败则 abort 撤回。然后刷新磁盘缓存。缓存查找通过 Snapshot 对象获取输入流，获取 FileDescriptor，通过 FileDescriptor 解析出 Bitmap 对象。 5、列表中需要加载图片的时候，当列表在滑动中不进行图片加载，当滑 动停止后再去加载图片。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="webview相关"><a href="#webview相关" class="headerlink" title="webview相关"></a>webview相关</h2><p>客户端api通过native://method?para=x的方式出发，主要提供一些小程序和客户端的交互，对小程序屏蔽客户端差异。实现方式：java调用h5：webView.loadUrl(js); h5调用客户端：shouldOverrideUrlLoading拦截请求url。使用注解的方式维护方法名和method的映射关系，同时还可以指定方法是否可以立即返回。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>webview原生的安全漏洞：<br>1.addJavascriptInterface方法导致远程代码执行漏洞，前端可以获取到addJavascriptInterface的java对象的Class对象，Class.forName可以加载java.lang.Runtime 类,通过Runtime可以执行本地命令。该漏洞4.2版本后被修复，使用@JavascriptInterface进行注解从而避免漏洞攻击。<br>2.WebView默认开启密码保存功能，关键是密码会被明文存入 /data/data/com.package.name/databases/webview.db ,解决方案是关闭密码保存提醒<br>3.setAllowFileAccess允许小程序可以访问访问本地文件，容易导致本地隐私文件泄漏，setAllowUniversalAccessFromFileURLs设置是否允许通过 file url 加载的 Javascript 可以访问其他的源(包括http、https等源),setAllowFileAccessFromFileURLs设置是否允许通过 file url 加载的 Js代码读取其他的本地文件，小程序要求setAllowFileAccess(true)和setJavaScriptEnabled(true)让浏览器加载html和js代码，使用setAllowUniversalAccessFromFileURLs(false)和setAllowFileAccessFromFileURLs(false)禁止本地j访问文件。</p>
<p>客户端层面安全：<br>1.客户端api区分安全等级，有些方法需要授权才可以访问<br>2.客户端api白名单，有些api需要后台配置了才能访问<br>3.由于跨域问题，小程序的网络请求必须由客户端转发</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>1.客户端调用h5使用evaluateJavascript，比loadurl速度快<br>2.缓存最近打开的5个小程序，保留每个小程序打开的完整Fragment栈，在栈中的小程序可以做到秒开</p>
<p>###客户端与小程序的相互调用</p>
<p>1.客户端调用小程序：loadUrl与evaluateJavascript<br>2.小程序调用客户端：addJavascriptInterface、shouldOverrideUrlLoading和onJsPrompt三种方式</p>
<h2 id="AMS相关"><a href="#AMS相关" class="headerlink" title="AMS相关"></a>AMS相关</h2><p>Activity的attach中生成PhoneWindow对象;PhoneWindow的setContentView中初始化DecorView（ViewGroup），同时使用LayoutInflater解析布局文件。在view中有一个getViewRootImpl，获取ViewRootImpl。在WindowmanagerGlobal中addView时创建ViewRootImpl,同时新建View.AttachInfo，viewrootImpl在performTraversals时将View.AttachInfo传给view。</p>
<p>ViewRootImp 在 onCreate() 时还没创建；在 onResume()时，即ActivityThread 的 handleResumeActivity() 执 行后才创建，调用 requestLayout()，走到 checkThread() 时就报错了。</p>
<p>Activity中持有WindowManager，addview是通过WindowManager调用到WindowManagerGlobal中的。</p>
<h2 id="WMS相关"><a href="#WMS相关" class="headerlink" title="WMS相关"></a>WMS相关</h2><p>Activity有一个phonewindow和WindowManager，phonewindow有一个decorView。activitythread在handleResumeActivity时从activity中取出WindowManager，调用addView（decorview），此时创建viewrootImpl，同时调用viewrootImpl.setView(decorview)，调用mWindowSession.addToDisplay将window添加到屏幕。</p>
<p>WindowManagerImpl代理给WindowManagerGlobal。WindowManagerGlobal中有IWindowSession和IWindowManager两个binder客户端，static修饰。WindowManagerGlobal中有三个List，分别为View、ViewRootImpl、WindowManager.LayoutParams，管理窗口级view的增删更新等，虽然最终的操作都是转发到ViewrootImpl中，在这里通过mWindowSession做ipc,然后结果通知回来更新WindowManagerGlobal中管理的参数。</p>
<p>Window定义了三种窗口类型：系统Window、应用程序Window、子Window。每一种窗口类型定义了一种对应的type。<br>应用类型的窗口的type范围是１<del>99，子窗口的type范围是1000</del>1999，系统的窗口的type范围是2000以上。</p>
<p>WindowState是WMS中事实的窗口，而不是Window，WindowState是在WMS的addWindow方法中创建，包含了一个窗口的所有的属性，其中一个属性为mLayer，表示窗口在Ｚ轴的位置，mLayer值越小，窗口越靠后，mLayer值越大，窗口越靠前，最前面的一个窗口就作为焦点窗口，可以接收触摸事件。因为窗口的切换，切换后的Ｚ序(窗口的显示次序称为 Z 序)就可能不同，所以mLayer的值不是固定不变的。mLayer是通过WindowState的另一个成员变量mBaseLayer的值计算得到，mBaseLayer的值是固定不变的，只和窗口类型有关。mBaseLayer(称为主序)是WindowState的构造方法中赋值。mBaseLayer =窗口类型×10000+1000。</p>
<h2 id="View相关"><a href="#View相关" class="headerlink" title="View相关"></a>View相关</h2><p>view中requestLayout层层调用parent.requestLayout,其实最终是调用viewrootImpl.requestLayout的。requestLayout中检测了线程，只要创建viewrootImpl的线程和执行requestLayout线程是相同即可。</p>
<p>viewrootImpl.setView(decorview)时将调用view.assignParent(this);将viewrootImpl设置为view的parent。</p>
<p>viewrootImpl中requestLayout调用scheduleTraversals，mHandler.getLooper().postSyncBarrier()插入屏障消息, mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);为mTraversalRunnable注册16ms回调。mTraversalRunnable中执行performTraversals，大致为三个步骤performMeasure，performLayout，performDraw。</p>
<p>viewrootImpl的scheduleTraversals向Choreographer注册了CALLBACK_INPUT和CALLBACK_TRAVERSAL两种类型callback</p>
<p>Choreographer在doframe时执行doCallbacks时，执行的CALLBACK_INPUT回调时，会回调到viewrootImpl的doConsumeBatchedInput。然后执行viewrootImpl中的WindowInputEventReceiver.onInputEvent()。转发给viewrootImpl中的InputStage（有5个实现，应该使用不同策略处理InputEvent（包含KeyEvent和MotionEvent）），InputStage调用view.dispatchPointerEvent,然后dispatchTouchEvent方法。DecorView的dispatchTouchEvent会将事件转发到mWindow.getCallback()中（其实就是activity中）。activity中getWindow().superDispatchTouchEvent(ev)将时间转发给mDecor.superDispatchTouchEvent(event);继续view层的事件转发。如果都没有处理，最后回调activity.onTouchEvent方法。</p>
<p>view层事件转发流程：dispatchTouchEvent—&gt;onInterceptTouchEvent–&gt;onTouchEvent</p>
<h2 id="binder相关"><a href="#binder相关" class="headerlink" title="binder相关"></a>binder相关</h2><p>驱动层：<br>设备初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。分别对应应用程序的open、mmap、ioctl的调用。</p>
<p>write_buffer和read_buffer都是包含Binder协议命令和binder_transaction_data结构体。</p>
<ul>
<li>copy_from_user()将用户空间IPC数据拷贝到内核态binder_write_read结构体；</li>
<li>copy_to_user()将用内核态binder_write_read结构体数据拷贝到用户空间；</li>
</ul>
<p>应用程序层：</p>
<p>在native层由BBinder和BpBinder，在java层由Binder和BinderProxy。</p>
<h5 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h5><ol>
<li>binder的线程池最大数量默认为16，system_service进程就有16个线程程。</li>
<li>Binder内存大小限制为1M-8K。普通app在初始化时调用mmap申请了1M-8K，虽然在内核中是限制了4M，但是依然还是1M-8K。ServiceManager进程binder仅仅申请了128K的内存，因为他不需要传输大量数据。</li>
<li>大量数据使用binder的传递的方式：</li>
</ol>
<ul>
<li>非跨进程，使用静态变量来避免大量数据的拷贝，或者使用Eventbus等框架进行引用传递。</li>
<li>分批次传输，例如分页</li>
<li>对效率要求不高，可以使用socket或者文件方式。</li>
<li>使用ashmem匿名共享内存。使用例子Bundle.putBinder、ContentProvider、MemoryFile。推荐使用这个方式。</li>
</ul>
<p>tip：Intent如果允许传输文件符，则可以避免大量数据拷贝。但是startActivity时会调用 setAllowFds(false)禁止掉文件符传输。</p>
<p>binder是为了ipc(进程间通信)设计的，并不是为了数据传输设计的。</p>
<h2 id="handler相关"><a href="#handler相关" class="headerlink" title="handler相关"></a>handler相关</h2><ol>
<li>消息是通过 MessageQueen 中的 enqueueMessage()方法加入消息队列中的，并 且它在放入中就进行好排序，链表头的延迟时间小，尾部延迟时间最大</li>
<li>Looper.loop()通过 MessageQueue 中的 next()去取消息</li>
<li>next()中如果当前链表头部消息是延迟消息，则根据延迟时间进行消息队列会 阻塞，不返回给 Looper message，直到时间到了，返回给 message</li>
<li>如果在阻塞中有新的消息插入到链表头部则唤醒线程</li>
<li>Looper 将新消息交给回调给 handler 中的 handleMessage 后，继续调用MessageQueen 的 next()方法，如果刚刚的延迟消息还是时间未到，则计算时间 继续阻塞</li>
</ol>
<h5 id="UI的刷新消息为什么不会被其他消息阻塞"><a href="#UI的刷新消息为什么不会被其他消息阻塞" class="headerlink" title="UI的刷新消息为什么不会被其他消息阻塞:"></a>UI的刷新消息为什么不会被其他消息阻塞:</h5><p>在ViewRootImpl中scheduleTraversals里面先调用postSyncBarrier发送同步消息(message中没有target)，然后向Choreographer注册同步回调监听接口，收到同步回调后向handler发送异步消息。在messagequeue中next取消息时，一旦发现没有target的消息，则优先执行异步消息。</p>
<p>设置了屏障消息，此时只会处理异步消息，处理完异步消息后就会堵塞。如果想要恢复同步消息，需要调用 removeSyncBarrier()移除。</p>
<p>子线程中Toast和Dialog的show发生crash原因：Toast和dialog里面有使用到new Handler()，如果子线程没有Looper.prepare();则会导致crash。</p>
<h2 id="Service保活"><a href="#Service保活" class="headerlink" title="Service保活"></a>Service保活</h2><p>Android 进程不死从 3 个层面入手：</p>
<p>A.提供进程优先级，降低进程被杀死的概率 </p>
<p>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动 1 个像素的 Activity，在用 户解锁时将 Activity 销毁掉。</p>
<p>方法二：启动前台 service。</p>
<p>方法三：提升 service 优先级：</p>
<p>在 AndroidManifest.xml 文件中对于 intent-filter 可以通过 android:priority = “1000”这个属性设置最高优先级，1000 是最高值，如果数字越小则优先级越低， 同时适用于广播。 </p>
<p>B. 在进程被杀死后，进行拉活 </p>
<p>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等 </p>
<p>方法二：双进程相互唤起。</p>
<p> 方法三：依靠系统唤起。 </p>
<p>方法四：onDestroy 方法里重启 service：service + broadcast 方式，就是当 service 走 ondestory 的时候，发送一个自定义的广播，当收到广播的时候，重新启动 service；</p>
<p>C. 依靠第三方</p>
<p>根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推 送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。</p>
<h3 id="保活方案"><a href="#保活方案" class="headerlink" title="保活方案"></a>保活方案</h3><p>1、AIDL 方式单进程、双进程方式保活 Service。（基于 onStartCommand() return START_STICKY）<br>START_STICKY 在运行 onStartCommand 后 service 进程被 kill 后，那将保留在 开始状态，但是不保留那些传入的 intent。不久后 service 就会再次尝试重新创 建，因为保留在开始状态，在创建 service 后将保证调用 onstartCommand。如 果没有传递任何开始命令给 service，那将获取到 null 的 intent。<br>除了华为此方案无效以及未更改底层的厂商不起作用外（START_STICKY 字段就 可以保持 Service 不被杀）。此方案可以与其他方案混合使用</p>
<p>2、降低 oom_adj 的值（提升 service 进程优先级）：<br>Android 中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进 行进程的回收。Android 将进程分为 5 个等级,它们按优先级顺序由高到低依次是:<br>1.前台进程 (Foreground process)<br>2.可见进程 (Visible process)<br>3.服务进程 (Service process)<br>4.后台进程 (Background process)<br>5.空进程 (Empty process)</p>
<p>当 service 运行在低内存的环境时，将会 kill 掉一些存在的进程。因此进程的优 先级将会很重要，可以使用 startForeground 将 service 放到前台状态。这样在 低内存时被 kill 的几率会低一些。</p>
<p>常驻通知栏（可通过启动另外一个服务关闭 Notification，不对 oom_adj 值有影响）。<br>使用”1 像素“的 Activity 覆盖在 getWindow()的 view 上。此方案无效果<br>循环播放无声音频（黑科技，7.0 下杀不掉）。<br>成功对华为手机保活。小米 8 下也成功突破 20 分钟<br>3、监听锁屏广播：使 Activity 始终保持前台。<br>4、使用自定义锁屏界面：覆盖了系统锁屏界面。<br>5、通过 android:process 属性来为 Service 创建一个进程。<br>6、跳转到系统白名单界面让用户自己添加 app 进入白名单</p>
<p>复活方案:<br>1、onDestroy 方法里重启 service<br>service + broadcast 方式，就是当 service 走 onDestory 的时候，发送一个自定 义的广播，当收到广播的时候，重新启动 service。</p>
<p>2、JobScheduler：原理类似定时器，5.0,5.1,6.0 作用很大，7.0 时候有一定影响 （可以在电源管理中给 APP 授权）。只对 5.0，5.1、6.0 起作用。</p>
<p>3、推送互相唤醒复活：极光、友盟、以及各大厂商的推送。</p>
<p>4、同派系 APP 广播互相唤醒：比如今日头条系、阿里系。</p>
<p>此外还可以监听系统广播判断 Service 状态，通过系统的一些广播，比如：手机 重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的 Service 是 否还存活。<br>结论：高版本情况下可以使用弹出通知栏、双进程、无声音乐提高后台服务的 保活概率。</p>
<h2 id="ListView-amp-RecyclerView"><a href="#ListView-amp-RecyclerView" class="headerlink" title="ListView &amp; RecyclerView"></a>ListView &amp; RecyclerView</h2><p>ListView 的基础使用：<br>1.继承重写 BaseAdapter 类<br>2.自定义 ViewHolder 和 convertView 一起完成复用优化工作</p>
<p>RecyclerView 基础使用关键点同样有两点：<br>1.继承重写 RecyclerView.Adapter 和 RecyclerView.ViewHolder<br>2.设置布局管理器，控制布局效果</p>
<p>缓存：<br>RecyclerView比ListView多两级缓存，支持多个离ItemView缓存，支持开发者自定义缓存处理逻辑，支持所有RecyclerView共用同一个RecyclerViewPool(缓存池)。<br>具体来说：<br>ListView(两级缓存)：<br>RecyclerView(四级缓存)：</p>
<p>列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。</p>
<p>问题：<br>1.RecyclerView 与 ListView 缓存机制的不同？<br>2.想改变 listview 的高度，怎么做？<br>3.listview 跟 recyclerview 上拉加载的时候分别应该如何处理？<br>4.如何自己实现 RecyclerView 的侧滑删除？<br>5.RecyclerView 的 ItemTouchHelper 的实现原理</p>
<h2 id="热修复与插件化"><a href="#热修复与插件化" class="headerlink" title="热修复与插件化"></a>热修复与插件化</h2><p>热修复流程：</p>
<p>资源和代码的热修复；资源热修复：新建AssetManager，使用addAssetPath指向新路径，然后替换AssetManager 类型的 mAssets 字段的引用全部替换为新创建的 AssetManager。代码热修复分为dex和so，dex修复分三种 1类加载方案（QQ 空间的超级补丁和微信Tinker）2底层替换方案，ArtMethod变动（AndFix、Dexposed、阿里百川、Sophix）3 Instant Run 借助ASM变更字节码（Robust 和 Aceso）。so库的话重新加载即可。</p>
<p>插件化：</p>
<p>主流的插件化方案有滴滴任玉刚的 VirtualApk、360 的 DroidPlugin、 RePlugin、Wequick 的 Small 框架，Alibaba 的 Atlas。</p>
<p>四大组件的插件：Activity 插件化：1.反射：对性能有影响，主流的插件化框架没有采用此方式。2.接口：dynamic-load-apk 采用。3.Hook：主流。Hook 实现方式有两种：Hook IActivityManager（ActivityManager中的IActivityManagerSingleton修改，ActivityThread 的 H 初恢复） 和 Hook Instrumentation（Instrumentation的execStartActivity修改，performLaunchActivity出恢复）。流程：1、占坑、通过校验：2.还原插件 Activity 3、插件 Activity 的生命周期：<br>Service：通过代理Service的方式去分发，VirtualAPK使用了两个代理Service，即LocalService和RemoteService。<br>BroadcastReceiver：将静态广播转为动态广播。<br>ContentProvider：通过一个代理Provider进行操作的分发。</p>
<p>资源插件化：<br>资源的插件化和热修复的资源修复都借助了 AssetManager。<br>资源的插件化方案主要有两种：<br>1.合并资源方案，将插件的资源全部添加到宿主的 Resources 中，这种 方案插件可以访问宿主的资源。<br>2.构建插件资源方案，每个插件都构造出独立的 Resources，这种方案 插件不可以访问宿主资源。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Summer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://skyskiper.github.io/2021/%E5%9B%9E%E7%AD%94%E6%80%9D%E8%B7%AF/">https://skyskiper.github.io/2021/%E5%9B%9E%E7%AD%94%E6%80%9D%E8%B7%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://skyskiper.github.io">阿七笔记</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84/"><span>算法小抄</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Summer</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>