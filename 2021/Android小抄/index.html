<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android小抄"><meta name="keywords" content=""><meta name="author" content="Summer"><meta name="copyright" content="Summer"><title>Android小抄 | 阿七笔记</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.1.1'
} </script><meta name="generator" content="Hexo 5.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">1. Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E7%BD%AE%E4%B8%BA-null%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">强引用置为 null，会不会被回收？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Android"><span class="toc-number">2.</span> <span class="toc-text">2. Android</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LaunchMode"><span class="toc-number">2.1.</span> <span class="toc-text">LaunchMode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#activty-%E5%92%8C-Fragmengt-%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">activty 和 Fragmengt 之间怎么通信？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Traceview"><span class="toc-number">2.3.1.</span> <span class="toc-text">Traceview</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ANR%EF%BC%9F-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AE%83%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">什么是 ANR？ 如何避免它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#android-%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">android 中进程的优先级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AsyncTask%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.6.</span> <span class="toc-text">AsyncTask与线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serializable%E4%B8%8EParcelable%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">Serializable与Parcelable？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap-%E4%BD%BF%E7%94%A8%E6%97%B6%E5%80%99%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="toc-number">2.8.</span> <span class="toc-text">Bitmap 使用时候注意什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="toc-number">2.9.</span> <span class="toc-text">Bitmap 占用内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E4%BC%A0%E8%BE%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E6%9C%89%E9%99%90%E5%88%B6%EF%BC%8C%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">广播传输的数据是否有限制，是多少，为什么要限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVP%E3%80%81MVVM%E3%80%81MVC"><span class="toc-number">2.11.</span> <span class="toc-text">MVP、MVVM、MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC"><span class="toc-number">2.11.1.</span> <span class="toc-text">MVC:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVP"><span class="toc-number">2.11.2.</span> <span class="toc-text">MVP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVM"><span class="toc-number">2.11.3.</span> <span class="toc-text">MVVM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E4%BA%86%E8%A7%A3%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">是否了解硬件加速？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context"><span class="toc-number">2.13.</span> <span class="toc-text">Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.14.</span> <span class="toc-text">Handler源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C%E6%B6%88%E6%81%AF"><span class="toc-number">2.14.0.1.</span> <span class="toc-text">屏障消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.15.</span> <span class="toc-text">Android系统的启动过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.</span> <span class="toc-text">3. 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%9B%B4%E6%96%B0"><span class="toc-number">3.1.</span> <span class="toc-text">应用更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4. 算法</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Summer</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">82</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">阿七笔记</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/menu">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android小抄</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-01</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><h3 id="强引用置为-null，会不会被回收？"><a href="#强引用置为-null，会不会被回收？" class="headerlink" title="强引用置为 null，会不会被回收？"></a>强引用置为 null，会不会被回收？</h3><p>不会立即释放对象占用的内存。 如果对象的引用被置为 null，只是断开了当前 线程栈帧中对该对象的引用关系，而 垃圾收集器是运行在后台的线程，只有当 用户线程运行到安全点(safe point)或者安全区域才会扫描对象引用关系，扫描到 对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些 对象是可恢复的（在 finalize 方法中恢复引用 ）。只有确定了对象无法恢复引 用的时候才会清除对象内存。</p>
<h2 id="2-Android"><a href="#2-Android" class="headerlink" title="2. Android"></a>2. Android</h2><h3 id="LaunchMode"><a href="#LaunchMode" class="headerlink" title="LaunchMode"></a>LaunchMode</h3><h3 id="activty-和-Fragmengt-之间怎么通信？"><a href="#activty-和-Fragmengt-之间怎么通信？" class="headerlink" title="activty 和 Fragmengt 之间怎么通信？"></a>activty 和 Fragmengt 之间怎么通信？</h3><p>（一）Handler </p>
<p>（二）广播 </p>
<p>（三）事件总线：EventBus、RxBus、Otto </p>
<p>（四）接口回调 </p>
<p>（五）Bundle 和 setArguments(bundle)</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>1.资源对象没关闭造成的内存泄漏，Cursor，File 文件、Bitmap等在不适用时没有释放</p>
<p>2.注册没取消造成的内存泄漏</p>
<p>3.使用关于 application 的 context 来替代和 activity 相关的 context</p>
<p>查找内存泄漏：</p>
<p>1、使用 AndroidProfiler 的 MEMORY 工具：</p>
<p>运行程序，对每一个页面进行内存分析检查。首先，反复打开关闭页面 5 次，然 后收到 GC（点击 Profile MEMORY 左上角的垃圾桶图标），如果此时 total 内存 还没有恢复到之前的数值，则可能发生了内存泄露。此时，再点击 Profile MEMORY 左上角的垃圾桶图标旁的 heap dump 按钮查看当前的内存堆栈情况， 选择按包名查找，找到当前测试的 Activity，如果引用了多个实例，则表明发生 了内存泄露。</p>
<p>2、使用 MAT：</p>
<p>1、运行程序，所有功能跑一遍，确保没有改出问题，完全退出程序，手动触发 GC，然后使用 adb shell dumpsys meminfo packagename -d 命令查看退出界面 后 Objects 下的 Views 和 Activities 数目是否为 0，如果不是则通过 Leakcanary 检查可能存在内存泄露的地方，最后通过 MAT 分析，如此反复，改善满意为止。 1、在使用 MAT 之前，先使用 as 的 Profile 中的 Memory 去获取要分析的堆内存 快照文件.hprof，如果要测试某个页面是否产生内存泄漏，可以先 dump 出没进 入该页面的内存快照文件.hprof，然后，通常执行 5 次进入/退出该页面，然后再 dump 出此刻的内存快照文件.hprof，最后，将两者比较，如果内存相除明显， 则可能发生内存泄露。（注意:MAT 需要标准的.hprof 文件，因此在 as 的 Profiler 中 GC 后 dump 出的内存快照文件.hprof 必须手动使用 android sdk platform-tools 下的 hprof-conv 程序进行转换才能被 MAT 打开）</p>
<p>2、然后，使用 MAT 打开前面保存的 2 份.hprof 文件，打开 Overview 界面，在 Overview 界面下面有 4 中 action，其中最常用的就是 Histogram 和 Dominator Tree。</p>
<p>Dominator Tree：支配树，按对象大小降序列出对象和其所引用的对象，注重引 用关系分析。选择 Group by package，找到当前要检测的类（或者使用顶部的 Regex 直接搜索），查看它的 Object 数目是否正确，如果多了，则判断发生了 内存泄露。然后，右击该类，选择 Merge Shortest Paths to GC Root 中的 exclude all phantom/weak/soft etc.references 选项来查看该类的 GC 强引用链。最后， 通过引用链即可看到最终强引用该类的对象。 Histogram：直方图注重量的分析。使用方式与 Dominator Tree 类似。</p>
<p>3、对比 hprof 文件，检测出复杂情况下的内存泄露：</p>
<p>通用对比方式：在 Navigation History 下面选择想要对比的 dominator_tree/histogram，右击选择 Add to Compare Basket，然后在 Compare Basket 一栏中点击红色感叹号（Compare the results）生成对比表格（Compared Tables），在顶部 Regex 输入要检测的类，查看引用关系或对象数量去进行分析 即可。 针对于 Historam 的快速对比方式：直接选择 Histogram 上方的 Compare to another Heap Dump 选择要比较的 hprof 文件的 Historam 即可。</p>
<h4 id="Traceview"><a href="#Traceview" class="headerlink" title="Traceview"></a>Traceview</h4><p>Traceview 是 Android 平台特有的数据采集和分析工具，它主要用于分析 Android 中应用程序的 hotspot（瓶颈）。Traceview 本身只是一个数据分析工 具，而数据的采集则需要使用 Android SDK 中的 Debug 类或者利用 DDMS 工 具。二者的用法如下：开发者在一些关键代码段开始前调用 Android SDK 中 Debug 类的 startMethodTracing 函数，并在关键代码段结束前调用 stopMethodTracing 函数。这两个函数运行过程中将采集运行时间内该应用所 有线程（注意，只能是 Java 线程） 的函数执行情况， 并将采集数据保存到 /mnt/sdcard/下的一个文件中。 开发者然后需要利用 SDK 中的 Traceview 工 具来分析这些数据。</p>
<h3 id="什么是-ANR？-如何避免它？"><a href="#什么是-ANR？-如何避免它？" class="headerlink" title="什么是 ANR？ 如何避免它？"></a>什么是 ANR？ 如何避免它？</h3><p>在 Android 上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户 显示一个对话框，这个对话框称作应 用程序无响应（ANR：Application NotResponding）对话框。 用户可以选择让程序继续运行，但是，他们在使用 你的 应用程序时，并不希望每次都要处理这个对话框。因此 ，在程序里对响应 性能的设计很重要这样，这样系统就不会显 示 ANR 给用户。</p>
<p>不同的组件发生 ANR 的时间不一样，Activity 是 5 秒，BroadCastReceiver 是 10 秒，Service 是 20 秒、contentProvider(onCreate)为10秒（均为前台）。</p>
<p>如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt 即可，最新的 ANR 信息在最开始部分。</p>
<ul>
<li>主线程被 IO 操作（从 4.0 之后网络 IO 不允许在主线程中）阻塞。</li>
<li>主线程中存在耗时的计算</li>
<li>主线程中错误的操作，比如 Thread.wait 或者 Thread.sleep 等 Android 系 统会监控程序的响应状况，一旦出现上面两种情况，则弹出 ANR 对话框</li>
<li>应用在 5 秒内未响应用户的输入事件（如按键或者触摸）</li>
<li>BroadcastReceiver 未在 10 秒内完成相关的处理</li>
<li>Service 在特定的时间内无法处理完成 20 秒</li>
</ul>
<h3 id="android-中进程的优先级？"><a href="#android-中进程的优先级？" class="headerlink" title="android 中进程的优先级？"></a>android 中进程的优先级？</h3><p>前台进程：即与用户正在交互的 Activity 或者 Activity 用到的 Service 等，如果系统内存不足 时前台进程是最晚被杀死的</p>
<p>可见进程：可以是处于暂停状态(onPause)的 Activity 或者绑定在其上的 Service，即被用户 可见，但由于失了焦点而不能与用户交互</p>
<p>服务进程：其中运行着使用 startService 方法启动的 Service，虽然不被用户可见，但是却是 用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面下载的文件 等；当系统要空间运行，前两者进程才会被终止</p>
<p>后台进程：其中运行着执行 onStop 方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的 QQ，这时的进程系统一旦没了有内存就首先被杀死</p>
<p>空进程：不包含任何应用程序的进程，这样的进程系统是一般不会让他存在的</p>
<h3 id="AsyncTask与线程池"><a href="#AsyncTask与线程池" class="headerlink" title="AsyncTask与线程池"></a>AsyncTask与线程池</h3><p>核心参数:<br>corePoolSize:核心线程数<br>maximumPoolSize:最大线程数<br>keepAliveTime:非核心线程的闲置时间限制，超过则回收该非核心线程<br>workQueue:BlockingQueue类型，阻塞队列<br>threadFactory：线程的工厂类<br>handler：RejectedExecutionHandler线程池的饱和策略，默认策略是抛出运行时exception</p>
<p>在execute提交时：<br>1.如果线程数小于核心线程，则新建核心线程去执行任务Runable<br>2.将任务Runable加入workQueue中，然后检查是否可以新建线程<br>3.如果队列无法加入Runnable，检查是否可以新建线程(防止线程有回收的),如果不能，执行handler的拒绝策略</p>
<p>thread执行的对象是Worker对象，在worker中run方法会从queue中不停的取任务执行。</p>
<p>Runnable、Callable、Future是三个基础interface，分别是不带结果的运行，带结果的运行，对异步任务整个生命周期的表示。</p>
<p>FutureTask是class，继承了Runnable与Future，内部持有callable。一般外部传入callable。</p>
<p>java内置5中线程池：在Executors中提供静态方法<br>newCachedThreadPool：核心线程0，最大Integer.MAX_VALUE, keepAliveTime为60秒,SynchronousQueue同步阻塞队列。只有非核心线程,最大线程数非常大,所有线程都活动时会为新任务创建新线程, 否则会利用空闲线程(60s 空闲时间,过了就会被回收,所以线程池中有 0 个线程的 可能)处理任务。优点:任何任务都会被立即执行(任务队列 SynchronousQuue 相当于一个空集合); 比较适合执行大量的耗时较少的任务.<br>newSingleThreadExecutor：核心1，最大1，keepAliveTime为0，LinkedBlockingQueue。只有一个核心线程,确保所有的任务都在同一线程中按序完成.因此不需要处理线 程同步的问题.<br>newFixedThreadPool：核心n,最大n，keepAliveTime为0，LinkedBlockingQueue。只有核心线程,并且数量固定的,也不会被回收,所有线程都活动时,因为队列没有 限制大小,新任务会等待执行。优点:更快的响应外界请求。<br>newScheduledThreadPool：线程池为ScheduledThreadPoolExecutor，核心n，最大Integer.MAX_VALUE，keepAliveTime为10秒,DelayedWorkQueue（利用数组模拟堆实现）。主要处理定时任务，和Timer功能类似。核心线程数固定,非核心线程（闲着没活干会被立即回收数）没有限制.优点:执行定时任务以及有固定周期的重复任务<br>newWorkStealingPool：ForkJoinPool，使用一个无限队列来保存需要执行的任务，可以传入线程的数量，不传入，则默认使用当前计算机中可用的cpu数量，使用分治法来解决问题，使用fork()和join()来进行调用.</p>
<p>可以引入rxjava、kotlin线程池框架的比较？</p>
<h3 id="Serializable与Parcelable？"><a href="#Serializable与Parcelable？" class="headerlink" title="Serializable与Parcelable？"></a>Serializable与Parcelable？</h3><p>Serializable（Java 自带）：序列化的意思，表示将一个对象转换成存储或可传输的状态。序 列化后的对象可以在网络上进传输，也可以存储到本地。</p>
<p>Parcelable（android 专用）：是将一个完整的对象进行分解，而 分解后的每一部分都是 Intent 所支持的数据类型，这也就实现传递对象的功能 了。</p>
<p>编码上：Serializable代码量少，写起来方便，Parcelable代码多一些；效率上：Parcelable的速度比高十倍以上。</p>
<p>Serializable方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p>
<h3 id="Bitmap-使用时候注意什么"><a href="#Bitmap-使用时候注意什么" class="headerlink" title="Bitmap 使用时候注意什么"></a>Bitmap 使用时候注意什么</h3><p>1、要选择合适的图片规格（bitmap 类型）：</p>
<p>ALPHA_8每个像素占用 1byte 内存 </p>
<p>ARGB_4444 每个像素占用 2byte 内存 </p>
<p>ARGB_8888 每个像素占用 4byte 内存（默认） </p>
<p>RGB_565 每个像素占用 2byte 内存</p>
<p>2、降低采样率。BitmapFactory.Options 参数 inSampleSize 的使用，先把 options.inJustDecodeBounds 设为 true，只是去读取图片的大小，在拿到图片的 大小之后和要显示的大小做比较通过 calculateInSampleSize()函数计算 inSampleSize 的具体值，得到值之后。options.inJustDecodeBounds 设为 false 读图片资源。</p>
<p>3、复用内存。即，通过软引用(内存不够的时候才会回收掉)，复用内存块，不 需要再重新给这个 bitmap 申请一块新的内存，避免了一次内存的分配和回收， 从而改善了运行效率。</p>
<p>4、使用 recycle()方法及时回收内存。</p>
<p>5、压缩图片。</p>
<p>在 Android 中，Bitmap 的存储分为两部分，一部分是 Bitmap 的数据，一部分是 Bitmap 的引用。 在 Android2.3 时代，Bitmap 的引用是放在堆中的，而 Bitmap 的数据部分是放在栈中的，需要用户调用 recycle 方法手动进行内存回收，而在 Android2.3 之后，整个 Bitmap，包括数据和引用，都放在了堆中，这样，整个 Bitmap 的回收就全部交给 GC 了，这个 recycle 方法就再也不需要使用了。</p>
<p>bitmap recycler 引发的问题：当图像的旋转角度小余两个像素点之间的夹角时， 图像即使旋转也无法显示，因此，系统完全可以认为图像没有发生变化。这时系 统就直接引用同一个对象来进行操作，避免内存浪费。</p>
<h3 id="Bitmap-占用内存"><a href="#Bitmap-占用内存" class="headerlink" title="Bitmap 占用内存"></a>Bitmap 占用内存</h3><p>Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存</p>
<p>注：这里 inDensity 表示目标图片的 dpi（放在哪个资源文件夹下）， inTargetDensity 表示目标屏幕的 dpi，所以你可以发现 inDensity 和 inTargetDensity 会对 Bitmap 的宽高进行拉伸，进而改变 Bitmap 占用内存的大 小。 在 Bitmap 里有两个获取内存占用大小的方法。</p>
<p>getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。 getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存 大小，代替了 getByteCount() 方法。 在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片 时，那么 getByteCount() 表示新解码图片占用内存的大 小， getAllocationByteCount() 表示被复用 Bitmap 真实占用的内存大小（即 mBuffer 的长度）。</p>
<p>为了保证在加载 Bitmap 的时候不产生内存溢出，可以使用 BitmapFactory 进行 图片压缩，主要有以下几个参数： BitmapFactory.Options.inPreferredConfig：将 ARGB_8888 改为 RGB_565，改变 编码方式，节约内存。 BitmapFactory.Options.inSampleSize：缩放比例，可以 参考 Luban 那个库，根据图片宽高计算出合适的缩放比例。 BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。</p>
<h3 id="广播传输的数据是否有限制，是多少，为什么要限制？"><a href="#广播传输的数据是否有限制，是多少，为什么要限制？" class="headerlink" title="广播传输的数据是否有限制，是多少，为什么要限制？"></a>广播传输的数据是否有限制，是多少，为什么要限制？</h3><p>Intent 在传递数据时是有大小限制的，大约限制在 1MB 之内，你用 Intent 传递 数据，实际上走的是跨进程通信（IPC），跨进程通信需要把数据从内核 copy</p>
<p>到进程中，每一个进程有一个接收内核数据的缓冲区，默认是 1M；如果一次传 递的数据超过限制，就会出现异常。</p>
<p>不同厂商表现不一样有可能是厂商修改了此限制的大小，也可能同样的对象在不 同的机器上大小不一样。</p>
<p>传递大数据，不应该用 Intent；考虑使用 ContentProvider 或者直接匿名共享内 存。简单情况下可以考虑分段传输。</p>
<h3 id="MVP、MVVM、MVC"><a href="#MVP、MVVM、MVC" class="headerlink" title="MVP、MVVM、MVC"></a>MVP、MVVM、MVC</h3><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC:"></a>MVC:</h4><p>视图层(View) 对应于 xml 布局文件和 java 代码动态 view 部分；<br>控制层(Controller) MVC 中 Android 的控制层是由 Activity 来承担的， Activity 本来主要是作为初始化页面，展示数据的操作，但是因为 XML 视 图功能太弱，所以 Activity 既要负责视图的显示又要加入控制逻辑，承担 的功能过多。<br>模型层(Model) 针对业务模型，建立数据结构和相关的类，它主要负责网 络请求，数据库处理，I/O 的操作。</p>
<p>总结：具有一定的分层，model 彻底解耦，controller 和 view 并没有解耦 层与层之间 的交互尽量使用回调或者去使用消息机制去完成，尽量避免直接持有 controller 和 view 在 android 中无法做到彻底分离，但在代码逻辑层面一定要分清 业务逻 辑被放置在 model 层，能够更好的复用和修改增加业务。</p>
<h4 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h4><p>通过引入接口 BaseView，让相应的视图组件如 Activity，Fragment 去实现 BaseView，实现了视图层的独立，通过中间层 Preseter 实现了 Model 和 View 的完全解耦。MVP 彻底解决了 MVC 中 View 和 Controller 傻傻分不清楚的问题， 但是随着业务逻辑的增加，一个页面可能会非常复杂，UI 的改变是非常多，会 有非常多的 case，这样就会造成 View 的接口会很庞大。</p>
<h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>MVP 中我们说过随着业务逻辑的增加，UI 的改变多的情况下，会有非常多的跟 UI 相关的 case，这样就会造成 View 的接口会很庞大。而 MVVM 就解决了这个 问题，通过双向绑定的机制，实现数据和 UI 内容，只要想改其中一方，另一方 都能够及时更新的一种设计理念，这样就省去了很多在 View 层中写很多 case 的情况，只需要改变数据就行。</p>
<p>MVVM 与 DataBinding 的关系？</p>
<p>MVVM 是一种思想，DataBinding 是谷歌推出的方便实现 MVVM 的工具。</p>
<p>看起来 MVVM 很好的解决了 MVC 和 MVP 的不足，但是由于数据和视图的双向 绑定，导致出现问题时不太好定位来源，有可能数据问题导致，也有可能业务逻 辑中对视图属性的修改导致。如果项目中打算用 MVVM 的话可以考虑使用官方 的架构组件 ViewModel、LiveData、DataBinding 去实现 MVVM。</p>
<p>三者如何选择？</p>
<ul>
<li>如果项目简单，没什么复杂性，未来改动也不大的话，那就不要用设计模 式或者架构方法，只需要将每个模块封装好，方便调用即可，不要为了使 用设计模式或架构方法而使用。</li>
<li>对于偏向展示型的 app，绝大多数业务逻辑都在后端，app 主要功能就是 展示数据，交互等，建议使用 mvvm。 </li>
<li>对于工具类或者需要写很多业务逻辑 app，使用 mvp 或者 mvvm 都可。</li>
</ul>
<h3 id="是否了解硬件加速？"><a href="#是否了解硬件加速？" class="headerlink" title="是否了解硬件加速？"></a>是否了解硬件加速？</h3><p>硬件加速就是运用 GPU 优秀的运算能力来加快渲染的速度，而通常的基于软件 的绘制渲染模式是完全利用 CPU 来完成渲染。</p>
<p>1.硬件加速是从 API 11 引入，API 14 之后才默认开启。对于标准的绘制操作和 控件都是支持的，但是对于自定义 View 的时候或者一些特殊的绘制函数就需要 考虑是否需要关闭硬件加速。</p>
<p>2.我们面对不支持硬件加速的情况，就需要限制硬件加速，这个兼容性的问题是 因为硬件加速是把 View 的绘制函数转化为使用 OpenGL 的函数来进完成实际的 绘制的，那么必然会存在 OpenGL 中不支持原始回执函数的情况，对于这些绘制 函数，就会失效。</p>
<p>3.硬件加速的消耗问题，因为是使用 OpenGL，需要把系统中 OpenGL 加载到内 存中，OpenGL API 调用就会占用 8MB，而实际上会占用更多内存，并且使用了 硬件必然增加耗电量了。</p>
<p>4.硬件加速的优势还有 display list 的设计，使用这个我们不需要每次重绘都执行 大量的代码，基于软件的绘制模式会重绘脏区域内的所有控件，而 display 只会 更新列表，然后绘制列表内的控件。</p>
<ol>
<li>CPU 更擅长复杂逻辑控制，而 GPU 得益于大量 ALU 和并行结构设计，更 擅长数学运算。</li>
</ol>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>1、Activity 和 Service 以及 Application 的 Context 是不一样的,Activity 继 承自 ContextThemeWraper.其他的继承自 ContextWrapper。</p>
<p>2、每一个 Activity 和 Service 以及 Application 的 Context 是一个新的 ContextImpl 对象。</p>
<p>3、getApplication()用来获取 Application 实例的，但是这个方法只有在 Activity 和 Service 中才能调用的到。那也许在绝大多数情况下我们都是在 Activity 或者 Servic 中使用 Application 的，但是如果在一些其它的场景， 比如 BroadcastReceiver 中也想获得 Application 的实例，这时就可以借助 getApplicationContext()方法，getApplicationContext()比 getApplication() 方法的作用域会更广一些，任何一个 Context 的实例，只要调用 getApplicationContext()方法都可以拿到我们的 Application 对象。</p>
<p>4、创建对话框时不可以用 Application 的 context，只能用 Activity 的 context。</p>
<p>5、Context 的数量等于 Activity 的个数 + Service 的个数 +1，这个 1 为 Application。</p>
<h3 id="Handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析</h3><ol>
<li>消息是通过 MessageQueen 中的 enqueueMessage()方法加入消息队列中的，并 且它在放入中就进行好排序，链表头的延迟时间小，尾部延迟时间最大</li>
<li>Looper.loop()通过 MessageQueue 中的 next()去取消息</li>
<li>next()中如果当前链表头部消息是延迟消息，则根据延迟时间进行消息队列会 阻塞，不返回给 Looper message，直到时间到了，返回给 message</li>
<li>如果在阻塞中有新的消息插入到链表头部则唤醒线程</li>
<li>Looper 将新消息交给回调给 handler 中的 handleMessage 后，继续调用MessageQueen 的 next()方法，如果刚刚的延迟消息还是时间未到，则计算时间 继续阻塞</li>
</ol>
<h5 id="屏障消息"><a href="#屏障消息" class="headerlink" title="屏障消息"></a>屏障消息</h5><p>在ViewRootImpl中scheduleTraversals里面先调用postSyncBarrier发送同步消息(message中没有target)，然后向Choreographer注册同步回调监听接口，收到同步回调后向handler发送异步消息。在messagequeue中next取消息时，一旦发现没有target的消息，则优先执行异步消息。</p>
<p>设置了屏障消息，此时只会处理异步消息，处理完异步消息后就会堵塞。如果想要恢复同步消息，需要调用 removeSyncBarrier()移除。</p>
<p>子线程中Toast和Dialog的show发生crash原因：Toast和dialog里面有使用到new Handler()，如果子线程没有Looper.prepare();则会导致crash。</p>
<h3 id="Android系统的启动过程"><a href="#Android系统的启动过程" class="headerlink" title="Android系统的启动过程"></a>Android系统的启动过程</h3><ol>
<li>linux内核启动后会启动第一个用户空间进程Init(pId=1),Init进程会解析和分析init.rc文件，rc文件中配置了各种程序和服务的启动项</li>
<li>在init.rc中也配置了Zygote进程的启动项，Zygote进程的执行文件/system/bin/app_process，实现代码为app_main.cpp，在main方法中启动了AppRuntime虚拟机，同时指定虚拟机执行com.android.internal.os.ZygoteInit，进入java世界</li>
<li>ZygoteInit的main方法中registerZygoteSocket(注册socket长连接)、preloadClasses、preloadResources、startSystemServer（开启system_server进程）、runSelectLoop(Zygote执行死循环监听socket)</li>
<li>startSystemServer中fork出system_server进程后执行handleSystemServerProcess初始化相关信息，其中层层调用到app_main.cpp中的onZygoteInit方法来初始化binder线程池。其中的RuntimeInit.zygoteInit故意抛出异常，ZygoteInit的main方法中捕获该异常，然后使用反射的方式执行异常中指定的class和method（system_server进程是SystemServer.main,该参数在startSystemServer方法中由代码指定；普通应用进程是ActivityThread.main，该参数从socket中读取）。SystemServer.main中启动system_server进程中的各种系统服务。</li>
</ol>
<h2 id="3-项目"><a href="#3-项目" class="headerlink" title="3. 项目"></a>3. 项目</h2><h3 id="应用更新"><a href="#应用更新" class="headerlink" title="应用更新"></a>应用更新</h3><p>灰度，强制更新，分区域更新</p>
<p>1、通过接口获取线上版本号，versionCode 2、比较线上的 versionCode 和本地 的 versionCode，弹出更新窗口 3、下载 APK 文件（文件下载） 4、安装 APK</p>
<p>灰度： (1)找单一渠道投放特别版本。 (2)做升级平台的改造，允许针对部分用 户推送升级通知甚至版本强制升级。 (3)开放单独的下载入口。 (4)是两个版本 的代码都打到 app 包里，然后在 app 端植入测试框架，用来控制显示哪个版本。 测试框架负责与服务器端 api 通信，由服务器端控制 app 上 A/B 版本的分布， 可以实现指定的一组用户看到 A 版本，其它用户看到 B 版本。服务端会有相应 的报表来显示 A/B 版本的数量和效果对比。最后可以由服务端的后台来控制，全 部用户在线切换到 A 或者 B 版本~ 无论哪种方法都需要做好版本管理工作，分配特别的版本号以示区别。 当然， 既然是做灰度，数据监控（常规数据、新特性数据、主要业务数据）还是要做到 位，该打的数据桩要打。 还有，灰度版最好有收回的能力，一般就是强制升级 下一个正式版。 强制更新:一般的处理就是进入应用就弹窗通知用户有版本更新，弹窗可以没有 取消按钮并不能取消。这样用户就只能选择更新或者关闭应用了，当然也可以添 加取消按钮，但是如果用户选择取消则直接退出应用。 增量更新：bsdiff：二进制差分工具 bsdiff 是相应的补丁合成工具,根据两个不同 版本的二进制文件，生成补丁文件.patch 文件。通过 bspatch 使旧的 apk 文件与 不定文件合成新的 apk。 注意通过 apk 文件的 md5 值进行区分版本。</p>
<h2 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Summer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://skyskiper.github.io/2021/Android%E5%B0%8F%E6%8A%84/">https://skyskiper.github.io/2021/Android%E5%B0%8F%E6%8A%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://skyskiper.github.io">阿七笔记</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/Android%E7%83%AD%E9%A2%98%E7%AD%94%E6%A1%88/"><span>Android热题答案</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Summer</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>