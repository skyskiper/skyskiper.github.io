<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android小抄"><meta name="keywords" content=""><meta name="author" content="Summer"><meta name="copyright" content="Summer"><title>Android小抄 | 阿七笔记</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.1.1'
} </script><meta name="generator" content="Hexo 5.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">1. Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E7%BD%AE%E4%B8%BA-null%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">强引用置为 null，会不会被回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">软引用和弱引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Android"><span class="toc-number">2.</span> <span class="toc-text">2. Android</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-%E4%B8%AD-ClassLoader"><span class="toc-number">2.1.</span> <span class="toc-text">Android 中 ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LruCache%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">LruCache原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%8ESparseArray"><span class="toc-number">2.3.</span> <span class="toc-text">HashMap与SparseArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LaunchMode"><span class="toc-number">2.4.</span> <span class="toc-text">LaunchMode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-Service-%E4%B8%8D%E8%A2%AB%E6%9D%80%E6%AD%BB%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">如何保证 Service 不被杀死？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerThread%E3%80%81IntentService"><span class="toc-number">2.6.</span> <span class="toc-text">HandlerThread、IntentService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HandlerThread"><span class="toc-number">2.6.1.</span> <span class="toc-text">HandlerThread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntentService"><span class="toc-number">2.6.2.</span> <span class="toc-text">IntentService</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ContentProvider%E3%80%81ContentResolver%E3%80%81ContentObserver-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">ContentProvider、ContentResolver、ContentObserver 之间的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#activty-%E5%92%8C-Fragmengt-%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">activty 和 Fragmengt 之间怎么通信？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">2.9.</span> <span class="toc-text">内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Traceview"><span class="toc-number">2.9.1.</span> <span class="toc-text">Traceview</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ANR%EF%BC%9F-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AE%83%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">什么是 ANR？ 如何避免它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#android-%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">android 中进程的优先级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AsyncTask%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.12.</span> <span class="toc-text">AsyncTask与线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serializable%E4%B8%8EParcelable%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">Serializable与Parcelable？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap-%E4%BD%BF%E7%94%A8%E6%97%B6%E5%80%99%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="toc-number">2.14.</span> <span class="toc-text">Bitmap 使用时候注意什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="toc-number">2.14.1.</span> <span class="toc-text">Bitmap 占用内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%A7%E5%9B%BE%EF%BC%8C%E5%A6%82%E4%B8%80%E5%BC%A0-30M-%E7%9A%84%E5%A4%A7%E5%9B%BE%EF%BC%8C%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2-OOM"><span class="toc-number">2.14.2.</span> <span class="toc-text">Bitmap 如何处理大图，如一张 30M 的大图，如何预防 OOM?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.14.3.</span> <span class="toc-text">Bitmap 对象的理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E4%BC%A0%E8%BE%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E6%9C%89%E9%99%90%E5%88%B6%EF%BC%8C%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">广播传输的数据是否有限制，是多少，为什么要限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVP%E3%80%81MVVM%E3%80%81MVC"><span class="toc-number">2.16.</span> <span class="toc-text">MVP、MVVM、MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC"><span class="toc-number">2.16.1.</span> <span class="toc-text">MVC:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVP"><span class="toc-number">2.16.2.</span> <span class="toc-text">MVP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVM"><span class="toc-number">2.16.3.</span> <span class="toc-text">MVVM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E4%BA%86%E8%A7%A3%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">是否了解硬件加速？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context"><span class="toc-number">2.18.</span> <span class="toc-text">Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%EF%BC%9F%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">View 的事件分发机制？滑动冲突怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">2.20.</span> <span class="toc-text">View 的绘制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE-MeasureSpec-%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%80%91%E5%B8%83%E6%B5%81%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89-ViewGroup%EF%BC%9F"><span class="toc-number">2.20.1.</span> <span class="toc-text">如何根据 MeasureSpec 去实现一个瀑布流的自定义 ViewGroup？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E4%B9%8B-Measure"><span class="toc-number">2.20.2.</span> <span class="toc-text">View 绘制流程之 Measure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E4%B9%8B-Layout"><span class="toc-number">2.20.3.</span> <span class="toc-text">View 的绘制流程之 Layout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E4%B9%8B-Draw"><span class="toc-number">2.20.4.</span> <span class="toc-text">View 的绘制流程之 Draw</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setWillNotDraw-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.20.5.</span> <span class="toc-text">setWillNotDraw 的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.21.</span> <span class="toc-text">Handler源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C%E6%B6%88%E6%81%AF"><span class="toc-number">2.21.0.1.</span> <span class="toc-text">屏障消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binder"><span class="toc-number">2.22.</span> <span class="toc-text">Binder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMS%E8%A7%A3%E6%9E%90"><span class="toc-number">2.23.</span> <span class="toc-text">AMS解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Window-%E5%92%8C-WindowManager"><span class="toc-number">2.24.</span> <span class="toc-text">Window 和 WindowManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.25.</span> <span class="toc-text">Android系统的启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APK%E5%AE%89%E8%A3%85"><span class="toc-number">2.26.</span> <span class="toc-text">APK安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B"><span class="toc-number">2.27.</span> <span class="toc-text">打包流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D"><span class="toc-number">2.28.</span> <span class="toc-text">签名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v1%E7%AD%BE%E5%90%8D"><span class="toc-number">2.28.1.</span> <span class="toc-text">v1签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V2%E7%AD%BE%E5%90%8D%EF%BC%88Android-7-0%EF%BC%89"><span class="toc-number">2.28.2.</span> <span class="toc-text">V2签名（Android 7.0）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V3%E7%AD%BE%E5%90%8D%EF%BC%88Android-9-0%EF%BC%89"><span class="toc-number">2.28.3.</span> <span class="toc-text">V3签名（Android 9.0）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">2.29.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Davilk%E3%80%81ART%E5%8C%BA%E5%88%AB"><span class="toc-number">2.30.</span> <span class="toc-text">Davilk、ART区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART-%E5%92%8C-Davlik-%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.31.</span> <span class="toc-text">ART 和 Davlik 中垃圾回收的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%8D%93%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.32.</span> <span class="toc-text">安卓内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#App-%E6%98%AF%E5%A6%82%E4%BD%95%E6%B2%99%E7%AE%B1%E5%8C%96"><span class="toc-number">2.33.</span> <span class="toc-text">App 是如何沙箱化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.</span> <span class="toc-text">3. 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%9B%B4%E6%96%B0"><span class="toc-number">3.1.</span> <span class="toc-text">应用更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OkHttp-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">OkHttp 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpUrlConnection-%E5%92%8C-okhttp-%E5%85%B3%E7%B3%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">HttpUrlConnection 和 okhttp 关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Volley-%E4%B8%8E-OkHttp-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">Volley 与 OkHttp 的对比：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.2.3.</span> <span class="toc-text">衍生问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Retrofit-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">Retrofit 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rxjava"><span class="toc-number">3.4.</span> <span class="toc-text">Rxjava</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rxjava-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E4%BD%A0%E4%BB%AC%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">Rxjava 的线程池与你们自己实现任务管理框架?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%EF%BC%9AGlide-amp-Fresco"><span class="toc-number">3.5.</span> <span class="toc-text">图片缓存框架：Glide &amp; Fresco</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Glide"><span class="toc-number">3.5.1.</span> <span class="toc-text">Glide</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco"><span class="toc-number">3.5.2.</span> <span class="toc-text">Fresco</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco-%E4%B8%8E-Glide-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">3.5.3.</span> <span class="toc-text">Fresco 与 Glide 的对比：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-ImageLoader-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.5.4.</span> <span class="toc-text">实现一个 ImageLoader 的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-number">3.5.5.</span> <span class="toc-text">EventBus（略）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LeakCanary-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.6.</span> <span class="toc-text">LeakCanary 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockCanary"><span class="toc-number">3.6.</span> <span class="toc-text">BlockCanary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ButterKnife-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.7.</span> <span class="toc-text">ButterKnife 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%92%8C%E6%8F%92%E4%BB%B6%E5%8C%96"><span class="toc-number">3.8.</span> <span class="toc-text">热修复和插件化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E9%9A%BE%E9%A2%98%EF%BC%8C%E6%9C%80%E7%BB%88%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">项目中遇到哪些难题，最终你是如何解决的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4. 算法</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Summer</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">82</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">阿七笔记</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/menu">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android小抄</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-01</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><h3 id="强引用置为-null，会不会被回收？"><a href="#强引用置为-null，会不会被回收？" class="headerlink" title="强引用置为 null，会不会被回收？"></a>强引用置为 null，会不会被回收？</h3><p>不会立即释放对象占用的内存。 如果对象的引用被置为 null，只是断开了当前 线程栈帧中对该对象的引用关系，而 垃圾收集器是运行在后台的线程，只有当 用户线程运行到安全点(safe point)或者安全区域才会扫描对象引用关系，扫描到 对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些 对象是可恢复的（在 finalize 方法中恢复引用 ）。只有确定了对象无法恢复引 用的时候才会清除对象内存。</p>
<h3 id="软引用和弱引用"><a href="#软引用和弱引用" class="headerlink" title="软引用和弱引用"></a>软引用和弱引用</h3><p>1、软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软 / 弱引用。</p>
<p>2、如果只是想避免 OOM 异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p>
<p>3、可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对 象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p>
<h2 id="2-Android"><a href="#2-Android" class="headerlink" title="2. Android"></a>2. Android</h2><h3 id="Android-中-ClassLoader"><a href="#Android-中-ClassLoader" class="headerlink" title="Android 中 ClassLoader"></a>Android 中 ClassLoader</h3><p>BootClassLoader（Java 的 BootStrap ClassLoader）： 用于加载 Android Framework 层 class 文件。<br>PathClassLoader（Java 的 App ClassLoader）： 用于加载已经安装到系 统中的 apk 中的 class 文件。<br>DexClassLoader（Java 的 Custom ClassLoader）： 用于加载指定目录中 的 class 文件。 BaseDexClassLoader： 是 PathClassLoader 和 DexClassLoader 的父类。</p>
<h3 id="LruCache原理"><a href="#LruCache原理" class="headerlink" title="LruCache原理"></a>LruCache原理</h3><p>LRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈 中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超 过限定值，则删除栈底元素（即最近最少使用的元素）。</p>
<p>LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用 put()方法时，就会在结合中添加元素，并调用 trimToSize()判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队 头元素，即近期最少访问的元素。当调用 get()方法访问缓存对象时，就会调用 LinkedHashMap 的 get()方法获得对应集合元素，同时会更新该元素到队尾。</p>
<p>DiskLruCache 与 LruCache 原理相似，只是多了一个 journal 文件来做磁盘文件 的管理。</p>
<p>我们来分析下这个文件的内容： 第一行：libcore.io.DiskLruCache，固定字符串。 第二行：1，DiskLruCache 源 码版本号。 第三行：1，App 的版本号，通过 open()方法传入进去的。 第四行： 1，每个 key 对应几个文件，一般为 1. 第五行：空行 第六行及后续行：缓存操作记录。 第六行及后续行表示缓存操作记录，关于操作记录，我们需要了解以 下三点：</p>
<p>DIRTY 表示一个 entry 正在被写入。写入分两种情况，如果成功会紧接着写入一 行 CLEAN 的记录；如果失败，会增加一行 REMOVE 记录。注意单独只有 DIRTY 状态的记录是非法的。 当手动调用 remove(key)方法的时候也会写入一条 REMOVE 记录。 READ 就是说明有一次读取的记录。 CLEAN 的后面还记录了文 件的长度，注意可能会一个 key 对应多个文件，那么就会有多个数字。</p>
<h3 id="HashMap与SparseArray"><a href="#HashMap与SparseArray" class="headerlink" title="HashMap与SparseArray"></a>HashMap与SparseArray</h3><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源码中可以看到key和value分别是用数组表示。SparseArray在存储和读取数据时候，使用的是二分查找法。</p>
<h3 id="LaunchMode"><a href="#LaunchMode" class="headerlink" title="LaunchMode"></a>LaunchMode</h3><p>standard、singleTop、singleTask、singleInstance</p>
<p>taskAffinity 是 Activity 在 mainfest 中配置的一个属性，暂时可以理解为： taskAffinity为宿主Activity指定了存放的任务栈[不同于App中其他的Activity 的栈]，为 activity 设置 taskAffinity 属性时不能和包名相同，因为 Android 团 队为 taskAffinity 默认设置为包名任务栈。taskAffinity 只有和 SingleTask 启动模式匹配使用时，启动的 Activity 才会运 行在名字和 taskAffinity 相同的任务栈中。</p>
<h3 id="如何保证-Service-不被杀死？"><a href="#如何保证-Service-不被杀死？" class="headerlink" title="如何保证 Service 不被杀死？"></a>如何保证 Service 不被杀死？</h3><p>Android 进程不死从 3 个层面入手：</p>
<p>A.提供进程优先级，降低进程被杀死的概率 </p>
<p>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动 1 个像素的 Activity，在用 户解锁时将 Activity 销毁掉。</p>
<p>方法二：启动前台 service。</p>
<p>方法三：提升 service 优先级：</p>
<p>在 AndroidManifest.xml 文件中对于 intent-filter 可以通过 android:priority = “1000”这个属性设置最高优先级，1000 是最高值，如果数字越小则优先级越低， 同时适用于广播。 </p>
<p>B. 在进程被杀死后，进行拉活 </p>
<p>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等 </p>
<p>方法二：双进程相互唤起。</p>
<p> 方法三：依靠系统唤起。 </p>
<p>方法四：onDestroy 方法里重启 service：service + broadcast 方式，就是当 service 走 ondestory 的时候，发送一个自定义的广播，当收到广播的时候，重新启动 service；</p>
<p>C. 依靠第三方</p>
<p>根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推 送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。</p>
<h3 id="HandlerThread、IntentService"><a href="#HandlerThread、IntentService" class="headerlink" title="HandlerThread、IntentService"></a>HandlerThread、IntentService</h3><h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h4><p>当系统有多个耗时任务需要执行时，每个任务都会开启个新线程去执行耗时任 务，这样会导致系统多次创建和销毁线程，从而影响性能。为了解决这一问题， Google 提出了 HandlerThread，HandlerThread 本质上是一个线程类，它继承了 Thread。HandlerThread 有自己的内部 Looper 对象，可以进行 loopr 循环。通 过获取 HandlerThread 的 looper 对象传递给 Handler 对象，可以在 handleMessage()方法中执行异步任务。创建 HandlerThread 后必须先调用 HandlerThread.start()方法，Thread 会先调用 run 方法，创建 Looper 对象。当 有耗时任务进入队列时，则不需要开启新线程，在原有的线程中执行耗时任务即 可，否则线程阻塞。它在 Android 中的一个具体的使用场景是 IntentService。由 于 HanlderThread 的 run()方法是一个无限循环，因此当明确不需要再使用 HandlerThread 时，可以通过它的 quit 或者 quitSafely 方法来终止线程的执行。</p>
<p>优缺点：<br>1.HandlerThread 优点是异步不会堵塞，减少对性能的消耗。<br>2.HandlerThread 缺点是不能同时继续进行多任务处理，要等待进行处理， 处理效率较低。<br>3.HandlerThread 与线程池不同，HandlerThread 是一个串队列，背后只有 一个线程。</p>
<h4 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h4><p>IntentService 是一种特殊的 Service，它继承了 Service 并且它是一个抽象类，因 此必须创建它的子类才能使用 IntentService。</p>
<p>在实现上，IntentService 封装了 HandlerThread 和 Handler。当 IntentService 被 第一次启动时，它的 onCreate()方法会被调用，onCreat()方法会创建一个 HandlerThread，然后使用它的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最终都会在 HandlerThread 中执行。 生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至 onStartCommand()方法的 Intetnt。 生成一个工作队列来传送 Intent 对象给 onHandleIntent()方法，同一时刻只传送 一个 Intent 对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent) 都被执行完以后会自动停止服务，所以，你不需要自己去调用 stopSelf()方法来 停止。 该服务提供了一个 onBind()方法的默认实现，它返回 null。</p>
<p>提供了一个 onStartCommand()方法的默认实现，它将 Intent 先传送至工作队列， 然后从工作队列中每次取出一个传送至 onHandleIntent()方法，在该方法中对 Intent 做相应的处理。</p>
<p>为什么在 mServiceHandler 的 handleMessage()回调方法中执行完 onHandlerIntent()方法后要使用带 参数的 stopSelf()方法？</p>
<p>因为 stopSel()方法会立即停止服务，而 stopSelf（int startId）会等待所有的消 息都处理完毕后才终止服务，一般来说，stopSelf(int startId)在尝试停止服务之 前会判断最近启动服务的次数是否和 startId 相等，如果相等就立刻停止服务， 不相等则不停止服务。</p>
<h3 id="ContentProvider、ContentResolver、ContentObserver-之间的关系？"><a href="#ContentProvider、ContentResolver、ContentObserver-之间的关系？" class="headerlink" title="ContentProvider、ContentResolver、ContentObserver 之间的关系？"></a>ContentProvider、ContentResolver、ContentObserver 之间的关系？</h3><p>ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、 文件、XML、网络等，ContentProvider 为这些数据的访问提供了统一的接口， 可以用来做进程间数据共享。 </p>
<p>ContentResolver：ContentResolver 可以为不同 URI 操作不同的 ContentProvider 中的数据，外部进程可以通过 ContentResolver 与 ContentProvider 进行交互。</p>
<p>ContentObserver：观察 ContentProvider 中的数据变化，并将变化通知给外界。</p>
<h3 id="activty-和-Fragmengt-之间怎么通信？"><a href="#activty-和-Fragmengt-之间怎么通信？" class="headerlink" title="activty 和 Fragmengt 之间怎么通信？"></a>activty 和 Fragmengt 之间怎么通信？</h3><p>（一）Handler </p>
<p>（二）广播 </p>
<p>（三）事件总线：EventBus、RxBus、Otto </p>
<p>（四）接口回调 </p>
<p>（五）Bundle 和 setArguments(bundle)</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>1.资源对象没关闭造成的内存泄漏，Cursor，File 文件、Bitmap等在不适用时没有释放</p>
<p>2.注册没取消造成的内存泄漏</p>
<p>3.使用关于 application 的 context 来替代和 activity 相关的 context</p>
<p>查找内存泄漏：</p>
<p>1、使用 AndroidProfiler 的 MEMORY 工具：</p>
<p>运行程序，对每一个页面进行内存分析检查。首先，反复打开关闭页面 5 次，然 后收到 GC（点击 Profile MEMORY 左上角的垃圾桶图标），如果此时 total 内存 还没有恢复到之前的数值，则可能发生了内存泄露。此时，再点击 Profile MEMORY 左上角的垃圾桶图标旁的 heap dump 按钮查看当前的内存堆栈情况， 选择按包名查找，找到当前测试的 Activity，如果引用了多个实例，则表明发生 了内存泄露。</p>
<p>2、使用 MAT：</p>
<p>1、运行程序，所有功能跑一遍，确保没有改出问题，完全退出程序，手动触发 GC，然后使用 adb shell dumpsys meminfo packagename -d 命令查看退出界面 后 Objects 下的 Views 和 Activities 数目是否为 0，如果不是则通过 Leakcanary 检查可能存在内存泄露的地方，最后通过 MAT 分析，如此反复，改善满意为止。 1、在使用 MAT 之前，先使用 as 的 Profile 中的 Memory 去获取要分析的堆内存 快照文件.hprof，如果要测试某个页面是否产生内存泄漏，可以先 dump 出没进 入该页面的内存快照文件.hprof，然后，通常执行 5 次进入/退出该页面，然后再 dump 出此刻的内存快照文件.hprof，最后，将两者比较，如果内存相除明显， 则可能发生内存泄露。（注意:MAT 需要标准的.hprof 文件，因此在 as 的 Profiler 中 GC 后 dump 出的内存快照文件.hprof 必须手动使用 android sdk platform-tools 下的 hprof-conv 程序进行转换才能被 MAT 打开）</p>
<p>2、然后，使用 MAT 打开前面保存的 2 份.hprof 文件，打开 Overview 界面，在 Overview 界面下面有 4 中 action，其中最常用的就是 Histogram 和 Dominator Tree。</p>
<p>Dominator Tree：支配树，按对象大小降序列出对象和其所引用的对象，注重引 用关系分析。选择 Group by package，找到当前要检测的类（或者使用顶部的 Regex 直接搜索），查看它的 Object 数目是否正确，如果多了，则判断发生了 内存泄露。然后，右击该类，选择 Merge Shortest Paths to GC Root 中的 exclude all phantom/weak/soft etc.references 选项来查看该类的 GC 强引用链。最后， 通过引用链即可看到最终强引用该类的对象。 Histogram：直方图注重量的分析。使用方式与 Dominator Tree 类似。</p>
<p>3、对比 hprof 文件，检测出复杂情况下的内存泄露：</p>
<p>通用对比方式：在 Navigation History 下面选择想要对比的 dominator_tree/histogram，右击选择 Add to Compare Basket，然后在 Compare Basket 一栏中点击红色感叹号（Compare the results）生成对比表格（Compared Tables），在顶部 Regex 输入要检测的类，查看引用关系或对象数量去进行分析 即可。 针对于 Historam 的快速对比方式：直接选择 Histogram 上方的 Compare to another Heap Dump 选择要比较的 hprof 文件的 Historam 即可。</p>
<h4 id="Traceview"><a href="#Traceview" class="headerlink" title="Traceview"></a>Traceview</h4><p>Traceview 是 Android 平台特有的数据采集和分析工具，它主要用于分析 Android 中应用程序的 hotspot（瓶颈）。Traceview 本身只是一个数据分析工 具，而数据的采集则需要使用 Android SDK 中的 Debug 类或者利用 DDMS 工 具。二者的用法如下：开发者在一些关键代码段开始前调用 Android SDK 中 Debug 类的 startMethodTracing 函数，并在关键代码段结束前调用 stopMethodTracing 函数。这两个函数运行过程中将采集运行时间内该应用所 有线程（注意，只能是 Java 线程） 的函数执行情况， 并将采集数据保存到 /mnt/sdcard/下的一个文件中。 开发者然后需要利用 SDK 中的 Traceview 工 具来分析这些数据。</p>
<h3 id="什么是-ANR？-如何避免它？"><a href="#什么是-ANR？-如何避免它？" class="headerlink" title="什么是 ANR？ 如何避免它？"></a>什么是 ANR？ 如何避免它？</h3><p>在 Android 上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户 显示一个对话框，这个对话框称作应 用程序无响应（ANR：Application NotResponding）对话框。 用户可以选择让程序继续运行，但是，他们在使用 你的 应用程序时，并不希望每次都要处理这个对话框。因此 ，在程序里对响应 性能的设计很重要这样，这样系统就不会显 示 ANR 给用户。</p>
<p>不同的组件发生 ANR 的时间不一样，Activity 是 5 秒，BroadCastReceiver 是 10 秒，Service 是 20 秒、contentProvider(onCreate)为10秒（均为前台）。</p>
<p>如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt 即可，最新的 ANR 信息在最开始部分。</p>
<ul>
<li>主线程被 IO 操作（从 4.0 之后网络 IO 不允许在主线程中）阻塞。</li>
<li>主线程中存在耗时的计算</li>
<li>主线程中错误的操作，比如 Thread.wait 或者 Thread.sleep 等 Android 系 统会监控程序的响应状况，一旦出现上面两种情况，则弹出 ANR 对话框</li>
<li>应用在 5 秒内未响应用户的输入事件（如按键或者触摸）</li>
<li>BroadcastReceiver 未在 10 秒内完成相关的处理</li>
<li>Service 在特定的时间内无法处理完成 20 秒</li>
</ul>
<h3 id="android-中进程的优先级？"><a href="#android-中进程的优先级？" class="headerlink" title="android 中进程的优先级？"></a>android 中进程的优先级？</h3><p>前台进程：即与用户正在交互的 Activity 或者 Activity 用到的 Service 等，如果系统内存不足 时前台进程是最晚被杀死的</p>
<p>可见进程：可以是处于暂停状态(onPause)的 Activity 或者绑定在其上的 Service，即被用户 可见，但由于失了焦点而不能与用户交互</p>
<p>服务进程：其中运行着使用 startService 方法启动的 Service，虽然不被用户可见，但是却是 用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面下载的文件 等；当系统要空间运行，前两者进程才会被终止</p>
<p>后台进程：其中运行着执行 onStop 方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的 QQ，这时的进程系统一旦没了有内存就首先被杀死</p>
<p>空进程：不包含任何应用程序的进程，这样的进程系统是一般不会让他存在的</p>
<h3 id="AsyncTask与线程池"><a href="#AsyncTask与线程池" class="headerlink" title="AsyncTask与线程池"></a>AsyncTask与线程池</h3><p>核心参数:<br>corePoolSize:核心线程数<br>maximumPoolSize:最大线程数<br>keepAliveTime:非核心线程的闲置时间限制，超过则回收该非核心线程<br>workQueue:BlockingQueue类型，阻塞队列<br>threadFactory：线程的工厂类<br>handler：RejectedExecutionHandler线程池的饱和策略，默认策略是抛出运行时exception</p>
<p>在execute提交时：<br>1.如果线程数小于核心线程，则新建核心线程去执行任务Runable<br>2.将任务Runable加入workQueue中，然后检查是否可以新建线程<br>3.如果队列无法加入Runnable，检查是否可以新建线程(防止线程有回收的),如果不能，执行handler的拒绝策略</p>
<p>thread执行的对象是Worker对象，在worker中run方法会从queue中不停的取任务执行。</p>
<p>Runnable、Callable、Future是三个基础interface，分别是不带结果的运行，带结果的运行，对异步任务整个生命周期的表示。</p>
<p>FutureTask是class，继承了Runnable与Future，内部持有callable。一般外部传入callable。</p>
<p>java内置5中线程池：在Executors中提供静态方法<br>newCachedThreadPool：核心线程0，最大Integer.MAX_VALUE, keepAliveTime为60秒,SynchronousQueue同步阻塞队列。只有非核心线程,最大线程数非常大,所有线程都活动时会为新任务创建新线程, 否则会利用空闲线程(60s 空闲时间,过了就会被回收,所以线程池中有 0 个线程的 可能)处理任务。优点:任何任务都会被立即执行(任务队列 SynchronousQuue 相当于一个空集合); 比较适合执行大量的耗时较少的任务.<br>newSingleThreadExecutor：核心1，最大1，keepAliveTime为0，LinkedBlockingQueue。只有一个核心线程,确保所有的任务都在同一线程中按序完成.因此不需要处理线 程同步的问题.<br>newFixedThreadPool：核心n,最大n，keepAliveTime为0，LinkedBlockingQueue。只有核心线程,并且数量固定的,也不会被回收,所有线程都活动时,因为队列没有 限制大小,新任务会等待执行。优点:更快的响应外界请求。<br>newScheduledThreadPool：线程池为ScheduledThreadPoolExecutor，核心n，最大Integer.MAX_VALUE，keepAliveTime为10秒,DelayedWorkQueue（利用数组模拟堆实现）。主要处理定时任务，和Timer功能类似。核心线程数固定,非核心线程（闲着没活干会被立即回收数）没有限制.优点:执行定时任务以及有固定周期的重复任务<br>newWorkStealingPool：ForkJoinPool，使用一个无限队列来保存需要执行的任务，可以传入线程的数量，不传入，则默认使用当前计算机中可用的cpu数量，使用分治法来解决问题，使用fork()和join()来进行调用.</p>
<p>可以引入rxjava、kotlin线程池框架的比较？</p>
<h3 id="Serializable与Parcelable？"><a href="#Serializable与Parcelable？" class="headerlink" title="Serializable与Parcelable？"></a>Serializable与Parcelable？</h3><p>Serializable（Java 自带）：序列化的意思，表示将一个对象转换成存储或可传输的状态。序 列化后的对象可以在网络上进传输，也可以存储到本地。</p>
<p>Parcelable（android 专用）：是将一个完整的对象进行分解，而 分解后的每一部分都是 Intent 所支持的数据类型，这也就实现传递对象的功能 了。</p>
<p>编码上：Serializable代码量少，写起来方便，Parcelable代码多一些；效率上：Parcelable的速度比高十倍以上。</p>
<p>Serializable方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p>
<h3 id="Bitmap-使用时候注意什么"><a href="#Bitmap-使用时候注意什么" class="headerlink" title="Bitmap 使用时候注意什么"></a>Bitmap 使用时候注意什么</h3><p>1、要选择合适的图片规格（bitmap 类型）：</p>
<p>ALPHA_8每个像素占用 1byte 内存 </p>
<p>ARGB_4444 每个像素占用 2byte 内存 </p>
<p>ARGB_8888 每个像素占用 4byte 内存（默认） </p>
<p>RGB_565 每个像素占用 2byte 内存</p>
<p>2、降低采样率。BitmapFactory.Options 参数 inSampleSize 的使用，先把 options.inJustDecodeBounds 设为 true，只是去读取图片的大小，在拿到图片的 大小之后和要显示的大小做比较通过 calculateInSampleSize()函数计算 inSampleSize 的具体值，得到值之后。options.inJustDecodeBounds 设为 false 读图片资源。</p>
<p>3、复用内存。即，通过软引用(内存不够的时候才会回收掉)，复用内存块，不 需要再重新给这个 bitmap 申请一块新的内存，避免了一次内存的分配和回收， 从而改善了运行效率。</p>
<p>4、使用 recycle()方法及时回收内存。</p>
<p>5、压缩图片。</p>
<p>在 Android 中，Bitmap 的存储分为两部分，一部分是 Bitmap 的数据，一部分是 Bitmap 的引用。 在 Android2.3 时代，Bitmap 的引用是放在堆中的，而 Bitmap 的数据部分是放在栈中的，需要用户调用 recycle 方法手动进行内存回收，而在 Android2.3 之后，整个 Bitmap，包括数据和引用，都放在了堆中，这样，整个 Bitmap 的回收就全部交给 GC 了，这个 recycle 方法就再也不需要使用了。</p>
<p>bitmap recycler 引发的问题：当图像的旋转角度小余两个像素点之间的夹角时， 图像即使旋转也无法显示，因此，系统完全可以认为图像没有发生变化。这时系 统就直接引用同一个对象来进行操作，避免内存浪费。</p>
<p>BitmapFactory 四类方法：<br>decodeFile( 文件系统 )<br>decodeResourece( 资源 )<br>decodeStream( 输入流 )<br>decodeByteArray( 字节数 )</p>
<h4 id="Bitmap-占用内存"><a href="#Bitmap-占用内存" class="headerlink" title="Bitmap 占用内存"></a>Bitmap 占用内存</h4><p>Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存</p>
<p>注：这里 inDensity 表示目标图片的 dpi（放在哪个资源文件夹下）， inTargetDensity 表示目标屏幕的 dpi，所以你可以发现 inDensity 和 inTargetDensity 会对 Bitmap 的宽高进行拉伸，进而改变 Bitmap 占用内存的大 小。 在 Bitmap 里有两个获取内存占用大小的方法。</p>
<p>getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。 getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存 大小，代替了 getByteCount() 方法。 在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片 时，那么 getByteCount() 表示新解码图片占用内存的大 小， getAllocationByteCount() 表示被复用 Bitmap 真实占用的内存大小（即 mBuffer 的长度）。</p>
<p>为了保证在加载 Bitmap 的时候不产生内存溢出，可以使用 BitmapFactory 进行 图片压缩，主要有以下几个参数：<br>BitmapFactory.Options.inPreferredConfig：将 ARGB_8888 改为 RGB_565，改变 编码方式，节约内存。<br>BitmapFactory.Options.inSampleSize：缩放比例，可以 参考 Luban 那个库，根据图片宽高计算出合适的缩放比例。<br>BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。<br>inJustDecodeBounds 获取图片的宽高信息，交给 inSampleSize 参数选 择缩放比</p>
<p>高效加载 Bitmap 的流程:<br>1、将 BitmapFactory.Options 的 inJustDecodeBounds 参数设为 true 并加载图片<br>2、从 BitmapFactory.Options 中取出图片原始的宽高信息， 对应于 outWidth 和 outHeight 参数 3、根据采样率规则并结合目标 view 的大小计算出采样率 inSampleSize<br>4、将 BitmapFactory.Options 的 inJustDecodeBounds 设置为 false 重 新加载图片</p>
<p>针对清明上河图这种大图可以使用 BitmapRegionDecoder 动态加载图片的显示区域。</p>
<h4 id="Bitmap-如何处理大图，如一张-30M-的大图，如何预防-OOM"><a href="#Bitmap-如何处理大图，如一张-30M-的大图，如何预防-OOM" class="headerlink" title="Bitmap 如何处理大图，如一张 30M 的大图，如何预防 OOM?"></a>Bitmap 如何处理大图，如一张 30M 的大图，如何预防 OOM?</h4><p>上面减少bitmap内存的各种策略</p>
<h4 id="Bitmap-对象的理解"><a href="#Bitmap-对象的理解" class="headerlink" title="Bitmap 对象的理解"></a>Bitmap 对象的理解</h4><h3 id="广播传输的数据是否有限制，是多少，为什么要限制？"><a href="#广播传输的数据是否有限制，是多少，为什么要限制？" class="headerlink" title="广播传输的数据是否有限制，是多少，为什么要限制？"></a>广播传输的数据是否有限制，是多少，为什么要限制？</h3><p>Intent 在传递数据时是有大小限制的，大约限制在 1MB 之内，你用 Intent 传递 数据，实际上走的是跨进程通信（IPC），跨进程通信需要把数据从内核 copy</p>
<p>到进程中，每一个进程有一个接收内核数据的缓冲区，默认是 1M；如果一次传 递的数据超过限制，就会出现异常。</p>
<p>不同厂商表现不一样有可能是厂商修改了此限制的大小，也可能同样的对象在不 同的机器上大小不一样。</p>
<p>传递大数据，不应该用 Intent；考虑使用 ContentProvider 或者直接匿名共享内 存。简单情况下可以考虑分段传输。</p>
<h3 id="MVP、MVVM、MVC"><a href="#MVP、MVVM、MVC" class="headerlink" title="MVP、MVVM、MVC"></a>MVP、MVVM、MVC</h3><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC:"></a>MVC:</h4><p>视图层(View) 对应于 xml 布局文件和 java 代码动态 view 部分；<br>控制层(Controller) MVC 中 Android 的控制层是由 Activity 来承担的， Activity 本来主要是作为初始化页面，展示数据的操作，但是因为 XML 视 图功能太弱，所以 Activity 既要负责视图的显示又要加入控制逻辑，承担 的功能过多。<br>模型层(Model) 针对业务模型，建立数据结构和相关的类，它主要负责网 络请求，数据库处理，I/O 的操作。</p>
<p>总结：具有一定的分层，model 彻底解耦，controller 和 view 并没有解耦 层与层之间 的交互尽量使用回调或者去使用消息机制去完成，尽量避免直接持有 controller 和 view 在 android 中无法做到彻底分离，但在代码逻辑层面一定要分清 业务逻 辑被放置在 model 层，能够更好的复用和修改增加业务。</p>
<h4 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h4><p>通过引入接口 BaseView，让相应的视图组件如 Activity，Fragment 去实现 BaseView，实现了视图层的独立，通过中间层 Preseter 实现了 Model 和 View 的完全解耦。MVP 彻底解决了 MVC 中 View 和 Controller 傻傻分不清楚的问题， 但是随着业务逻辑的增加，一个页面可能会非常复杂，UI 的改变是非常多，会 有非常多的 case，这样就会造成 View 的接口会很庞大。</p>
<h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>MVP 中我们说过随着业务逻辑的增加，UI 的改变多的情况下，会有非常多的跟 UI 相关的 case，这样就会造成 View 的接口会很庞大。而 MVVM 就解决了这个 问题，通过双向绑定的机制，实现数据和 UI 内容，只要想改其中一方，另一方 都能够及时更新的一种设计理念，这样就省去了很多在 View 层中写很多 case 的情况，只需要改变数据就行。</p>
<p>MVVM 与 DataBinding 的关系？</p>
<p>MVVM 是一种思想，DataBinding 是谷歌推出的方便实现 MVVM 的工具。</p>
<p>看起来 MVVM 很好的解决了 MVC 和 MVP 的不足，但是由于数据和视图的双向 绑定，导致出现问题时不太好定位来源，有可能数据问题导致，也有可能业务逻 辑中对视图属性的修改导致。如果项目中打算用 MVVM 的话可以考虑使用官方 的架构组件 ViewModel、LiveData、DataBinding 去实现 MVVM。</p>
<p>三者如何选择？</p>
<ul>
<li>如果项目简单，没什么复杂性，未来改动也不大的话，那就不要用设计模 式或者架构方法，只需要将每个模块封装好，方便调用即可，不要为了使 用设计模式或架构方法而使用。</li>
<li>对于偏向展示型的 app，绝大多数业务逻辑都在后端，app 主要功能就是 展示数据，交互等，建议使用 mvvm。 </li>
<li>对于工具类或者需要写很多业务逻辑 app，使用 mvp 或者 mvvm 都可。</li>
</ul>
<h3 id="是否了解硬件加速？"><a href="#是否了解硬件加速？" class="headerlink" title="是否了解硬件加速？"></a>是否了解硬件加速？</h3><p>硬件加速就是运用 GPU 优秀的运算能力来加快渲染的速度，而通常的基于软件 的绘制渲染模式是完全利用 CPU 来完成渲染。</p>
<p>1.硬件加速是从 API 11 引入，API 14 之后才默认开启。对于标准的绘制操作和 控件都是支持的，但是对于自定义 View 的时候或者一些特殊的绘制函数就需要 考虑是否需要关闭硬件加速。</p>
<p>2.我们面对不支持硬件加速的情况，就需要限制硬件加速，这个兼容性的问题是 因为硬件加速是把 View 的绘制函数转化为使用 OpenGL 的函数来进完成实际的 绘制的，那么必然会存在 OpenGL 中不支持原始回执函数的情况，对于这些绘制 函数，就会失效。</p>
<p>3.硬件加速的消耗问题，因为是使用 OpenGL，需要把系统中 OpenGL 加载到内 存中，OpenGL API 调用就会占用 8MB，而实际上会占用更多内存，并且使用了 硬件必然增加耗电量了。</p>
<p>4.硬件加速的优势还有 display list 的设计，使用这个我们不需要每次重绘都执行 大量的代码，基于软件的绘制模式会重绘脏区域内的所有控件，而 display 只会 更新列表，然后绘制列表内的控件。</p>
<ol>
<li>CPU 更擅长复杂逻辑控制，而 GPU 得益于大量 ALU 和并行结构设计，更 擅长数学运算。</li>
</ol>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>1、Activity 和 Service 以及 Application 的 Context 是不一样的,Activity 继 承自 ContextThemeWraper.其他的继承自 ContextWrapper。</p>
<p>2、每一个 Activity 和 Service 以及 Application 的 Context 是一个新的 ContextImpl 对象。</p>
<p>3、getApplication()用来获取 Application 实例的，但是这个方法只有在 Activity 和 Service 中才能调用的到。那也许在绝大多数情况下我们都是在 Activity 或者 Servic 中使用 Application 的，但是如果在一些其它的场景， 比如 BroadcastReceiver 中也想获得 Application 的实例，这时就可以借助 getApplicationContext()方法，getApplicationContext()比 getApplication() 方法的作用域会更广一些，任何一个 Context 的实例，只要调用 getApplicationContext()方法都可以拿到我们的 Application 对象。</p>
<p>4、创建对话框时不可以用 Application 的 context，只能用 Activity 的 context。</p>
<p>5、Context 的数量等于 Activity 的个数 + Service 的个数 +1，这个 1 为 Application。</p>
<h3 id="View-的事件分发机制？滑动冲突怎么解决？"><a href="#View-的事件分发机制？滑动冲突怎么解决？" class="headerlink" title="View 的事件分发机制？滑动冲突怎么解决？"></a>View 的事件分发机制？滑动冲突怎么解决？</h3><p>了解 Activity 的构成</p>
<p>一个 Activity 包含了一个 Window 对象，这个对象是由 PhoneWindow 来实现的。 PhoneWindow 将 DecorView 作为整个应用窗口的根 View，而这个 DecorView 又将屏幕划分为两个区域：一个是 TitleView，另一个是 ContentView，而我们 平时所写的就是展示在 ContentView 中的。</p>
<p>触摸事件的类型</p>
<p>触摸事件对应的是 MotionEvent 类，事件的类型主要有如下三种：ACTION_DOWN、ACTION_MOVE(移动的距离超过一定的阈值会被判定为 ACTION_MOVE 操作) 、ACTION_UP</p>
<p>View 事件分发本质就是对 MotionEvent 事件分发的过程。即当一个 MotionEvent 发生后，系统将这个点击事件传递到一个具体的 View 上。</p>
<p>事件分发流程</p>
<p>事件分发过程由三个方法共同完成： dispatchTouchEvent：方法返回值为 true 表示事件被当前视图消费掉；返回为 super.dispatchTouchEvent 表示继续分发该事件，返回为 false 表示交给父类的 onTouchEvent 处理。</p>
<p>onInterceptTouchEvent：方法返回值为 true 表示拦截这个事件并交由自身的 onTouchEvent 方法进行消费；返回 false 表示不拦截，需要继续传递给子视图。 如果 return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: </p>
<p>1.如果该View存在子View且点击到了该子View, 则不拦截, 继续分发 给 子 View 处理, 此时相当于 return false。</p>
<p>2.如果该 View 没有子 View 或者有子 View 但是没有点击中子 View(此时 ViewGroup 相当于普通 View), 则交由该 View 的 onTouchEvent 响应，此 时相当于 return true。</p>
<p>注意：一般的 LinearLayout、 RelativeLayout、FrameLayout 等 ViewGroup 默认 不拦截， 而 ScrollView、ListView 等 ViewGroup 则可能拦截，得看具体情况。</p>
<p>onTouchEvent：方法返回值为 true 表示当前视图可以处理对应的事件；返回值 为 false 表示当前视图不处理这个事件，它会被传递给父视图的 onTouchEvent 方法进行处理。如果 return super.onTouchEvent(ev)，事件处理分为两种情况：</p>
<p>1.如果该 View 是 clickable 或者 longclickable 的,则会返回 true, 表示消费 了该事件, 与返回 true 一样;</p>
<p>2.如果该 View 不是 clickable 或者 longclickable 的,则会返回 false, 表示不 消费该事件,将会向上传递,与返回 false 一样。</p>
<p>注意：在 Android 系统中，拥有事件传递处理能力的类有以下三种：</p>
<p>Activity：拥有分发和消费两个方法。 ViewGroup：拥有分发、拦截和消费三个方法。 View：拥有分发、消费两个方法。</p>
<p>三个方法的关系用伪代码表示如下：</p>
<p>public boolean dispatchTouchEvent(MotionEvent ev) { </p>
<p>boolean consume = false; </p>
<p>if (onInterceptTouchEvent(ev)) {</p>
<p>consume = onTouchEvent(ev); </p>
<p>} else {</p>
<p>coonsume = child.dispatchTouchEvent(ev); </p>
<p>}</p>
<p>return consume;</p>
<p>}</p>
<p>通过上面的伪代码，我们可以大致了解点击事件的传递规则：对应一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，这是它的 dispatchTouchEvent 就会被调用，如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 true 就表示它要拦截当前事件，接着事件就会 交给这个 ViewGroup 处理，这时如果它的 mOnTouchListener 被设置，则 onTouch 会被调用，否则 onTouchEvent 会被调用。在 onTouchEvent 中，如果 设置了 mOnCLickListener，则 onClick 会被调用。只要 View 的 CLICKABLE 和 LONG_CLICKABLE 有一个为 true，onTouchEvent()就会返回 true 消耗这个事件。 如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 false 就表示它不拦截 当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 dispatchTouchEvent 方法就会被调用，如此反复直到事件被最终处理。</p>
<p>一些重要的结论：</p>
<p>1、事件传递优先级：onTouchListener.onTouch &gt; onTouchEvent &gt; onClickListener.onClick。 2、正常情况下，一个时间序列只能被一个 View 拦截且消耗。因为一旦一个元 素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不 会再调用这个 View 的拦截方法去询问它是否要拦截了，而是把剩余的 ACTION_MOVE、ACTION_DOWN 等事件直接交给它来处理）。特例：通过将重 写 View 的 onTouchEvent 返回 false 可强行将事件转交给其他 View 处理。</p>
<p>3、如果 View 不消耗除 ACTION_DOWN 以外的其他事件，那么这个点击事件会 消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续收 到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。</p>
<p>4、ViewGroup 默认不拦截任何事件（返回 false）。</p>
<p>5、View 的 onTouchEvent 默认都会消耗事件（返回 true），除非它是不可点击 的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认 都为 false，clickable 属性要分情况，比如 Button 的 clickable 属性默认为 true， 而 TextView 的 clickable 默认为 false。</p>
<p>6、View 的 enable 属性不影响 onTouchEvent 的默认返回值。</p>
<p>7、通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的 事件分发过程，但是 ACTION_DOWN 事件除外。</p>
<p>ACTION_CANCEL 什么时候触发，触摸 button 然后滑动到外部抬起会触发点 击事件吗，再滑动回去抬起会么？</p>
<p>一般 ACTION_CANCEL 和 ACTION_UP 都作为 View 一段事件处理的结束。</p>
<p>如果在父 View 中拦截 ACTION_UP 或 ACTION_MOVE，在第一次父视图 拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收 到 ACTION_CANCEL 事件。 </p>
<p>如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地 方了），就会出现 action_cancel。</p>
<p>点击事件被拦截，但是想传到下面的 View， 如何操作？</p>
<p>重写子类的 requestDisallowInterceptTouchEvent()方法返回 true 就不会执行父类的 onInterceptTouchEvent()，即可将点击事件传到下面的 View。</p>
<p>如何解决 View 的事件冲突？举个开发中遇到的例子？</p>
<p>常见开发中事件冲突的有 ScrollView 与 RecyclerView 的滑动冲突、RecyclerView 内嵌同时滑动同一方向。 滑动冲突的处理规则：</p>
<p>对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动 的方向判断谁来拦截事件。对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业 务需求，规定何时让外部 View 拦截事件，何时由内部 View 拦截事件。 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破 点。</p>
<p>滑动冲突的实现方法：</p>
<p>外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此 事件就拦截，否则就不拦截。具体方法：需要重写父容器的 onInterceptTouchEvent 方法，在内部做出相应的拦截。 </p>
<p>内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器， 如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方 法：需要配合 requestDisallowInterceptTouchEvent 方法。</p>
<h3 id="View-的绘制流程"><a href="#View-的绘制流程" class="headerlink" title="View 的绘制流程"></a>View 的绘制流程</h3><p>DecorView 被加载到 Window 中</p>
<p>从 Activity 的 startActivity 开 始 ， 最 终 调 用 到 ActivityThread 的 handleLaunchActivity 方 法 来 创 建 Activity ， 首 先 ， 会 调 用 performLaunchActivity 方法，内部会执行 Activity 的 onCreate 方法，从 而 完 成 DecorView 和 Activity 的 创 建 。 然 后 ， 会 调 用 handleResumeActivity，里面首先会调用 performResumeActivity 去执行 Activity 的 onResume()方法， 执行完后会得到一个 ActivityClientRecord 对象，然后通过 r.window.getDecorView()的方式得到 DecorView，然后会 通 过 a.getWindowManager() 得 到 WindowManager ， 最 终 调 用 其 addView()方法将 DecorView 加进去。 </p>
<p>WindowManager 的 实 现 类 是 WindowManagerImpl ， 它 内 部 会 将 addView 的逻辑委托给 WindowManagerGlobal，可见这里使用了接口隔 离和委托模式将实现和抽象充分解耦。 在 WindowManagerGlobal 的 addView()方法中不仅会将 DecorView 添加到 Window 中， 同时会创建 ViewRootImpl 对 象 ， 并 将 ViewRootImpl 对 象 和 DecorView 通 过 root.setView()把 DecorView 加载到 Window 中。 这里的 ViewRootImpl 是 ViewRoot 的实现类，是连接 WindowManager 和 DecorView 的纽带。 View 的三大流程均是通过 ViewRoot 来完成的。</p>
<p>了解绘制的整体流程</p>
<p>绘制会从根视图 ViewRoot 的 performTraversals()方法开始，从上到下遍历整个 视图树，每个 View 控件负责绘制自己，而 ViewGroup 还需要负责通知自己的子 View 进行绘制操作。 理解 MeasureSpec</p>
<p>MeasureSpec 表示的是一个 32 位的整形值，它的高 2 位表示测量模式 SpecMode，低 30 位表示某种测量模式下的规格大小 SpecSize。MeasureSpec</p>
<p>是 View 类的一个静态内部类，用来说明应该如何测量这个 View。它由三种测量 模式，如下：</p>
<p>EXACTLY：精确测量模式，视图宽高指定为 match_parent 或具体数值时生效，表示父视图已经决定了子视图的精确大小，这种模式下 View 的测量值就是 SpecSize 的值。</p>
<p>AT_MOST：最大值测量模式，当视图的宽高指定为 wrap_content 时生效， 此时子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。 UNSPECIFIED：不指定测量模式, 父视图没有限制子视图的大小，子视图 可以是想要的任何尺寸，通常用于系统内部，应用开发中很少用到。</p>
<p>MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对 象内存分配，为了方便操作，其提供了打包和解包的方法，打包方法为 makeMeasureSpec，解包方法为 getMode 和 getSize。</p>
<p>普通 View 的 MeasureSpec 的创建规则如下：</p>
<p>对于 DecorView 而言，它的 MeasureSpec 由窗口尺寸和其自身的 LayoutParams共同决定；对于普通的 View，它的 MeasureSpec 由父视图的 MeasureSpec 和其自身的 LayoutParams 共同决定。</p>
<h4 id="如何根据-MeasureSpec-去实现一个瀑布流的自定义-ViewGroup？"><a href="#如何根据-MeasureSpec-去实现一个瀑布流的自定义-ViewGroup？" class="headerlink" title="如何根据 MeasureSpec 去实现一个瀑布流的自定义 ViewGroup？"></a>如何根据 MeasureSpec 去实现一个瀑布流的自定义 ViewGroup？</h4><h4 id="View-绘制流程之-Measure"><a href="#View-绘制流程之-Measure" class="headerlink" title="View 绘制流程之 Measure"></a>View 绘制流程之 Measure</h4><p>首 先 ， 在 ViewGroup 中 的 measureChildren() 方 法 中 会 遍 历 测 量 ViewGroup 中所有的 View，当 View 的可见性处于 GONE 状态时，不对 其进行测量。 然后，测量某个指定的 View 时，根据父容器的 MeasureSpec 和子 View 的 LayoutParams 等信息计算子 View 的 MeasureSpec。 最后， 将计算出的 MeasureSpec 传入 View 的 measure 方法， 这里 ViewGroup 没有定义测量的具体过程，因为 ViewGroup 是一个抽象类， 其测量过程的 onMeasure 方法需要各个子类去实现。不同的 ViewGroup 子类有不同的布局特性，这导致它们的测量细节各不相同，如果需要自定 义测量过程，则子类可以重写这个方法。（setMeasureDimension 方法用 于设置 View 的测量宽高，如果 View 没有重写 onMeasure 方法，则会默 认调用 getDefaultSize 来获得 View 的宽高）</p>
<p>getSuggestMinimumWidth 分析</p>
<p>如果 View 没有设置背景，那么返回 android:minWidth 这个属性所指定的值，这 个值可以为 0；如果 View 设置了背景，则返回 android:minWidth 和背景的最小 宽度这两者中的最大值。</p>
<p>自定义 View 时手动处理 wrap_content 时的情形</p>
<p>直接继承 View 的控件需要重写 onMeasure 方法并设置 wrap_content 时的自身 大小，否则在布局中使用 wrap_content 就相当于使用 match_parent。此时，可 以在 wrap_content 的情况下（对应 MeasureSpec.AT_MOST）指定内部宽/高 (mWidth 和 mHeight)。 LinearLayout 的 onMeasure 方法实现解析（这里仅分析 measureVertical 核心源码）</p>
<p>系统会遍历子元素并对每个子元素执行 measureChildBeforeLayout 方法，这个 方法内部会调用子元素的 measure 方法，这样各个子元素就开始依次进入 measure 过程，并且系统会通过 mTotalLength 这个变量来存储 LinearLayout 在 竖直方向的初步高度。每测量一个子元素，mTotalLength 就会增加，增加的部 分主要包括了子元素的高度以及子元素在竖直方向上的 margin 等。</p>
<p>在Activity中获取某个View的宽高</p>
<p>由于View的measure过程和Activity的生命周期方法不是同步执行的，如果View 还没有测量完毕，那么获得的宽/高就是 0。所以在 onCreate、onStart、onResume 中均无法正确得到某个 View 的宽高信息。解决方式如下：</p>
<p>Activity/View#onWindowFocusChanged：此时 View 已经初始化完毕， 当 Activity 的窗口得到焦点和失去焦点时均会被调用一次，如果频繁地进 行 onResume 和 onPause，那么 onWindowFocusChanged 也会被频繁地 调用。 view.post(runnable)： 通过 post 可以将一个 runnable 投递到消息队列的 尾部，始化好了然后等待 Looper 调用次 runnable 的时候，View 也已经 初始化好了。 ViewTreeObserver#addOnGlobalLayoutListener：当 View 树的状态发生 改变或者 View 树内部的 View 的可见性发生改变时，onGlobalLayout 方 法将被回调。 View.measure(int widthMeasureSpec, int heightMeasureSpec) ： match_parent 时不知道 parentSize 的大小，测不出；具体数值时，直接 makeMeasureSpec 固 定 值 ， 然 后 调 用 view..measure 就 可 以 了 ； wrap_content 时，在最大化模式下，用 View 理论上能支持的最大值去构 造 MeasureSpec 是合理的。</p>
<h4 id="View-的绘制流程之-Layout"><a href="#View-的绘制流程之-Layout" class="headerlink" title="View 的绘制流程之 Layout"></a>View 的绘制流程之 Layout</h4><p>首先，会通过 setFrame 方法来设定 View 的四个顶点的位置，即 View 在父容器 中的位置。然后，会执行到 onLayout 空方法，子类如果是 ViewGroup 类型，则 重写这个方法，实现 ViewGroup 中所有 View 控件布局流程。</p>
<p>LinearLayout 的 onLayout 方法实现解析（layoutVertical 核心源码）</p>
<p>其中会遍历调用每个子 View 的 setChildFrame 方法为子元素确定对应的位置。 其中的 childTop 会逐渐增大，意味着后面的子元素会被放置在靠下的位置。</p>
<p>注意：在 View 的默认实现中，View 的测量宽/高和最终宽/高是相等的，只不过 测量宽/高形成于 View 的 measure 过程，而最终宽/高形成于 View 的 layout 过 程，即两者的赋值时机不同，测量宽/高的赋值时机稍微早一些。在一些特殊的 情况下则两者不相等：</p>
<p>重写 View 的 layout 方法,使最终宽度总是比测量宽/高大 100px。 </p>
<p>View 需要多次 measure 才能确定自己的测量宽/高，在前几次测量的过程 中，其得出的测量宽/高有可能和最终宽/高不一致，但最终来说，测量宽 /高还是和最终宽/高相同。</p>
<h4 id="View-的绘制流程之-Draw"><a href="#View-的绘制流程之-Draw" class="headerlink" title="View 的绘制流程之 Draw"></a>View 的绘制流程之 Draw</h4><p>Draw 的基本流程</p>
<p>绘制基本上可以分为六个步骤： </p>
<p>首先绘制 View 的背景；</p>
<p> 如果需要的话，保持 canvas 的图层，为 fading 做准备； </p>
<p>然后，绘制 View 的内容； </p>
<p>接着，绘制 View 的子 View； </p>
<p>如果需要的话，绘制 View 的 fading 边缘并恢复图层； </p>
<p>最后，绘制 View 的装饰(例如滚动条等等)。</p>
<h4 id="setWillNotDraw-的作用"><a href="#setWillNotDraw-的作用" class="headerlink" title="setWillNotDraw 的作用"></a>setWillNotDraw 的作用</h4><p>如果一个 View 不需要绘制任何内容，那么设置这个标记位为 true 以后，系统会 进行相应的优化。 </p>
<p>默认情况下，View 没有启用这个优化标记位，但是 ViewGroup 会默认启 用这个优化标记位。  当我们的自定义控件继承于 ViewGroup 并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。  当明确知道一个 ViewGroup 需要通过 onDraw 来绘制内容时，我们需要显示地关闭 WILL_NOT_DRAW 这个标记位。</p>
<p>requestLayout()方法 ：会导致调用 measure()过程 和 layout()过程，将会根据 标志位判断是否需要 ondraw。</p>
<h3 id="Handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析</h3><ol>
<li>消息是通过 MessageQueen 中的 enqueueMessage()方法加入消息队列中的，并 且它在放入中就进行好排序，链表头的延迟时间小，尾部延迟时间最大</li>
<li>Looper.loop()通过 MessageQueue 中的 next()去取消息</li>
<li>next()中如果当前链表头部消息是延迟消息，则根据延迟时间进行消息队列会 阻塞，不返回给 Looper message，直到时间到了，返回给 message</li>
<li>如果在阻塞中有新的消息插入到链表头部则唤醒线程</li>
<li>Looper 将新消息交给回调给 handler 中的 handleMessage 后，继续调用MessageQueen 的 next()方法，如果刚刚的延迟消息还是时间未到，则计算时间 继续阻塞</li>
</ol>
<h5 id="屏障消息"><a href="#屏障消息" class="headerlink" title="屏障消息"></a>屏障消息</h5><p>在ViewRootImpl中scheduleTraversals里面先调用postSyncBarrier发送同步消息(message中没有target)，然后向Choreographer注册同步回调监听接口，收到同步回调后向handler发送异步消息。在messagequeue中next取消息时，一旦发现没有target的消息，则优先执行异步消息。</p>
<p>设置了屏障消息，此时只会处理异步消息，处理完异步消息后就会堵塞。如果想要恢复同步消息，需要调用 removeSyncBarrier()移除。</p>
<p>子线程中Toast和Dialog的show发生crash原因：Toast和dialog里面有使用到new Handler()，如果子线程没有Looper.prepare();则会导致crash。</p>
<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>为什么选用 Binder，在讨论这个问题之前，我们知道 Android 也是基于 Linux 内核，Linux 现有的进程通信手段有以下几种：</p>
<p>1.管道：在创建时分配一个 page 大小的内存，缓存区大小比较有限；<br>2.消息队列：信息复制两次，额外的 CPU 消耗；不合适频繁或信息量大的通信；<br>3.共享内存：无须复制，共享缓冲区直接附加到进程虚拟地址空间，速度快； 但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；<br>4.套接字：作为更通用的接口，传输效率低，主要用于不同机器或跨网络的 通信；<br>5.信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程 也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同 步手段。 不适用于信息交换，更适用于进程中断控制，比如非法内存访 问，杀死某个进程等；</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：<br>1.首先 Binder 驱动在内核空间创建一个数据接收缓存区。<br>2.接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收 缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间 地址的映射关系。<br>3.发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也 就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间 的通信。</p>
<p>Binder系列1—Binder Driver初探</p>
<h3 id="AMS解析"><a href="#AMS解析" class="headerlink" title="AMS解析"></a>AMS解析</h3><p>1.ActivityManagerServices，简称 AMS，服务端对象，负责系统中所有 Activity 的生命周期。</p>
<p>2.ActivityThread，App 的真正入口。当开启 App 之后，调用 main()开始运行， 开启消息循环队列，这就是传说的 UI 线程或者叫主线程。与 ActivityManagerService 一起完成 Activity 的管理工作。 3.ApplicationThread，用来实现 ActivityManagerServie 与 ActivityThread 之间的 交互。在 ActivityManagerSevice 需要管理相关 Application 中的 Activity 的生命 周期时，通过 ApplicationThread 的代理对象与 ActivityThread 通信。</p>
<p>4.ApplicationThreadProxy，是 ApplicationThread 在服务器端的代理，负责和客 户端的 ApplicationThread 通信。AMS 就是通过该代理与 ActivityThread 进行通 信的。</p>
<p>5.Instrumentation，每一个应用程序只有一个 Instrumetation 对象，每个 Activity 内都有一个对该对象的引用，Instrumentation 可以理解为应用进程的管家， ActivityThread 要创建或暂停某个 Activity 时，都需要通过 Instrumentation 来进 行具体的操作。</p>
<p>6.ActivityStack，Activity 在 AMS 的栈管理，用来记录经启动的 Activity 的先后 关系，状态信息等。通过 ActivtyStack 决定是否需要启动新的进程。</p>
<p>7.ActivityRecord，ActivityStack 的管理对象，每个 Acivity 在 AMS 对应一个 ActivityRecord，来记录 Activity 状态以及其他的管理信息。其实就是服务器端的 Activit 对象的映像。</p>
<p>8.TaskRecord，AMS 抽象出来的一个“任务”的概念，是记录 ActivityRecord 的栈， 一个“Task”包含若干个 ActivityRecord。AMS 用 TaskRecord 确保 Activity 启动和 退出的顺序。如果你清楚 Activity 的 4 种 launchMode，那么对这概念应该不陌 生。</p>
<p>调用流程：<br>1、点击桌面应用图标，Launcher 进程将启动 Activity（MainActivity）的 请求以 Binder 的方式发送给了 AMS。<br>2、AMS 接收到启动请求后，交付 ActivityStarter 处理 Intent 和 Flag 等信 息，然后再交给 ActivityStackSupervisior/ActivityStack 处理 Activity 进栈 相关流程。同时以 Socket 方式请求 Zygote 进程 fork 新进程。<br>3、Zygote 接收到新进程创建请求后 fork 出新进程。<br>4、在新进程里创建 ActivityThread 对象，新创建的进程就是应用的主线 程，在主线程里开启 Looper 消息循环，开始处理创建 Activity。<br>5、ActivityThread 利用 ClassLoader 去加载 Activity、创建 Activity 实例， 并回调 Activity 的 onCreate()方法，这样便完成了 Activity 的启动。</p>
<h3 id="Window-和-WindowManager"><a href="#Window-和-WindowManager" class="headerlink" title="Window 和 WindowManager"></a>Window 和 WindowManager</h3><p>1.Window 用于显示 View 和接收各种事件，Window 有三种型：应用 Window(每 个 Activity 对应一个 Window)、子 Widow(不能单独存在，附属于特定 Window)、 系统 window(toast 和状态栏)<br>2.Window分层级，应用Window在1-99、子Window在1000-1999、系统Window 在 2000-2999.WindowManager 提供了增删改 View 的三个功能。<br>3.Window 是个抽象概念：每一个 Window 对应着一个 ViewRootImpl，Window 通过 ViewRootImpl 来和 View 建立联系，View 是 Window 存在的实体，只能通 过 WindowManager 来访问 Window。<br>4.WindowManager 的实现是 WindowManagerImpl，其再委托 WindowManagerGlobal 来对 Window 进行操作，其中有四种 List 分别储存对应 的 View、ViewRootImpl、WindowManger.LayoutParams 和正在被删除的 View。<br>5.Window 的实体是存在于远端的 WindowMangerService，所以增删改 Window 在本端是修改上面的几个 List 然后通过 ViewRootImpl 重绘 View，通过 WindowSession(每 Window 个对应一个)在远端修改 Window。<br>6.Activity 创建 Window：Activity 会在 attach()中创建 Window 并设置其回调 (onAttachedToWindow()、dispatchTouchEvent())，Activity 的 Window 是由 Policy 类创建 PhoneWindow 实现的。然后通过 Activity#setContentView()调用 PhoneWindow 的 setContentView。</p>
<h3 id="Android系统的启动过程"><a href="#Android系统的启动过程" class="headerlink" title="Android系统的启动过程"></a>Android系统的启动过程</h3><ol>
<li>linux内核启动后会启动第一个用户空间进程Init(pId=1),Init进程会解析和分析init.rc文件，rc文件中配置了各种程序和服务的启动项</li>
<li>在init.rc中也配置了Zygote进程的启动项，Zygote进程的执行文件/system/bin/app_process，实现代码为app_main.cpp，在main方法中启动了AppRuntime虚拟机，同时指定虚拟机执行com.android.internal.os.ZygoteInit，进入java世界</li>
<li>ZygoteInit的main方法中registerZygoteSocket(注册socket长连接)、preloadClasses、preloadResources、startSystemServer（开启system_server进程）、runSelectLoop(Zygote执行死循环监听socket)</li>
<li>startSystemServer中fork出system_server进程后执行handleSystemServerProcess初始化相关信息，其中层层调用到app_main.cpp中的onZygoteInit方法来初始化binder线程池。其中的RuntimeInit.zygoteInit故意抛出异常，ZygoteInit的main方法中捕获该异常，然后使用反射的方式执行异常中指定的class和method（system_server进程是SystemServer.main,该参数在startSystemServer方法中由代码指定；普通应用进程是ActivityThread.main，该参数从socket中读取）。SystemServer.main中启动system_server进程中的各种系统服务。</li>
</ol>
<h3 id="APK安装"><a href="#APK安装" class="headerlink" title="APK安装"></a>APK安装</h3><p>复制 APK 到/data/app 目录下，解压并扫描安装包。</p>
<p>资源管理器解析 APK 里的资源文件。</p>
<p>解析 AndroidManifest 文件，并在/data/data/目录下创建对应的应用数据目录。</p>
<p>然后对 dex 文件进行优化，并保存在 dalvik-cache 目录下。</p>
<p>将 AndroidManifest 文件解析出的四大组件信息注册到 PackageManagerService 中。</p>
<p>安装完成后，发送广播。</p>
<h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><p>1.通过 AAPT 工具进行资源文件（包括 AndroidManifest.xml、布局文件、 各种 xml 资源等）的打包，生成 R.java 文件。<br>2.通过 AIDL 工具处理 AIDL 文件，生成相应的 Java 文件。<br>3.通过 Java Compiler 编译 R.java、Java 接口文件、Java 源文件，生成.class 文件。<br>4.通 过 dex 命 令 ， 将 .class 文 件 和第 三 方 库 中 的 .class 文 件 处 理生成 classes.dex，该过程主要完成 Java 字节码转换成 Dalvik 字节码，压缩常 量池以及清除冗余信息等工作。<br>5.通过 ApkBuilder 工具将资源文件、DEX 文件打包生成 APK 文件。<br>6.通过 Jarsigner 工具，利用 KeyStore 对生成的 APK 文件进行签名。<br>7.如果是正式版的 APK，还会利用 ZipAlign 工具进行对齐处理，对齐的过 程就是将 APK 文件中所有的资源文件距离文件的起始距位置都偏移 4 字 节的整数倍，这样通过内存映射访问 APK 文件的速度会更快，并且会减 少其在设备上运行时的内存占用。 </p>
<p>apk 组成<br>1.dex：最终生成的 Dalvik 字节码。<br>2.res：存放资源文件的目录。<br>3.asserts：额外建立的资源文件夹。<br>4.lib：如果存在的话，存放的是 ndk 编出来的 so 库。<br>5.META-INF：存放签名信息 MANIFEST.MF（清单文件）：其中每一个资源文件都有一个 SHA-256-Digest 签 名，MANIFEST.MF 文件的 SHA256（SHA1）并 base64 编码的结果即为 CERT.SF 中的 SHA256-Digest-Manifest 值。</p>
<p>CERT.SF（待签名文件）：除了开头处定义的 SHA256（SHA1）-Digest-Manifest 值，后面几项的值是对 MANIFEST.MF 文件中的每项再次 SHA256 并 base64 编 码后的值。<br>CERT.RSA（签名结果文件）：其中包含了公钥、加密算法等信息。首先对前一 步生成的 MANIFEST.MF 使用了 SHA256（SHA1）-RSA 算法，用开发者私钥签 名，然后在安装时使用公钥解密。最后，将其与未加密的摘要信息（MANIFEST.MF 文件）进行对比，如果相符，则表明内容没有被修改。</p>
<p>androidManifest：程序的全局清单配置文件。<br>resources.arsc：编译后的二进制资源文件</p>
<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><h4 id="v1签名"><a href="#v1签名" class="headerlink" title="v1签名"></a>v1签名</h4><p>1.对Apk中的每个文件做一次算法(数据摘要+Base64编码)，保存到MANIFEST.MF文件中<br>2.对MANIFEST.MF整个文件做一次算法(数据摘要+Base64编码)，存放到CERT.SF文件的头属性中，在对MANIFEST.MF文件中各个属性块做一次算法(数据摘要+Base64编码)，存到到一个属性块中<br>3.对CERT.SF文件做签名，内容存档到CERT.RSA中</p>
<h4 id="V2签名（Android-7-0）"><a href="#V2签名（Android-7-0）" class="headerlink" title="V2签名（Android 7.0）"></a>V2签名（Android 7.0）</h4><p>由于在 v1 仅针对单个 ZIP 条目进行验证，因此，在 APK 签署后可进行许多修改 — 可以移动甚至重新压缩文件。事实上，编译过程中要用到的 ZIPalign 工具就是这么做的，它用于根据正确的字节限制调整 ZIP 条目，以改进运行时性能。而且我们也可以利用这个东西，在打包之后修改 META-INF 目录下面的内容，或者修改 ZIP 的注释来实现多渠道的打包，在 v1 签名中都可以校验通过。</p>
<p>v2 签名将验证归档中的所有字节，而不是单个 ZIP 条目，因此，在签署后无法再运行 ZIPalign（必须在签名之前执行）。正因如此，现在，在编译过程中，Google 将压缩、调整和签署合并成一步完成。</p>
<p>签名过程</p>
<p>首先，说一下 APK 摘要计算规则，对于每个摘要算法，计算结果如下:</p>
<ul>
<li>将 APK 中文件 ZIP 条目的内容、ZIP 中央目录、ZIP 中央目录结尾按照 1MB 大小分割成一些小块。</li>
<li>计算每个小块的数据摘要，数据内容是 0xa5 + 块字节长度 + 块内容。</li>
<li>计算整体的数据摘要，数据内容是 0x5a + 数据块的数量 + 每个数据块的摘要内容</li>
</ul>
<p>总之，就是把 APK 按照 1M 大小分割，分别计算这些分段的摘要，最后把这些分段的摘要在进行计算得到最终的摘要也就是 APK 的摘要。然后将 APK 的摘要 + 数字证书 + 其他属性生成签名数据写入到 APK Signing Block 区块。</p>
<h4 id="V3签名（Android-9-0）"><a href="#V3签名（Android-9-0）" class="headerlink" title="V3签名（Android 9.0）"></a>V3签名（Android 9.0）</h4><p>新版v3签名在v2的基础上，仍然采用检查整个压缩包的校验方式。不同的是在签名部分增可以添加新的证书（Attr块）。在这个新块中，会记录我们之前的签名信息以及新的签名信息，以密钥转轮的方案，来做签名的替换和升级。这意味着，只要旧签名证书在手，我们就可以通过它在新的 APK 文件中，更改签名。</p>
<p>v3 签名新增的新块（attr）存储了所有的签名信息，由更小的 Level 块，以链表的形式存储。</p>
<p>其中每个节点都包含用于为之前版本的应用签名的签名证书，最旧的签名证书对应根节点，系统会让每个节点中的证书为列表中下一个证书签名，从而为每个新密钥提供证据来证明它应该像旧密钥一样可信。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h3 id="Davilk、ART区别"><a href="#Davilk、ART区别" class="headerlink" title="Davilk、ART区别"></a>Davilk、ART区别</h3><p>Dalvik:从安卓诞生之初到4.4版本，最开始使用解析器解析字节码，在2.2中引入JIT编译器，使得Dalvik 的性能提升了 3~6 倍。但是由于JIT每次启动应用都要重新编译，导致耗电严重。在4.4中引入ART虚拟机的预览版和AOT编译策略，此时Davilk和ART是共存的，用户可以自由选择。</p>
<p>ART：5.0时正式取代Dalvik，AOT也成为唯一的编译策略，同时也改成了GC的过程。AOT虽然解决了每次都要重新编译和耗电的问题，但是也引入了新问题：应用安装和系统升级之后的应用优化比较耗时、优化后的文件会占用额外的存储空间。于是在7.0的时候JIT编译器回归，这种混合编译的特点：</p>
<ol>
<li>应用在安装的时候 dex 不会被编译；</li>
<li>应用在运行时 dex 文件先通过解析器（Interpreter）后会被直接执行，与此同时，热点函数（Hot Code）会被识别并被 JIT 编译后存储在 jit code cache 中并生成 profile 文件以记录热点函数的信息；</li>
<li>手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译。</li>
</ol>
<p>混合编译模式综合了 AOT 和 JIT 的各种优点，使得应用在安装速度加快的同时，运行速度、存储空间和耗电量等指标都得到了优化。</p>
<p>OT 和 JIT 的不同之处在于：JIT 是在运行时进行编译，是动态编译，并且每次运行程序的时候都需要对 odex 重新进行编译；而 AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex 预编译成 ELF 文件，每次运行程序的时候不用重新编译，是真正意义上的本地应用。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903748058218509">详细参考</a></p>
<h3 id="ART-和-Davlik-中垃圾回收的区别"><a href="#ART-和-Davlik-中垃圾回收的区别" class="headerlink" title="ART 和 Davlik 中垃圾回收的区别"></a>ART 和 Davlik 中垃圾回收的区别</h3><h3 id="安卓内存管理"><a href="#安卓内存管理" class="headerlink" title="安卓内存管理"></a>安卓内存管理</h3><h3 id="App-是如何沙箱化"><a href="#App-是如何沙箱化" class="headerlink" title="App 是如何沙箱化"></a>App 是如何沙箱化</h3><h2 id="3-项目"><a href="#3-项目" class="headerlink" title="3. 项目"></a>3. 项目</h2><h3 id="应用更新"><a href="#应用更新" class="headerlink" title="应用更新"></a>应用更新</h3><p>灰度，强制更新，分区域更新</p>
<p>1、通过接口获取线上版本号，versionCode 2、比较线上的 versionCode 和本地 的 versionCode，弹出更新窗口 3、下载 APK 文件（文件下载） 4、安装 APK</p>
<p>灰度： (1)找单一渠道投放特别版本。 (2)做升级平台的改造，允许针对部分用 户推送升级通知甚至版本强制升级。 (3)开放单独的下载入口。 (4)是两个版本 的代码都打到 app 包里，然后在 app 端植入测试框架，用来控制显示哪个版本。 测试框架负责与服务器端 api 通信，由服务器端控制 app 上 A/B 版本的分布， 可以实现指定的一组用户看到 A 版本，其它用户看到 B 版本。服务端会有相应 的报表来显示 A/B 版本的数量和效果对比。最后可以由服务端的后台来控制，全 部用户在线切换到 A 或者 B 版本~ 无论哪种方法都需要做好版本管理工作，分配特别的版本号以示区别。 当然， 既然是做灰度，数据监控（常规数据、新特性数据、主要业务数据）还是要做到 位，该打的数据桩要打。 还有，灰度版最好有收回的能力，一般就是强制升级 下一个正式版。 强制更新:一般的处理就是进入应用就弹窗通知用户有版本更新，弹窗可以没有 取消按钮并不能取消。这样用户就只能选择更新或者关闭应用了，当然也可以添 加取消按钮，但是如果用户选择取消则直接退出应用。 增量更新：bsdiff：二进制差分工具 bsdiff 是相应的补丁合成工具,根据两个不同 版本的二进制文件，生成补丁文件.patch 文件。通过 bspatch 使旧的 apk 文件与 不定文件合成新的 apk。 注意通过 apk 文件的 md5 值进行区分版本。</p>
<h3 id="OkHttp-实现原理"><a href="#OkHttp-实现原理" class="headerlink" title="OkHttp 实现原理"></a>OkHttp 实现原理</h3><p>网络底层库，它是基于 http 协议封装的一套请求客户端，虽然它也可以开线程， 但根本上它更偏向真正的请求，跟 HttpClient, HttpUrlConnection 的职责是一样 的。其中封装了网络请求 get、post 等底层操作的实现。</p>
<p>为什么要在项目中使用这个库？</p>
<p>1.OkHttp 提供了对最新的 HTTP 协议版本 HTTP/2 和 SPDY 的支持，这 使得对同一个主机发出的所有请求都可以共享相同的套接字连接。<br>2.如果 HTTP/2 和 SPDY 不可用，OkHttp 会使用连接池来复用连接以提 高效率。<br>3.OkHttp 提供了对 GZIP 的默认支持来降低传输内容的大小。<br>4.OkHttp 也提供了对 HTTP 响应的缓存机制，可以避免不必要的网络请求。<br>5.当网络出现问题时，OkHttp 会自动重试一个主机的多个 IP 地址。</p>
<p>OkHttp 内部的请求流程：使用 OkHttp 会在请求的时候初始化一个 Call 的实例， 然后执行它的 execute()方法或 enqueue()方法，内部最后都会执行到 getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任 链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、 连接拦截器和用户自定义网络拦截器以及访问服务器拦截器等拦截处理过程，来 获取到一个响应并交给用户。其中，除了 OKHttp 的内部请求流程这点之外，缓存和连接这两部分内容也是两个很重要的点，掌握了这 3 点就说明你理解了OkHttp。</p>
<p>各个拦截器的作用：</p>
<p>interceptors：用户自定义拦截器<br>retryAndFollowUpInterceptor：负责失败重试以及重定向<br>BridgeInterceptor：请求时，对必要的 Header 进行一些添加，接收响应时，移除必要的 Header<br>CacheInterceptor：负责读取缓存直接返回（根据请求的信息和缓存的响 应的信息来判断是否存在缓存可用）、更新缓存<br>ConnectInterceptor：负责和服务器建立连接</p>
<p>ConnectionPool：</p>
<p>1、判断连接是否可用，不可用则从 ConnectionPool 获取连接，ConnectionPool</p>
<p>无连接，创建新连接，握手，放入 ConnectionPool。</p>
<p>2、它是一个 Deque，add 添加 Connection，使用线程池负责定时清理缓存。</p>
<p>3、使用连接复用省去了进行 TCP 和 TLS 握手的一个过程。</p>
<p>networkInterceptors：用户定义网络拦截器</p>
<p>CallServerInterceptor：负责向服务器发送请求数据、从服务器读取响应 数据</p>
<p>你从这个库中学到什么有价值的或者说可借鉴的设计思想？</p>
<p>使用责任链模式实现拦截器的分层设计，每一个拦截器对应一个功能，充分实现 了功能解耦，易维护。</p>
<h4 id="HttpUrlConnection-和-okhttp-关系"><a href="#HttpUrlConnection-和-okhttp-关系" class="headerlink" title="HttpUrlConnection 和 okhttp 关系"></a>HttpUrlConnection 和 okhttp 关系</h4><p>从Android4.4开始HttpURLConnection的底层实现采用的是okHttp。</p>
<h4 id="Volley-与-OkHttp-的对比："><a href="#Volley-与-OkHttp-的对比：" class="headerlink" title="Volley 与 OkHttp 的对比："></a>Volley 与 OkHttp 的对比：</h4><p>Volley：支持 HTTPS。缓存、异步请求，不支持同步请求。协议类型是 Http/1.0, Http/1.1，网络传输使用的是 HttpUrlConnection/HttpClient，数据读写使用的 IO。 OkHttp：支持 HTTPS。缓存、异步请求、同步请求。协议类型是 Http/1.0, Http/1.1, SPDY, Http/2.0, WebSocket，网络传输使用的是封装的 Socket，数据 读写使用的 NIO（Okio）。 SPDY 协议类似于 HTTP，但旨在缩短网页的加载时 间和提高安全性。SPDY 协议通过压缩、多路复用和优先级来缩短加载时间。</p>
<h4 id="衍生问题："><a href="#衍生问题：" class="headerlink" title="衍生问题："></a>衍生问题：</h4><p>自己去设计网络请求框架，怎么做？</p>
<p>从网络加载一个 10M 的图片，说下注意事项？</p>
<p>http怎么知道文件过大是否传输完毕的响应？</p>
<p>谈谈你对 WebSocket 的理解？</p>
<p>WebSocket 与 socket 的区别？</p>
<h3 id="Retrofit-实现原理"><a href="#Retrofit-实现原理" class="headerlink" title="Retrofit 实现原理"></a>Retrofit 实现原理</h3><p>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。Retrofit 2.0 开始内置OkHttp，前者专注于接口的封装，后者专注于网络请求的高效。</p>
<p>为什么要在项目中使用这个库？</p>
<p>1.功能强大：支持同步、异步；支持多种数据的解析 &amp; 序列化格式；支持 RxJava<br>2.简洁易用:通过注解配置网络请求参数;采用大量设计模式简化使用<br>3.可扩展性好:功能模块高度封装;解耦彻底，如自定义 Converters</p>
<p>Retrofit 主要是在 create 方法中采用动态代理模式（通过访问代理对象的方式来间接访问目标对象）实现接口方法，这个过程构建了一个 ServiceMethod 对象， 根据方法注解获取请求方式，参数类型和参数注解拼接请求的链接，当一切都准 备好之后会把数据添加到 Retrofit 的 RequestBuilder 中。然后当我们主动发起网 络请求的时候会调用 okhttp 发起网络请求，okhttp 的配置包括请求方式，URL 等在 Retrofit 的 RequestBuilder 的 build()方法中实现，并发起真正的网络请求。</p>
<p>内部使用了优秀的架构设计和大量的设计模式，在我分析过 Retrofit 最新版的源 码和大量优秀的 Retrofit 源码分析文章后，我发现，要想真正理解 Retrofit 内部 的核心源码流程和设计思想，首先，需要对它使用到的九大设计模式有一定的了 解，下面我简单说一说： </p>
<p>1、创建 Retrofit 实例：使用建造者模式通过内部 Builder 类建立了一个 Retroift 实例。 网络请求工厂使用了工厂方法模式。</p>
<p>2、创建网络请求接口的实例：<br>首先，使用外观模式统一调用创建网络请求接口实例和网络请求参数配置 的方法。 然后，使用动态代理动态地去创建网络请求接口实例。 接着，使用了建造者模式 &amp; 单例模式创建了 serviceMethod 对象。 再者，使用了策略模式对 serviceMethod 对象进行网络请求参数配置，即 通过解析网络请求接口方法的参数、返回值和注解类型，从 Retrofit 对象中获取对应的网络的 url 地址、网络请求执行器、网络请求适配器和数据 转换器。 最后，使用了装饰者模式 ExecuteCallBack 为 serviceMethod 对象加入线 程切换的操作，便于接受数据后通过 Handler 从子线程切换到主线程从而 对返回数据结果进行处理。</p>
<p>3、发送网络请求：<br>在异步请求时，通过静态 delegate 代理对网络请求接口的方法中的每个 参数使用对应的 ParameterHanlder 进行解析。</p>
<p>4、解析数据</p>
<p>5、切换线程：<br>使用了适配器模式通过检测不同的 Platform 使用不同的回调执行器，然 后使用回调执行器切换线程，这里同样是使用了装饰模式。</p>
<p>6、处理结果</p>
<h3 id="Rxjava"><a href="#Rxjava" class="headerlink" title="Rxjava"></a>Rxjava</h3><p>RxJava 变换操作符 map flatMap concatMap buffer</p>
<p>map：【数据类型转换】将被观察者发送的事件转换为另一种类型的事件。<br>flatMap：【化解循环嵌套和接口嵌套】将被观察者发送的事件序列进行 拆分 &amp; 转换 后合并成一个新的事件序列，最后再进行发送。<br>concatMap：【有序】与 flatMap 的 区别在于，拆分 &amp; 重新合并生成 的事件序列 的顺序与被观察者旧序列生产的顺序一致。<br>buffer：定期从被观察者发送的事件中获取一定数量的事件并放到缓存区 中，然后把这些数据集合打包发射。</p>
<h4 id="Rxjava-的线程池与你们自己实现任务管理框架"><a href="#Rxjava-的线程池与你们自己实现任务管理框架" class="headerlink" title="Rxjava 的线程池与你们自己实现任务管理框架?"></a>Rxjava 的线程池与你们自己实现任务管理框架?</h4><h3 id="图片缓存框架：Glide-amp-Fresco"><a href="#图片缓存框架：Glide-amp-Fresco" class="headerlink" title="图片缓存框架：Glide &amp; Fresco"></a>图片缓存框架：Glide &amp; Fresco</h3><h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h4><p>为什么要在项目中使用这个库？<br>1.多样化媒体加载：不仅可以进行图片缓存，还支持 Gif、WebP、缩略图，甚 至是 Video。<br>2.通过设置绑定生命周期：可以使加载图片的生命周期动态管理起来。<br>3.高效的缓存策略：支持内存、Disk 缓存，并且 Picasso 只会缓存原始尺寸的 图片，内 Glide 缓存的是多种规格，也就是 Glide 会根据你 ImageView 的大小来 缓存相应大小的图片尺寸。<br>4.内存开销小：默认的 Bitmap 格式是 RGB_565 格式，而 Picasso 默认的是 ARGB_8888 格式，内存开销小一半。</p>
<p>这个库都有哪些用法？对应什么样的使用场景？<br>1.图片加载Glide.with(this).load(imageUrl).override(800,800).placeholder().error().animate().into()。<br>2.多样式媒体加载：asBitamp、asGif。<br>3.生命周期集成。<br>4.可以配置磁盘缓存策略 ALL、NONE、SOURCE、RESULT。</p>
<p>Glide&amp;with:<br>1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等） 以及 glide 对象。<br>2、将 glide 请求和 application/SupportFragment/Fragment 的生命周期绑定在一块。</p>
<p>Glide&amp;load：<br>设置请求 url，并记录 url 已设置的状态。</p>
<p>Glide&amp;into：<br>1、首先根据转码类 transcodeClass 类型返回不同的 ImageViewTarget：BitmapImageViewTarget、DrawableImageViewTarget。<br>2、递归建立缩略图请求，没有缩略图请求，则直接进行正常请求。<br>3、如果没指定宽高，会根据 ImageView 的宽高计算出图片宽高，最终执行到 onSizeReay()方法中的 engine.load()方法。<br>4、engine 是一个负责加载和管理缓存资源的类</p>
<p>常规三级缓存的流程：强引用-&gt;软引用-&gt;硬盘缓存<br>当我们的APP中想要加载某张图片时，先去LruCache中寻找图片，如果LruCache 中有，则直接取出来使用，如果 LruCache 中没有，则去 SoftReference 中寻找 （软引用适合当 cache，当内存吃紧的时候才会被回收。而 weakReference 在每 次 system.gc（）就会被回收）（当 LruCache 存储紧张时，会把最近最少使用 的数据放到 SoftReference 中），如果 SoftReference 中有，则从 SoftReference 中取出图片使用，同时将图片重新放回到 LruCache 中，如果 SoftReference 中 也没有图片，则去硬盘缓存中中寻找，如果有则取出来使用，同时将图片添加到 LruCache 中，如果没有，则连接网络从网上下载图片。图片下载完成后，将图 片保存到硬盘缓存中，然后放到 LruCache 中。</p>
<p>Glide 缓存机制大致分为三层：内存缓存、弱引用缓存、磁盘缓存。<br>取的顺序是：内存、弱引用、磁盘。<br>存的顺序是：弱引用、内存、磁盘。</p>
<p>三层存储的机制在 Engine 中实现的。先说下 Engine 是什么？Engine 这一层负 责加载时做管理内存缓存的逻辑。持有 MemoryCache、Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;。通过 load（）来加载图片，加载前后 会做内存存储的逻辑。如果内存缓存中没有，那么才会使用 EngineJob 这一层来 进行异步获取硬盘资源或网络资源。EngineJob类似一个异步线程或observable。 Engine 是一个全局唯一的，通过 Glide.getEngine()来获取。</p>
<p>需要一个图片资源，首先先取ActiveResources，activeResources是盛放正在使用的资源，以弱引用的形式存在。同时资源内部有被引用的记录。如果资源没有引用记录了，那么再放回 Lrucache 中，同时从 activeResources 中清除（activeResources开启了一个后台线程专门检测ReferenceQueue）。如果没有，则继续从LruResourceCache中取，取到以后从LruResourceCache删除同时加入ActiveResources中。如果 Lrucache 和 activeResources 中没有，那么进行资源异步请求（网络 /diskLrucache），请求成功后，资源放到 diskLrucache 和 activeResources 中。</p>
<p>缓存：<br>ActiveResources 活跃的内存缓存，使用的是弱引用的方式，用作优化列表反复滑动中Lru频繁清除，然后在重新加载的情况<br>LruResourceCache 内存缓存,不包含正在使用的资源。使用cache.remove(key)从LruResourceCache获取缓存<br>ResourceCacheGenerator:缓存的被加工过的原数据缓存（磁盘)<br>DataCacheGenerator:原文件<br>SourceGenerator:从网络加载数据</p>
<p>Glide源码机制的核心思想：</p>
<p>使用一个弱引用 map activeResources 来盛放项目中正在使用的资源。Lrucache 中不含有正在使用的资源。资源内部有个计数器来显示自己是不是还有被引用的 情况，把正在使用的资源和没有被使用的资源分开有什么好处呢？？因为当 Lrucache 需要移除一个缓存时，会调用 resource.recycle()方法。注意到该方法上 面注释写着只有没有任何 consumer 引用该资源的时候才可以调用这个方法。那 么为什么调用 resource.recycle()方法需要保证该资源没有任何 consumer 引用 呢？glide 中 resource 定义的 recycle（）要做的事情是把这个不用的资源（假设 是 bitmap 或 drawable）放到 bitmapPool 中。bitmapPool 是一个 bitmap 回收 再利用的库，在做 transform 的时候会从这个 bitmapPool 中拿一个 bitmap 进行 再利用。这样就避免了重新创建 bitmap，减少了内存的开支。而既然 bitmapPool 中的 bitmap 会被重复利用，那么肯定要保证回收该资源的时候（即调用资源的 recycle（）时），要保证该资源真的没有外界引用了。这也是为什么 glide 花费 那么多逻辑来保证 Lrucache 中的资源没有外界引用的原因。</p>
<p>相关问题：<br>Glide 如何确定图片加载完毕？<br>Glide 使用什么缓存？<br>Glide 内存缓存如何控制大小？</p>
<h4 id="Fresco"><a href="#Fresco" class="headerlink" title="Fresco"></a>Fresco</h4><p>DraweeView：继承于 ImageView，只是简单的读取 xml 文件的一些属性值和做 一些初始化的工作，图层管理交由 Hierarchy 负责，图层数据获取交由负责。<br>DraweeHierarchy：由多层 Drawable 组成，每层 Drawable 提供某种功能（例如： 缩放、圆角）。 DraweeController：控制数据的获取与图片加载，向 pipeline 发出请求，并接收相应事件，并根据不同事件控制 Hierarchy，从 DraweeView 接收用户的事件，然后执行取消网络请求、回收资源等操作。<br>DraweeHolder： 统筹管理 Hierarchy 与 DraweeHolder。<br>ImagePipeline：Fresco 的核心模块，用 来以各种方式（内存、磁盘、网络等）获取图像。 Producer/Consumer：Producer 也有很多种，它用来完成网络数据获取，缓存数据获取、图片解码等多种工作， 它产生的结果由 Consumer 进行消费。<br>IO/Data：这一层便是数据层了，负责实 现内存缓存、磁盘缓存、网络缓存和其他 IO 相关的功能。</p>
<p>具体实现：<br>GenericDraweeHierarchy：负责 SimpleDraweeView 上的图层管理，由多层 Drawable 组成，每层 Drawable 提供某种功能（例如：缩放、圆角）。</p>
<ol>
<li>背景图（backgroundImage）</li>
<li>占位图（placeholderImage=）</li>
<li>加载的图片（actualImage）</li>
<li>进度条（progressBarImage）</li>
<li>重试加载的图片（retryImage）</li>
<li>失败图片（failureImage）</li>
<li>叠加图（overlayImage）</li>
</ol>
<p>内存缓存：</p>
<p>已解码的内存缓存（BitmapMemoryCache）与未解码的内存缓存（EncodedMemoryCache）区别就是已解码内存缓存的数据是CloseableReference<CloseableBitmap>。而未解码内存缓存的数据是CloseableReference<PooledByteBuffer>。即他们的实现方式一样，区别仅仅在于<strong>资源的测量与释放方式不同</strong>。它们使用ValueDescriptor来描述不同资源的数据大小，使用不同的ResourceReleaser来释放资源。</p>
<p>BitmapMemoryCache（已解码的内存缓存）：BitmapMemoryCacheFactory提供工厂方法获取存储缓存的数据结构。<br>EncodedMemoryCache（未解码的内存缓存）：EncodedCountingMemoryCacheFactory提供工厂方法获取存储缓存的数据结构。</p>
<p>CountingLruMap：Fresco中定义的LRU缓存载体，里面使用了LinkedHashMap作为数据存储载体，但是并没有启用LinkedHashMap的accessOrder功能。同时里面封装了map中的总大小mSizeInBytes，还有各个缓存的大小（ValueDescriptor.getSizeInBytes）。</p>
<p>CountingMemoryCache:具体缓存缓存实现<br>Fresco中实现具体内存缓存的类是CountingMemoryCache，它内部维持着几个重要参数：<br>ExclusiveEntries存储着未被使用的对象的CountingLruMap；<br>CachedEntries存储着所有对象的CountingLruMap；<br>MemoryCacheParams存储着最大缓存对象数量、缓存池大小等参数;<br>PARAMS_INTERCHECK_INTERVAL_MS检查缓存参数变化的事件间隔：5分钟；</p>
<p>它使用一个内部类Entry来封装缓存对象，除了记录缓存键、缓存对象之外，它还记录着该对象的引用数量（clientCount）及是否被缓存追踪（isOrphan）。注意：每个缓存对象只有满足clientCount为0并且isOrphan为true时才可以被释放，可从referenceToClose函数中看出此逻辑。</p>
<p>Fresco使用InstrumentedMemoryCache包装了CountingMemoryCache，主要增加的功能就是提供了MemoryCacheTracker，会在缓存命中或未命中时提供回调函数，供使用者实现自定义功能。</p>
<p>Fresco的缓存调用处：</p>
<p>1.BitmapMemoryCacheProducer：已解码的内存缓存的调用处<br>2.EncodedMemoryCacheProducer：未解码的内存缓存的调用处<br>3.DiskCacheReadProducer：磁盘中未解码的内存缓存的调用处<br>4.NetworkFetchProducer:从网络获取图片的调用处</p>
<p>这里提一点Bitmap缓存：在5.0以下系统，Bitmap缓存位于ashmem，这样Bitmap对象的创建和释放将不会引发GC，更少的GC会使你的APP运行得更加流畅。5.0及其以上系统，相比之下，内存管理有了很大改进，所以Bitmap缓存直接位于Java的heap上。</p>
<h4 id="Fresco-与-Glide-的对比："><a href="#Fresco-与-Glide-的对比：" class="headerlink" title="Fresco 与 Glide 的对比："></a>Fresco 与 Glide 的对比：</h4><p>Glide：相对轻量级，用法简单优雅，支持 Gif 动态图，适合用在那些对图片依赖 不大的 App 中。 Fresco：采用匿名共享内存来保存图片，也就是 Native 堆，有 效的的避免了 OOM，功能强大，但是库体积过大，适合用在对图片依赖比较大 的 App 中。</p>
<h4 id="实现一个-ImageLoader-的流程"><a href="#实现一个-ImageLoader-的流程" class="headerlink" title="实现一个 ImageLoader 的流程"></a>实现一个 ImageLoader 的流程</h4><p>同步异步加载、图片压缩、内存硬盘缓存、网络拉取</p>
<p>1.同步加载只创建一个线程然后按照顺序进行图片加载<br>2.异步加载使用线程池，让存在的加载任务都处于不同线程<br>3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载</p>
<p>具体为：</p>
<p>1、ImageLoader 作为一个单例，提供了加载图片到指定控件的方法：直 接从内存缓存中获取对象，如果没有则用一个 ThreadPoolExecutor 去执 行 Runnable 任务来加载图片。ThreadPoolExecutor 的创建需要指定核心 线程数 CPU 数+1，最大线程数 CPU 数*2+1，线程闲置超市时长 10s,这几 个关键数据，还可以加入 ThreadFactory 参数来创建定制化的线程。<br>2、ImageLoader 的具体实现 loadBitmap：先从内存缓存 LruCache 中加 载，如果为空再从磁盘缓存中加载，加载成功后记得存入内存缓存，如果 为空则从网络中直接下载输出流到磁盘缓存，然后再从磁盘中加载，如果 为 空 并 且 磁 盘 缓 存 没 有 被 创 建 的 话 ， 直 接 通 过 BitmapFactory 的 decodeStream 获取网络请求的输入流获取 Bitmap 对象。<br>3、v4 包的 LruCache 可以兼容到 2.2 版本，LruCache 采用 LinkedHashMap 存储缓存对象。创建对象只需要提供缓存容量并重写 sizeOf 方法：作用 是计算缓存对象的大小。有时需要重写 entryRemoved 方法，用于回收一 些资源。<br>4、DiskLruCache 通过 open 方法创建，设置缓存路径，缓存容量。缓存 添加通过 Editor 对象创建输出流，下载资源到输出流完成后，commit， 如果失败则 abort 撤回。然后刷新磁盘缓存。缓存查找通过 Snapshot 对象获取输入流，获取 FileDescriptor，通过 FileDescriptor 解析出 Bitmap 对象。 5、列表中需要加载图片的时候，当列表在滑动中不进行图片加载，当滑 动停止后再去加载图片。</p>
<h4 id="EventBus（略）"><a href="#EventBus（略）" class="headerlink" title="EventBus（略）"></a>EventBus（略）</h4><h4 id="LeakCanary-实现原理"><a href="#LeakCanary-实现原理" class="headerlink" title="LeakCanary 实现原理"></a>LeakCanary 实现原理</h4><p>为什么要在项目中使用这个库？<br>1.针对 Android Activity 组件完全自动化的内存泄漏检查，在最新的版本中， 还加入了 android.app.fragment 的组件自动化的内存泄漏检测。<br>2.易用集成，使用成本低。<br>3.友好的界面展示和通知。</p>
<p>这个库都有哪些用法？对应什么样的使用场景？</p>
<p>直接从 application 中拿到全局的 refWatcher 对象，在 Fragment 或其他组件的 销毁回调中使用 refWatcher.watch(this)检测是否发生内存泄漏。</p>
<p>这个库的优缺点是什么，跟同类型库的比较？ 检测结果并不是特别的准确，因为内存的释放和对象的生命周期有关也和 GC 的 调度有关。</p>
<p>这个库的核心实现原理是什么？如果让你实现这个库的某些核心功能，你会考虑怎么去实现？<br>主要分为如下 7 个步骤：<br>1、RefWatcher.watch()创建了一个KeyedWeakReference用于去观察对象。<br>2、然后，在后台线程中，它会检测引用是否被清除了，并且是否没有触 发 GC。<br>3、如果引用仍然没有被清除，那么它将会把堆栈信息保存在文件系统中 的.hprof 文件里。<br>4、HeapAnalyzerService 被开启在一个独立的进程中，并且 HeapAnalyzer 使用了 HAHA 开源库解析了指定时刻的堆栈快照文件 heap dump。<br>5、从 heap dump 中， HeapAnalyzer 根据一个独特的引用 key 找到了 KeyedWeakReference，并且定位了泄露的引用。<br>6、HeapAnalyzer 为了确定是否有泄露，计算了到 GC Roots 的最短强引 用路径，然后建立了导致泄露的链式引用。<br>7、这个结果被传回到 app 进程中的 DisplayLeakService，然后一个泄露 通知便展现出来了。<br>简单来说就是： 在一个 Activity 执行完 onDestroy()之后，将它放入 WeakReference 中，然后将 这个 WeakReference 类型的 Activity 对象与 ReferenceQueque 关联。这时再从 ReferenceQueque 中查看是否有该对象，如果没有，执行 gc，再次查看，还是 没有的话则判断发生内存泄露了。最后用 HAHA 这个开源库去分析 dump 之后 的 heap 内存（主要就是创建一个 HprofParser 解析器去解析出对应的引用内存 快照文件 snapshot）。</p>
<p>源码分析中一些核心分析点：</p>
<p>AndroidExcludedRefs：它是一个 enum 类，它声明了 Android SDK 和厂商定制 的 SDK 中存在的内存泄露的 case，根据 AndroidExcludedRefs 这个类的类名就 可看出这些 case 都会被 Leakcanary 的监测过滤掉。</p>
<p>buildAndInstall()（即 install 方法）这个方法应该仅仅只调用一次。</p>
<p>debuggerControl : 判断是否处于调试模式，调试模式中不会进行内存泄漏检测。 为什么呢？因为在调试过程中可能会保留上一个引用从而导致错误信息上报。</p>
<p>watchExecutor : 线程控制器，在 onDestroy() 之后并且主线程空闲时执行内存 泄漏检测。</p>
<p>gcTrigger : 用于 GC，watchExecutor 首次检测到可能的内存泄漏，会主动进行 GC，GC 之后会再检测一次，仍然泄漏的判定为内存泄漏，最后根据 heapDump 信息生成相应的泄漏引用链。</p>
<p>gcTrigger 的 runGc()方法：这里并没有使用 System.gc()方法进行回收，因为 system.gc()并不会每次都执行。而是从 AOSP 中拷贝一段 GC 回收的代码，从而 相比 System.gc()更能够保证进行垃圾回收的工作。</p>
<p>Runtime.getRuntime().gc();</p>
<p>子线程延时 1000ms； System.runFinalization();</p>
<p>install 方法内部最终还是调用了 application 的 registerActivityLifecycleCallbacks()方法，这样就能够监听 activity 对应的生命周 期事件了。 在 RefWatcher#watch()中使用随机的 UUID 保证了每个检测对象对应的 key 的 唯一性。 在 KeyedWeakReference 内部，使用了 key 和 name 标识了一个被检测的 WeakReference 对象。在其构造方法中将弱引用和引用队列 ReferenceQueue 关联起来，如果弱引用 reference 持有的对象被 GC 回收，JVM 就会把这个弱引 用加入到与之关联的引用队列 referenceQueue 中。即 KeyedWeakReference 持 有的 Activity 对象如果被 GC 回收，该对象就会加入到引用队列 referenceQueue 中。</p>
<p>使用 Android SDK 的 API Debug.dumpHprofData() 来生成 hprof 文件。</p>
<p>在 HeapAnalyzerService（类型为 IntentService 的 ForegroundService）的 runAnalysis()方法中，为了避免减慢 app 进程或占用内存，这里将 HeapAnalyzerService 设置在了一个独立的进程中。</p>
<p>leakCannary中如何判断一个对象是否被回收？如何触发手动gc？c层实现？</p>
<h3 id="BlockCanary"><a href="#BlockCanary" class="headerlink" title="BlockCanary"></a>BlockCanary</h3><p>该组件利用了主线程的消息队列处理机制，应用发生卡顿，一定是在 dispatchMessage 中执行了耗时操作。我们通过给主线程的 Looper 设置一个 Printer，打点统计 dispatchMessage 方法执行的时间，如果超出阀值，表示发生 卡顿，则 dump 出各种信息，提供开发者分析性能瓶颈。</p>
<h3 id="ButterKnife-实现原理"><a href="#ButterKnife-实现原理" class="headerlink" title="ButterKnife 实现原理"></a>ButterKnife 实现原理</h3><p>ButterKnife 对性能的影响很小，因为没有使用使用反射，而是使用的 Annotation Processing Tool(APT)，注解处理器，javac 中用于编译时扫描和解析 Java 注解的 工具。在编译阶段执行的，它的原理就是读入 Java 源代码，解析注解，然后生 成新的 Java 代码。新生成的 Java 代码最后被编译成 Java 字节码，注解解析器不 能改变读入的 Java 类，比如不能加入或删除 Java 方法。</p>
<h3 id="热修复和插件化"><a href="#热修复和插件化" class="headerlink" title="热修复和插件化"></a>热修复和插件化</h3><p>插件化：动态加载主要解决 3 个技术问题：<br>1、使用 ClassLoader 加载类。<br>2、资源访问。<br>3、生命周期管理。</p>
<p>插件化是体现在功能拆分方面的，它将某个功能独立提取出来，独立开发，独立 测试，再插入到主应用中。以此来减少主应用的规模。</p>
<p>热修复：<br>代码热修复原理：<br>1.将编译好的 class 文件拆分打包成两个 dex，绕过 dex 方法数量的限制以 及安装时的检查，在运行时再动态加载第二个 dex 文件中。<br>2.热修复是体现在 bug 修复方面的，它实现的是不需要重新发版和重新安 装，就可以去修复已知的 bug。<br>3.利用 PathClassLoader 和 DexClassLoader 去加载与 bug 类同名的类，替 换掉 bug 类，进而达到修复 bug 的目的，原理是在 app 打包的时候阻止 类打上 CLASS_ISPREVERIFIED 标志， 然后在热修复的时候动态改变 BaseDexClassLoader 对象间接引用的 dexElements，替换掉旧的类。</p>
<p>相同点:都使用 ClassLoader 来实现加载新的功能类，都可以使用 PathClassLoader 与 DexClassLoader。<br>不同点：热修复因为是为了修复 Bug 的，所以要将新的类替代同名的 Bug 类，要抢先加 载新的类而不是 Bug 类，所以多做两件事：在原先的 app 打包的时候，阻止相 关类去打上 CLASS_ISPREVERIFIED 标志，还有在热修复时动态改变 BaseDexClassLoader 对象间接引用的 dexElements，这样才能抢先代替 Bug 类， 完成系统不加载旧的 Bug 类.。 而插件化只是增加新的功能类或者是资源文件， 所以不涉及抢先加载新的类这样的使命，就避过了阻止相关类去打上 CLASS_ISPREVERIFIED 标志和还有在热修复时动态改变 BaseDexClassLoader 对 象间接引用的 dexElements.<br>所以插件化比热修复简单，热修复是在插件化的基础上在进行替换旧的 Bug 类。</p>
<p>热修复原理：<br>资源修复：很多热修复框架的资源修复参考了 Instant Run 的资源修复的原理。传统编译部署流程如下：<br>Instant Run 编译部署流程如下：</p>
<ul>
<li>Hot Swap：修改一个现有方法中的代码时会采用 Hot Swap。</li>
<li>Warm Swap：修改或删除一个现有的资源文件时会采用 Warm Swap。</li>
<li>Cold Swap：有很多情况，如添加、删除或修改一个字段和方法、添加一 个类等。</li>
</ul>
<p>Instant Run 中的资源热修复流程：<br>1、创建新的 AssetManager，通过反射调用 addAssetPath 方法加载外部 的资源，这样新创建的 AssetManager 就含有了外部资源。<br>2、将 AssetManager 类型的 mAssets 字段的引用全部替换为新创建的 AssetManager。</p>
<p>代码修复：<br>1、类加载方案：<br>根据 dex 文件的查找流程，我们将有 Bug 的类 Key.class 进行修改，再将 Key.class 打 包 成 包 含 dex 的 补 丁 包 Patch.jar ， 放 在 Element 数 组 dexElements 的第一个元素，这样会首先找到 Patch.dex 中的 Key.class 去 替换之前存在 Bug 的 Key.class，排在数组后面的 dex 文件中存在 Bug 的 Key.class 根据 ClassLoader 的双亲委托模式就不会被加载。<br>类加载方案需要重启 App 后让 ClassLoader 重新加载新的类，为什么需要重启 呢？<br>这是因为类是无法被卸载的，要想重新加载新的类就需要重启 App，因此 采用类加载方案的热修复框架是不能即时生效的。</p>
<p>各个热修复框架的实现细节差异：</p>
<ul>
<li>QQ 空间的超级补丁和 Nuwa 是按照上面说的将补丁包放在 Element 数组 的第一个元素得到优先加载。</li>
<li>微信的 Tinker 将新旧 APK 做了 diff，得到 path.dex，再将 patch.dex 与手 机中 APK 的 classes.dex 做合并，生成新的 classes.dex，然后在运行时通 过反射将 classes.dex 放在 Elements 数组的第一个元素。</li>
<li>饿了么的 Amigo 则是将补丁包中每个 dex 对应的 Elements 取出来，之后 组成新的 Element 数组，在运行时通过反射用新的 Elements 数组替换掉 现有的 Elements 数组。</li>
</ul>
<p>2、底层替换方案：<br>当我们要反射 Key 的 show 方法，会调用 Key.class.getDeclaredMethod(“show”).invoke(Key.class.newInstance());，最终会 在 native 层将传入的 javaMethod 在 ART 虚拟机中对应一个 ArtMethod 指针， ArtMethod 结构体中包含了 Java 方法的所有信息，包括执行入口、访问权限、 所属类和代码执行地址等。</p>
<p>替换 ArtMethod 结构体中的字段或者替换整个 ArtMethod 结构体，这就是底层 替换方案。</p>
<p>AndFix 采用的是替换 ArtMethod 结构体中的字段，这样会有兼容性问题，因为 厂商可能会修改 ArtMethod 结构体，导致方法替换失败。</p>
<p>Sophix 采用的是替换整个 ArtMethod 结构体，这样不会存在兼容问题。 底层替换方案直接替换了方法，可以立即生效不需要重启。采用底层替换方案主 要是阿里系为主，包括 AndFix、Dexposed、阿里百川、Sophix。</p>
<p>3、Instant Run 方案：<br>什么是 ASM？ ASM 是一个 java 字节码操控框架，它能够动态生成类或者增强现有类的功能。 ASM 可以直接产生 class 文件，也可以在类被加载到虚拟机之前动态改变类的行 为。 Instant Run 在第一次构建 APK 时，使用 ASM 在每一个方法中注入了类似的代 码逻辑：当$change 不为 null 时，则调用它的 access$dispatch 方法，参数为具 体的方法名和方法参数。当 MainActivity 的 onCreate 方法做了修改，就会生成 替换类 MainActivity$override，这个类实现了 IncrementalChange 接口，同时也 会生成一个 AppPatchesLoaderImpl 类，这个类的 getPatchedClasses 方法会返 回被修改的类的列表（里面包含了 MainActivity），根据列表会将 MainActivity 的$change 设置为 MainActivity$override。最后这个$change 就不会为 null，则 会执行 MainActivity$override 的 access$dispatch 方法，最终会执行 onCreate 方法，从而实现了 onCreate 方法的修改。<br>借鉴 Instant Run 原理的热修复框架有 Robust 和 Aceso。</p>
<p>动态链接库修复：<br>重新加载 so。</p>
<p>加载 so 主要用到了 System 类的 load 和 loadLibrary 方法，最终都会调用到 nativeLoad 方法。其会调用 JavaVMExt 的 LoadNativeLibrary 函数来加载 so。<br>so 修复主要有两个方案：<br>1、将 so 补丁插入到 NativeLibraryElement 数组的前部，让 so 补丁的路 径先被返回和加载。<br>2、调用 System 的 load 方法来接管 so 的加载入口。</p>
<p>为什么选用插件化？</p>
<h3 id="项目中遇到哪些难题，最终你是如何解决的？"><a href="#项目中遇到哪些难题，最终你是如何解决的？" class="headerlink" title="项目中遇到哪些难题，最终你是如何解决的？"></a>项目中遇到哪些难题，最终你是如何解决的？</h3><h2 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Summer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://skyskiper.github.io/2021/Android%E5%B0%8F%E6%8A%84/">https://skyskiper.github.io/2021/Android%E5%B0%8F%E6%8A%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://skyskiper.github.io">阿七笔记</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/Android%E7%83%AD%E9%A2%98%E7%AD%94%E6%A1%88/"><span>Android热题答案</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Summer</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>