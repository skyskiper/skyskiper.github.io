<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android小抄"><meta name="keywords" content=""><meta name="author" content="Summer"><meta name="copyright" content="Summer"><title>Android小抄 | 阿七笔记</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.1.1'
} </script><meta name="generator" content="Hexo 5.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">1. Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collecttion"><span class="toc-number">1.3.</span> <span class="toc-text">Collecttion</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-1-7-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">HashMap 1.7 的原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-1-8-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">HashMap 1.8 的原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-1-7-%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.3.3.</span> <span class="toc-text">ConcurrentHashMap 1.7 原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-1-8-%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.3.4.</span> <span class="toc-text">ConcurrentHashMap 1.8 原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">1.3.5.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">1.4.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%EF%BC%8Cfinally%EF%BC%8Cfinalize"><span class="toc-number">1.5.</span> <span class="toc-text">final，finally，finalize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E3%80%81volatile%E3%80%81Lock-ReentrantLock"><span class="toc-number">1.6.</span> <span class="toc-text">Synchronized、volatile、Lock(ReentrantLock)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait%E3%80%81sleep-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.1.</span> <span class="toc-text">wait、sleep 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">1.7.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">1.8.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-number">1.9.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.11.</span> <span class="toc-text">静态代理和动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E7%BD%AE%E4%B8%BA-null%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">强引用置为 null，会不会被回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">1.13.</span> <span class="toc-text">软引用和弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.14.</span> <span class="toc-text">JVM 内存区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">1.15.</span> <span class="toc-text">GC 的原理和回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.16.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E8%B7%9F-Art%E3%80%81Dalvik-%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">JVM 跟 Art、Dalvik 对比？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jvm%E8%B0%83%E4%BC%98"><span class="toc-number">1.18.</span> <span class="toc-text">Jvm调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-HTTPS"><span class="toc-number">1.19.</span> <span class="toc-text">HTTP&#x2F;HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Http1-1-%E5%92%8C-Http1-0-%E5%8F%8A-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.19.1.</span> <span class="toc-text">Http1.1 和 Http1.0 及 2.0 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-UDP"><span class="toc-number">1.20.</span> <span class="toc-text">TCP&#x2F;UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.20.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.20.2.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="toc-number">1.20.3.</span> <span class="toc-text">TCP 可靠传输原理实现（滑动窗口）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tcp-%E5%92%8C-Udp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.20.4.</span> <span class="toc-text">Tcp 和 Udp 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket"><span class="toc-number">1.20.5.</span> <span class="toc-text">Socket</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Android"><span class="toc-number">2.</span> <span class="toc-text">2. Android</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-%E4%B8%AD-ClassLoader"><span class="toc-number">2.1.</span> <span class="toc-text">Android 中 ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LruCache%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">LruCache原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%8ESparseArray"><span class="toc-number">2.3.</span> <span class="toc-text">HashMap与SparseArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LaunchMode"><span class="toc-number">2.4.</span> <span class="toc-text">LaunchMode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-Service-%E4%B8%8D%E8%A2%AB%E6%9D%80%E6%AD%BB%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">如何保证 Service 不被杀死？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%B4%BB%E6%96%B9%E6%A1%88"><span class="toc-number">2.6.</span> <span class="toc-text">保活方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity-Window-View-%E4%B8%89%E8%80%85%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">Activity-Window-View 三者的差别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SurfaceView"><span class="toc-number">2.8.</span> <span class="toc-text">SurfaceView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ListView-amp-RecyclerView"><span class="toc-number">2.9.</span> <span class="toc-text">ListView &amp; RecyclerView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebView"><span class="toc-number">2.10.</span> <span class="toc-text">WebView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerThread%E3%80%81IntentService"><span class="toc-number">2.11.</span> <span class="toc-text">HandlerThread、IntentService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HandlerThread"><span class="toc-number">2.11.1.</span> <span class="toc-text">HandlerThread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntentService"><span class="toc-number">2.11.2.</span> <span class="toc-text">IntentService</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ContentProvider%E3%80%81ContentResolver%E3%80%81ContentObserver-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">ContentProvider、ContentResolver、ContentObserver 之间的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#activty-%E5%92%8C-Fragmengt-%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">activty 和 Fragmengt 之间怎么通信？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">2.14.</span> <span class="toc-text">内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Traceview"><span class="toc-number">2.14.1.</span> <span class="toc-text">Traceview</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ANR%EF%BC%9F-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AE%83%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">什么是 ANR？ 如何避免它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#android-%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">android 中进程的优先级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AsyncTask%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.17.</span> <span class="toc-text">AsyncTask与线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serializable%E4%B8%8EParcelable%EF%BC%9F"><span class="toc-number">2.18.</span> <span class="toc-text">Serializable与Parcelable？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap-%E4%BD%BF%E7%94%A8%E6%97%B6%E5%80%99%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="toc-number">2.19.</span> <span class="toc-text">Bitmap 使用时候注意什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="toc-number">2.19.1.</span> <span class="toc-text">Bitmap 占用内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%A7%E5%9B%BE%EF%BC%8C%E5%A6%82%E4%B8%80%E5%BC%A0-30M-%E7%9A%84%E5%A4%A7%E5%9B%BE%EF%BC%8C%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2-OOM"><span class="toc-number">2.19.2.</span> <span class="toc-text">Bitmap 如何处理大图，如一张 30M 的大图，如何预防 OOM?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.19.3.</span> <span class="toc-text">Bitmap 对象的理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E4%BC%A0%E8%BE%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E6%9C%89%E9%99%90%E5%88%B6%EF%BC%8C%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">2.20.</span> <span class="toc-text">广播传输的数据是否有限制，是多少，为什么要限制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90"><span class="toc-number">2.21.</span> <span class="toc-text">Android 程序运行时权限与文件系统权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVP%E3%80%81MVVM%E3%80%81MVC"><span class="toc-number">2.22.</span> <span class="toc-text">MVP、MVVM、MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC"><span class="toc-number">2.22.1.</span> <span class="toc-text">MVC:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVP"><span class="toc-number">2.22.2.</span> <span class="toc-text">MVP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVM"><span class="toc-number">2.22.3.</span> <span class="toc-text">MVVM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E4%BA%86%E8%A7%A3%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%EF%BC%9F"><span class="toc-number">2.23.</span> <span class="toc-text">是否了解硬件加速？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context"><span class="toc-number">2.24.</span> <span class="toc-text">Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%EF%BC%9F%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.25.</span> <span class="toc-text">View 的事件分发机制？滑动冲突怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View-%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">2.26.</span> <span class="toc-text">View 的绘制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE-MeasureSpec-%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%80%91%E5%B8%83%E6%B5%81%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89-ViewGroup%EF%BC%9F"><span class="toc-number">2.26.1.</span> <span class="toc-text">如何根据 MeasureSpec 去实现一个瀑布流的自定义 ViewGroup？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E4%B9%8B-Measure"><span class="toc-number">2.26.2.</span> <span class="toc-text">View 绘制流程之 Measure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E4%B9%8B-Layout"><span class="toc-number">2.26.3.</span> <span class="toc-text">View 的绘制流程之 Layout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E4%B9%8B-Draw"><span class="toc-number">2.26.4.</span> <span class="toc-text">View 的绘制流程之 Draw</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setWillNotDraw-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.26.5.</span> <span class="toc-text">setWillNotDraw 的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.27.</span> <span class="toc-text">Handler源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C%E6%B6%88%E6%81%AF"><span class="toc-number">2.27.0.1.</span> <span class="toc-text">屏障消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binder"><span class="toc-number">2.28.</span> <span class="toc-text">Binder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMS%E8%A7%A3%E6%9E%90"><span class="toc-number">2.29.</span> <span class="toc-text">AMS解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Window-%E5%92%8C-WindowManager"><span class="toc-number">2.30.</span> <span class="toc-text">Window 和 WindowManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.31.</span> <span class="toc-text">Android系统的启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APK%E5%AE%89%E8%A3%85"><span class="toc-number">2.32.</span> <span class="toc-text">APK安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B"><span class="toc-number">2.33.</span> <span class="toc-text">打包流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D"><span class="toc-number">2.34.</span> <span class="toc-text">签名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v1%E7%AD%BE%E5%90%8D"><span class="toc-number">2.34.1.</span> <span class="toc-text">v1签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V2%E7%AD%BE%E5%90%8D%EF%BC%88Android-7-0%EF%BC%89"><span class="toc-number">2.34.2.</span> <span class="toc-text">V2签名（Android 7.0）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V3%E7%AD%BE%E5%90%8D%EF%BC%88Android-9-0%EF%BC%89"><span class="toc-number">2.34.3.</span> <span class="toc-text">V3签名（Android 9.0）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">2.35.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Davilk%E3%80%81ART%E5%8C%BA%E5%88%AB"><span class="toc-number">2.36.</span> <span class="toc-text">Davilk、ART区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART-%E5%92%8C-Davlik-%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.37.</span> <span class="toc-text">ART 和 Davlik 中垃圾回收的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%8D%93%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.38.</span> <span class="toc-text">安卓内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#App-%E6%98%AF%E5%A6%82%E4%BD%95%E6%B2%99%E7%AE%B1%E5%8C%96"><span class="toc-number">2.39.</span> <span class="toc-text">App 是如何沙箱化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.</span> <span class="toc-text">3. 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%9B%B4%E6%96%B0"><span class="toc-number">3.1.</span> <span class="toc-text">应用更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OkHttp-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">OkHttp 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpUrlConnection-%E5%92%8C-okhttp-%E5%85%B3%E7%B3%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">HttpUrlConnection 和 okhttp 关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Volley-%E4%B8%8E-OkHttp-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">Volley 与 OkHttp 的对比：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.2.3.</span> <span class="toc-text">衍生问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Retrofit-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">Retrofit 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rxjava"><span class="toc-number">3.4.</span> <span class="toc-text">Rxjava</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rxjava-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E4%BD%A0%E4%BB%AC%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">Rxjava 的线程池与你们自己实现任务管理框架?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%EF%BC%9AGlide-amp-Fresco"><span class="toc-number">3.5.</span> <span class="toc-text">图片缓存框架：Glide &amp; Fresco</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Glide"><span class="toc-number">3.5.1.</span> <span class="toc-text">Glide</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco"><span class="toc-number">3.5.2.</span> <span class="toc-text">Fresco</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fresco-%E4%B8%8E-Glide-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">3.5.3.</span> <span class="toc-text">Fresco 与 Glide 的对比：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-ImageLoader-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.5.4.</span> <span class="toc-text">实现一个 ImageLoader 的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-number">3.5.5.</span> <span class="toc-text">EventBus（略）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LeakCanary-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.6.</span> <span class="toc-text">LeakCanary 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockCanary"><span class="toc-number">3.6.</span> <span class="toc-text">BlockCanary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ButterKnife-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.7.</span> <span class="toc-text">ButterKnife 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%92%8C%E6%8F%92%E4%BB%B6%E5%8C%96"><span class="toc-number">3.8.</span> <span class="toc-text">热修复和插件化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%EF%BC%9A"><span class="toc-number">3.8.1.</span> <span class="toc-text">热修复：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E5%8C%96"><span class="toc-number">3.8.2.</span> <span class="toc-text">插件化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-number">3.9.</span> <span class="toc-text">模块化和组件化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gradle"><span class="toc-number">3.10.</span> <span class="toc-text">gradle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E9%9A%BE%E9%A2%98%EF%BC%8C%E6%9C%80%E7%BB%88%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">项目中遇到哪些难题，最终你是如何解决的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.12.</span> <span class="toc-text">其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E7%BB%99%E6%9D%83%E9%99%90%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%EF%BC%8C%E7%89%B9%E5%AE%9A%E6%9C%BA%E5%9E%8B%E5%AE%9A%E4%BD%8D%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">3.12.1.</span> <span class="toc-text">没有给权限如何定位，特定机型定位失败，如何解决?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%EF%BC%8C%E8%83%BD%E4%B8%8D%E8%83%BD%E8%87%AA%E5%B7%B1%E5%88%86%E9%85%8D%E5%AE%9A%E9%A2%9D%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">3.12.2.</span> <span class="toc-text">Android 中进程内存的分配，能不能自己分配定额内存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E-UI-%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%96%B0-UI-%E5%90%97"><span class="toc-number">3.12.3.</span> <span class="toc-text">非 UI 线程可以更新 UI 吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%9C%89%E6%B2%A1%E6%9C%89%E5%81%9A%E8%BF%87%EF%BC%8C%E8%AF%B4%E8%AF%B4%E7%86%9F%E6%82%89%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">3.12.4.</span> <span class="toc-text">单元测试有没有做过，说说熟悉的单元测试框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E5%BA%94%E7%94%A8%E3%80%81react-native%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AD%89%E5%8C%BA%E5%88%AB"><span class="toc-number">3.12.5.</span> <span class="toc-text">快应用、react native、小程序等区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4. 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E9%A2%91%E9%A2%98%E9%9B%86"><span class="toc-number">4.0.1.</span> <span class="toc-text">高频题集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AC%A1%E9%AB%98%E9%A2%91%E9%A2%98%E9%9B%86"><span class="toc-number">4.0.2.</span> <span class="toc-text">次高频题集</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Summer</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">82</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">阿七笔记</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/menu">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android小抄</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-01</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1. Java基础"></a>1. Java基础</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象的三大特性：封装、继承、多态。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>Java 中一般认为有 23 种设计模式，我们不需要所有的都会，但是其中常用 的种设计模式应该去掌握。下面列出了所有的设计模式。要掌握的设计模式我单 独列出来了，当然能掌握的越多越好。 总体来说设计模式分为三大类： </p>
<ul>
<li>创建型模式，共五种： 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 </li>
<li>结构型模式，共七种： 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模 式。 </li>
<li>行为型模式，共十一种： 策略模式、模板方法模式、观者模式、迭代子模式、责任链模式、命令模式、备 忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<p>简单工厂、工厂方法、抽象工厂、Builder 模式的区别？<br>简单工厂模式：一个工厂方法创建不同类型的对象。<br>工厂方法模式：一个具体的工厂类负责创建一个具体对象类型。<br>抽象工厂模式：一个具体的工厂类负责创建一系列相关的对象。<br>Builder 模式：对象的构建与表示分离，它更注重对象的创建过程。</p>
<p>装饰模式和代理模式有哪些区别 ？与桥接模式相比呢<br>1、装饰模式是以客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；而代理模式则是给一个对象提供一个代理对象，并由代理对象 来控制对原有对象的引用。<br>2、装饰模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增加。<br>3、桥接模式的作用于代理、装饰截然不同，它主要是为了应对某个类族有多个变化维度导致子类类型急剧增多的场景。通过桥接模式将多个变化 维度隔离开，使得它们可以独立地变化，最后通过组合使它们应对多维变 化，减少子类的数量和复杂度。</p>
<p>外观模式和中介模式的区别？<br>外观模式重点是对外封装统一的高层接口，便于用户使用；而中介模式则是避免 多个互相协作的对象直接引用，它们之间的交互通过一个中介对象进行，从而使 得它们耦合松散，能够易于应对变化。</p>
<p>策略模式和状态模式的区别？<br>虽然两者的类型结构是一致的，但是它们的本质却是不一样的。策略模式重在整 个算法的替换，也就是策略的替换，而状态模式则是通过状态来改变行为。</p>
<p>适配器模式，装饰者模式，外观模式的异同？<br>这三个模式的相同之处是，它们都作用于用户与真实被使用的类或系统之间，作 一个中间层，起到了让用户间接地调用真实的类的作用。它们的不同之外在于， 如上所述的应用场合不同和本质的思想不同。</p>
<p>代理与外观的主要区别在于，代理对象代表一个单一对象，而外观对象代表一个 子系统，代理的客户对象无法直接访问对象，由代理提供单独的目标对象的访问， 而通常外观对象提供对子系统各元件功能的简化的共同层次的调用接口。代理是 一种原来对象的代表，其它需要与这个对象打交道的操作都是和这个代表交涉的。而适配器则不需要虚构出一个代表者，只需要为应付特定使用目的，将原来 的类进行一些组合。</p>
<p>外观与适配器都是对现存系统的封装。外观定义的新的接口，而适配器则是复用 一个原有的接口，适配器是使两个已有的接口协同工作，而外观则是为现存系统 提供一个更为方便的访问接口。如果硬要说外观是适配，那么适配器有用来适配 对象的，而外观是用来适配整个子系统的。也就是说，外观所针对的对象的粒度 更大。</p>
<p>代理模式提供与真实的类一致的接口，意在用代理类来处理真实的类，实现一些特定的服务或真实类的部分功能，Facade（外观）模式注重简化接口，Adapter（适配器）模式注重转换接口。</p>
<p>Android的设计模式<br>AlertDialog、Notification 源码中使用了 Bulider（建造者）模式完成参数的初始化；<br>Okhttp 内部使用了责任链模式来完成每个 Interceptor 拦截器的调用；<br>RxJava、ListView、RecyclerView 的观察者模式；<br>ListView/RecyclerView/GridView的适配器模式；<br>Context/ContextImpl 外观模式；</p>
<p>重构的时候：<br>1、代码重复：代码重复几乎是最常见的异味了。他也是 Refactoring 的主要目标之一。代码重复往往来自于 copy-and-paste 的编程风格。<br>2、方法过长：一个方法应当具有自我独立的意图，不要把几个意图放在一起。<br>3、类提供的功能太多：把太多的责任交给了一个类，一个类应该仅提供一个单一的功能。<br>4、数据泥团：某些数据通常像孩子一样成群玩耍：一起出现在很多类的成员变量中，一起出现在许多方法的参数中…..，这些数据或许应该自己独立形成对象。 比如以单例的形式对外提供自己的实例。<br>5、冗赘类：一个干活不多的类。类的维护需要额外的开销，如果一个类承担了太少的责任， 应当消除它。<br>6、需要太多注释：经常觉得要写很多注释表示你的代码难以理解。如果这种感觉太多，表示你需要 Refactoring。</p>
<h3 id="Collecttion"><a href="#Collecttion" class="headerlink" title="Collecttion"></a>Collecttion</h3><p>ArrayList 和 LinkedList 怎么动态扩容的吗？<br>ArrayList 初始化大小是 10 （如果你知道你的 arrayList 会达到多少容量，可以 在初始化的时候就指定，能节省扩容的性能开支） 扩容点规则是，新增的时候 发现容量不够用了，就去扩容 扩容大小规则是，扩容后的大小= 原始大小+原始大小/2 + 1。（例如：原始大小是 10 ，扩容后的大小就是 10 + 5+1 = 16）</p>
<h4 id="HashMap-1-7-的原理："><a href="#HashMap-1-7-的原理：" class="headerlink" title="HashMap 1.7 的原理："></a>HashMap 1.7 的原理：</h4><p>HashMap 底层是基于 数组 + 链表 组成的，不过在 jdk1.7 和 1.8 中具体实 现稍有不同。<br>负载因子：给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往 里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量 进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常 消耗性能。因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来 的性能损耗。</p>
<h4 id="HashMap-1-8-的原理："><a href="#HashMap-1-8-的原理：" class="headerlink" title="HashMap 1.8 的原理："></a>HashMap 1.8 的原理：</h4><p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效 率就会越来越低；时间复杂度为 O(N)，因此 1.8 中重点优化了这个查询效率。TREEIFY_THRESHOLD 用于判断是否需要将链表转换为红黑树的阈值。<br>修改为红黑树之后查询效率直接提高到了 O(logn)。但是 HashMap 原有的问题 也都存在，比如在并发场景下使用时容易出现死循环：<br>在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容 易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出 的 index 正好是环形链表的下标就会出现死循环：在 1.7 中 hash 冲突 采用的头插法形成的链表，在并发条件下会形成循环链表，一旦有查询落 到了这个链表上，当获取不到值时就会死循环。</p>
<h4 id="ConcurrentHashMap-1-7-原理："><a href="#ConcurrentHashMap-1-7-原理：" class="headerlink" title="ConcurrentHashMap 1.7 原理："></a>ConcurrentHashMap 1.7 原理：</h4><p>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同 步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量) 的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。<br>put 方法:首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。<br>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保 证并发的原子性，所以 put 操作时仍然需要加锁处理。 首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞 争，则利用 scanAndLockForPut() 自旋获取锁:<br>尝试自旋获取锁。 如果重试的次数达到了 MAX_SCAN_RETRIES 则改为 阻塞锁获取，保证能获取成功。<br>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是 否相等，相等则覆盖旧的 value。为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断 是否需要扩容。最后会使用 unlock()解除当前 Segment 的锁。<br>get 方法：只需要将 Key 通过 Hash 之后定位到具体的 Segment ， 再通过一次 Hash 定位到具体的元素上。由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内 存可见性，所以每次获取时都是最新值。ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要 加锁。</p>
<h4 id="ConcurrentHashMap-1-8-原理："><a href="#ConcurrentHashMap-1-8-原理：" class="headerlink" title="ConcurrentHashMap 1.8 原理："></a>ConcurrentHashMap 1.8 原理：</h4><p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但 依然存在 HashMap 在 1.7 版本中的问题：那就是查询遍历链表效率太低。和1.8 HashMap 结构类似：其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p>
<p>AtomicStampedReference：解 决 ABA 问题。这个类的 compareAndSet 方法作用是首先检查当前引用是 否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以 原子方式将该引用和该标志的值设置为给定的更新值。如果 CAS 不成功，则会原地自旋，如果长时间自旋会给 CPU 带来非常大 的执行开销。</p>
<p>put 方法：</p>
<ul>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li>如果当前 key 定位出的 Node 为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>最后，如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</li>
</ul>
<p>get 方法：</p>
<ul>
<li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li>
<li>如果是红黑树那就按照树的方式获取值。</li>
<li>就不满足那就按照链表的方式遍历获取值。</li>
</ul>
<p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率 （O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出 在新版的 JDK 中对 synchronized 优化是很到位的。</p>
<p>HashMap 何时扩容：<br>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值–即大于当前数组的长度乘以加载因子的值的时候，就要自动扩容。</p>
<p>扩容的算法是什么：<br>扩容(resize)就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度， 以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法是使用一 个新的数组代替已有的容量小的数组。</p>
<p>ArrayMap、SparseArray<br>SparseArray 比 HashMap 更省内存，在某些条件下性能更好，主要是因为它避 免了对 key 的自动装箱（int 转为 Integer 类型），它内部则是通过两个数组来进 行数据存储的，一个存储 key，另外一个存储 value，为了优化性能，它内部对 数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源 码中可以看到 key 和 value 分别是用数组表示；同时，SparseArray 在存储和读取数据时候，使用的是二分查找法。也就是在 put 添加数据的时候，会使用二分查找法和之前的 key 比较当前我们添加的元素的 key 的大小，然后按照从小到大的顺序排列好，所以，SparseArray 存储的元素 都是按元素的 key 值从小到大排列好的。 而在获取数据的时候，也是使用二分 查找法判断元素的位置，所以，在获取数据的时候非常快，比 HashMap 快的多。</p>
<p>ArrayMap:<br>ArrayMap 利用两个数组，mHashes 用来保存每一个 key 的 hash 值，mArrray 大小为 mHashes 的 2 倍，依次保存 key 和 value。当插入时，根据 key 的 hashcode()方法得到 hash 值，计算出在 mArrays 的 index 位置，然后利用二分查找找到对应的位置进行插入，当出现哈希冲突时，会在 index 的相邻位置插入。</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>Copy-On-Write 是什么？<br>在计算机中就是当你想要对一块内存进行修改时，我们不在原有内存块中进行写 操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向 原来内存指针指向新的内存，原来的内存就可以被回收掉。</p>
<p>原理：<br>CopyOnWriteArrayList 这是一个 ArrayList 的线程安全的变体，CopyOnWriteArrayList 底层实现添加的原理是先 copy 出一个容器(可以简称副 本)，再往新的容器里添加这个新的数据，最后把新的容器的引用地址赋值给了 之前那个旧的的容器地址，但是在添加这个数据的期间，其他线程如果要去读取 数据，仍然是读取到旧的容器里的数据。</p>
<p>优点:<br>1.数据一致性完整，为什么？因为加锁了，并发数据不会乱<br>2.解决了像 ArrayList、Vector 这种集合多线程遍历迭代问题，记住，Vector 虽然 线程安全，只不过是加了 synchronized 关键字，迭代问题完全没有解决！</p>
<p>缺点:<br>1.内存占有问题:很明显，两个数组同时驻扎在内存中，如果实际应用中，数据比 较多，而且比较大的情况下，占用内存会比较大，针对这个其实可以用 ConcurrentHashMap 来代替。<br>2.数据一致性:CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的 实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。</p>
<p>使用场景：<br>1、读多写少（白名单，黑名单，商品类目的访问和更新场景），为什么？因为 写的时候会复制新集合。<br>2、集合不大，为什么？因为写的时候会复制新集合。<br>3、实时性要求不高，为什么，因为有可能会读取到旧的集合数据。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>Java char 不存 UTF-8 的字节，而是 UTF-16。</li>
<li>Unicode 通用字符集占两个字节，例如“中”。</li>
<li>Unicode 扩展字符集需要用一对 char 来表示，例如“表情”。</li>
<li>Unicode 是字符集，不是编码，作用类似于 ASCII 码。</li>
<li>Java String 的 length 不是字符数。</li>
</ul>
<p>Java String 可以有多长？<br>分配到栈：<br>String longString = “aaa…aaa”;<br>分配到堆：<br>byte[] bytes = loadFromFile(new File(“superLongText.txt”); String superLongString = new String(bytes);<br>是否对字符串在内存当中的存储形式有深入了解（高级）<br>是否对Java虚拟机字节码有足够的了解（高级）</p>
<p>Java String 栈分配</p>
<ul>
<li>受字节码限制，字符串最终的 MUTF-8 字节数不超过 65535。</li>
<li>Latin 字符，受 Javac 代码限制，最多 65534 个。</li>
<li>非 Latin 字符最终对应字节个数差异较大，最多字节个数是 65535。</li>
<li>如果运行时方法区设置较小，也会受到方法区大小的限制。</li>
</ul>
<p>Java String 堆分配</p>
<ul>
<li>受虚拟机指令限制，字符数理论上限为 Integer.MAX_VALUE。</li>
<li>受虚拟机实现限制，实际上限可能会小于 Integer.MAX_VALUE。</li>
<li>如果堆内存较小，也会受到堆内存的限制。</li>
</ul>
<p>Java String 字面量形式</p>
<ul>
<li>字节码中 CONSTANT_Utf8_info 的限制，大小为65534（jvm字节码U2的最大长度）</li>
<li>Javac 源码逻辑的限制</li>
<li>方法区大小的限制</li>
</ul>
<p>Java String 运行时创建在堆上的形式</p>
<ul>
<li>Java 虚拟机指令 newarray 的限制</li>
<li>Java 虚拟机堆内存大小的限制</li>
</ul>
<p>String内部是以char数组的形式存储，数组的长度是int类型，那么String允许的最大长度就是Integer.MAX_VALUE了。又由于java中的字符是以16位存储的，因此大概需要4GB的内存才能存储最大长度的字符串。</p>
<p>String 为什么要设计成不可变的？<br>String 是不可变的（修改 String 时，不会在原有的内存地址修改，而是重新指向 一个新对象），String 用 final 修饰，不可继承，String 本质上是个 final 的 char[] 数组，所以 char[]数组的内存地址不会被修改，而且 String 也没有对外暴露修改 char[]数组的方法。不可变性可以保证线程安全以及字符串串常量池的实现。</p>
<p>String，StringBuffer，StringBuilder 有哪些不同<br>三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String<br>String 每次变化一个值就会开辟一个新的内存空间<br>StringBuilder：线程非安全的<br>StringBuffer：线程安全的</p>
<p>对于三者使用的总结：<br>1.如果要操作少量的数据用 String。<br>2.单线程操作字符串缓冲区下操作大量数据用 StringBuilder。<br>3.多线程操作字符串缓冲区下操作大量数据用 StringBuffer。</p>
<h3 id="final，finally，finalize"><a href="#final，finally，finalize" class="headerlink" title="final，finally，finalize"></a>final，finally，finalize</h3><p>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代 表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以 重写的（override）。</p>
<p>finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁 等动作。</p>
<p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被 垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。Java 平台目前在逐步使用java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。Cleaner 的实现利用了幻 象引用（PhantomReference），这是一种常见的所谓 post-mortem 清理机制。 利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收 的工作，比如关闭文件描述符（操作系统有限的资源），它比 finalize 更加轻量、 更加可靠。</p>
<h3 id="Synchronized、volatile、Lock-ReentrantLock"><a href="#Synchronized、volatile、Lock-ReentrantLock" class="headerlink" title="Synchronized、volatile、Lock(ReentrantLock)"></a>Synchronized、volatile、Lock(ReentrantLock)</h3><p>synchronized 代码块是由一对儿 monitorenter/monitorexit 指令实现的， Monitor 对象是同步的基本实现，而 synchronized 同步方法使用了 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行 相应的同步调用。 在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要 进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。 现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同 的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、 轻量级锁和重量级锁，大大改进了其性能。 所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检 测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、 降级。</p>
<p>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作，在对象头上 的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不 涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周 期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。 如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销 （revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升 级为重量级锁（可能会先进行自旋锁升级，如果失败再尝试重量级锁升级）。 我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是 会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</p>
<p>synchronized 修饰静态方法获取的是类锁(类的字节码文件对象)。<br>synchronized 修饰普通方法或代码块获取的是对象锁。这种机制确保了同一时刻 对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处 于可执行状态，从而有效避免了类成员变量的访问冲突。</p>
<h4 id="wait、sleep-的区别"><a href="#wait、sleep-的区别" class="headerlink" title="wait、sleep 的区别"></a>wait、sleep 的区别</h4><p>最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。wait 通常被用 于线程间交互，sleep 通常被用于暂停执行。</p>
<ul>
<li>首先，要记住这个差别，“sleep 是 Thread 类的方法,wait 是 Object 类中 定义的方法”。尽管这两个方法都会影响线程的执行行为，但是本质上是 有区别的。</li>
<li>Thread.sleep 不会导致锁行为的改变，如果当前线程是拥有锁的，那么 Thread.sleep 不会让线程释放锁。如果能够帮助你记忆的话，可以简单认 为和锁相关的方法都定义在 Object 类中，因此调用 Thread.sleep 是不会 影响锁的相关行为。</li>
<li>Thread.sleep 和 Object.wait 都会暂停当前的线程，对于 CPU 资源来说， 不管是哪种方式暂停的线程，都表示它暂时不再需要 CPU 的执行时间。 OS 会将执行时间分配给其它线程。区别是，调用 wait 后，需要别的线程 执行 notify/notifyAll 才能够重新获得 CPU 执行时间。</li>
</ul>
<p>notify 运行过程<br>当线程 A（消费者）调用 wait()方法后，线程 A 让出锁，自己进入等待状态，同 时加入锁对象的等待队列。 线程 B（生产者）获取锁后，调用 notify 方法通知 锁对象的等待队列，使得线程 A 从等待队列进入阻塞队列。 线程 A 进入阻塞队 列后，直至线程 B 释放锁后，线程 A 竞争得到锁继续从 wait()方法后执行。</p>
<p>Lock（ReentrantLock）的底层实现主要是 Volatile + CAS（乐观锁），而 Synchronized 是一种悲观锁，比较耗性能。但是在 JDK1.6 以后对 Synchronized 的锁机制进行了优化，加入了偏向锁、轻量级锁、自旋锁、重量级锁，在并发量 不大的情况下，性能可能优于 Lock 机制。所以建议一般请求并发量不大的情况 下使用 synchronized 关键字。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile 有两条关键的语义：</p>
<ul>
<li>保证被 volatile 修饰的变量对所有线程都是可见的</li>
<li>禁止进行指令重排序</li>
</ul>
<p>什么是指令重排序？<br>指令重排序是指指令乱序执行，即在条件允许的情况下直接运行当前有能 力立即执行的后续指令，避开为获取一条指令所需数据而造成的等待，通 过乱序执行的技术提供执行效率。<br>指令重排序会在被 volatile 修饰的变量的赋值操作前，添加一个内存屏障，指令重排序时不能把后面的指令重排序移到内存屏障之前的位置。</p>
<p>synchronized 和 volatile 关键字的作用和区别。<br>Volatile：<br>1）保证了不同线程对这个变量进行操作时的可见性即一个线程修改了某个变量 的值，这新值对其他线程来是立即可见的。 2）禁止进行指令重排序。</p>
<p>volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的， 需从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变 量，其它线程被阻塞住。</p>
<p>1.volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类 级别的。<br>2.volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可 以保证变量的修改可见性和原子性。<br>3.volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。<br>4.volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译 器优化。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock 实现的前提就是 AbstractQueuedSynchronizer，简称 AQS，是 java.util.concurrent 的核心，CountDownLatch、FutureTask、Semaphore、 ReentrantLock 等都有一个内部类是这个抽象类的子类。由于 AQS 是基于 FIFO 队列的实现，因此必然存在一个个节点，Node 就是一个节点，Node 有两种模 式：共享模式和独占模式。ReentrantLock 是基于 AQS 的，AQS 是 Java 并发包中众多同步组件的构建基础，它通过一个 int 类型的状态变量 state 和一个 FIFO 队列来完成共享资源的获取，线程的排队等待等。AQS 是个底层框架，采用模 板方法模式，它定义了通用的较为复杂的逻辑骨架，比如线程的排队，阻塞，唤 醒等，将这些复杂但实质通用的部分抽取出来，这些都是需要构建同步组件的使 用者无需关心的，使用者仅需重写一些简单的指定的方法即可（其实就是对于共 享变量 state 的一些简单的获取释放的操作）。AQS 的子类一般只需要重写 tryAcquire(int arg)和 tryRelease(int arg)两个方法即可。</p>
<p>ReentrantLock的处理逻辑：</p>
<p>其内部定义了三个重要的静态内部类，Sync，NonFairSync，FairSync。Sync 作 为 ReentrantLock 中公用的同步组件，继承了 AQS（要利用 AQS 复杂的顶层逻 辑嘛，线程排队，阻塞，唤醒等等）；NonFairSync 和 FairSync 则都继承 Sync， 调用 Sync 的公用逻辑，然后再在各自内部完成自己特定的逻辑（公平或非公平）。<br>接着说下这两者的 lock()方法实现原理：</p>
<p>NonFairSync（非公平可重入锁）<br>1.先获取 state 值，若为 0，意味着此时没有线程获取到资源，CAS 将其设置为 1， 设置成功则代表获取到排他锁了；<br>2.若 state 大于 0，肯定有线程已经抢占到资源了，此时再去判断是否就是自己 抢占的，是的话，state 累加，返回 true，重入成功，state 的值即是线程重入的 次数；<br>3.其他情况，则获取锁失败。</p>
<p>FairSync（公平可重入锁）<br>可以看到，公平锁的大致逻辑与非公平锁是一致的，不同的地方在于了!hasQueuedPredecessors()这个判断逻辑，即便 state 为 0，也不能贸然直接去获取，要先去看有没有还在排队的线程，若没有，才能尝试去获取，做后面的处理。反之，返回 false，获取失败。</p>
<p>最后，说下 ReentrantLock 的 tryRelease()方法实现原理：<br>若 state 值为 0，表示当前线程已完全释放干净，返回 true，上层的 AQS 会意识到资源已空出。若不为 0，则表示线程还占有资源，只不过将此次重入的资源的释放了而已，返回 false。</p>
<p>ReentrantLock 是一种可重入的，可实现公平性的互斥锁，它的设计基于 AQS框架，可重入和公平性的实现逻辑都不难理解，每重入一次，state 就加 1，当然在释放的时候，也得一层一层释放。至于公平性，在尝试获取锁的时候多了一 个判断：是否有比自己申请早的线程在同步队列中等待，若有，去等待；若没有， 才允许去抢占。</p>
<p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数 据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每 次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。Java中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。<br>乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁， 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版 本号机制和 CAS 算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
<p>乐观锁适用于写比较少的情况下（多读场景），而一般多写的场景下用悲观锁就 比较合适。</p>
<p>乐观锁常见的两种实现方式：<br>1、版本号机制<br>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数， 当数据被修改时，version 值会加 1。当线程 A 要更新数据值时，在读取数据的 同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数 据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>2、CAS 算法<br>即 compare and swap（比较与交换），是一种有名的无锁算法。CAS 有 3 个操 作数，内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。 一般情况下是一个自旋操 作，即不断的重试。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Unsafe 是 CAS 的核心类。因为 Java 无法直接访问底层操作系统，而是通过本地 （native）方法来访问。不过尽管如此，JVM 还是开了一个后门，JDK 中有一个 类 Unsafe，它提供了硬件级别的原子操作。</p>
<p>CAS，Compare and Swap 即比较并交换，设计并发算法时常用到的一种技术， java.util.concurrent 包全完建立在 CAS 之上，没有 CAS 也就没有此包，可见 CAS 的重要性。当前的处理器基本都支持 CAS，只不过不同的厂家的实现不一样罢了。 并且 CAS 也是通过 Unsafe 实现的，由于 CAS 都是硬件级别的操作，因此效率 会比普通加锁高一些。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到 CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试 发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。<br>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生 的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结 果后，调用 resume() 使其恢复。<br>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果 等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。<br>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它 有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数， 前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙 述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法 则相反。</p>
<p>线程的生命周期：</p>
<ul>
<li>NEW：创建状态，线程创建之后，但是还未启动。</li>
<li>RUNNABLE：运行状态，处于运行状态的线程，但有可能处于等待状态， 例如等待 CPU、IO 等。</li>
<li>WAITING：等待状态，一般是调用了 wait()、join()、LockSupport.spark() 等方法。</li>
<li>TIMED_WAITING：超时等待状态，也就是带时间的等待状态。一般是调 用 了 wait(time) 、 join(time) 、 LockSupport.sparkNanos() 、 LockSupport.sparkUnit()等方法。</li>
<li>BLOCKED：阻塞状态，等待锁的释放，例如调用了 synchronized 增加了 锁。</li>
<li>TERMINATED：终止状态，一般是线程完成任务后退出或者异常终止。</li>
</ul>
<h3 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h3><p>静态代理与动态代理的区别在于代理类生成的时间不同，即根据程序运行前代理 类是否已经存在，可以将代理分为静态代理和动态代理。如果需要对多个类进行 代理，并且代理的功能都是一样的，用静态代理重复编写代理类就非常的麻烦， 可以用动态代理动态的生成代理类。</p>
<h3 id="强引用置为-null，会不会被回收？"><a href="#强引用置为-null，会不会被回收？" class="headerlink" title="强引用置为 null，会不会被回收？"></a>强引用置为 null，会不会被回收？</h3><p>不会立即释放对象占用的内存。 如果对象的引用被置为 null，只是断开了当前 线程栈帧中对该对象的引用关系，而 垃圾收集器是运行在后台的线程，只有当 用户线程运行到安全点(safe point)或者安全区域才会扫描对象引用关系，扫描到 对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些 对象是可恢复的（在 finalize 方法中恢复引用 ）。只有确定了对象无法恢复引 用的时候才会清除对象内存。</p>
<h3 id="软引用和弱引用"><a href="#软引用和弱引用" class="headerlink" title="软引用和弱引用"></a>软引用和弱引用</h3><p>1、软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软 / 弱引用。</p>
<p>2、如果只是想避免 OOM 异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p>
<p>3、可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对 象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p>
<h3 id="JVM-内存区域"><a href="#JVM-内存区域" class="headerlink" title="JVM 内存区域"></a>JVM 内存区域</h3><p>JVM 主要包括四个部分：<br>1.类加载器（ClassLoader）:在 JVM 启动时或者在类运行将需要的 class 加载到 JVM 中。<br>2.执行引擎：负责执行 class 文件中包含的字节码指令；<br>3.内存区（也叫运行时数据区）：是在 JVM 运行的时候操作所分配的内存区。 运行时内存区主要可以划分为 5 个区域，</p>
<ul>
<li>方法区(MethodArea)：用于存储类结构信息的地方，包括常量池、静态常量、 构造函数等。虽然 JVM 规范把方法区描述为堆的一个辑部分， 但它却有个别名 non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。</li>
<li>java 堆(Heap)：存储 java 实例或者对象的地方。这块是 GC 的主要区域。从存储 的内容我们可以很容易知道，方法和堆是被所有 java 线程共享的。</li>
<li>java 栈(Stack)：java 栈总是和线程关联在一起，每当创一个线程时，JVM 就会为 这个线程创建一个对应的 java 栈在这个 java 栈中,其中又会包含多个栈帧，每运 行一个方法就建一个栈帧，用于存储局部变量表、操作栈、方法返回等。每一个 方法从调用直至执行完成的过程，就对应一栈帧在 java 栈中入栈到出栈的过程。 所以 java 栈是现成有的。</li>
<li>程序计数器(PCRegister)：用于保存当前线程执行的内存地址。由于 JVM 程序是 多线程执行的（线程轮流切换），所以为了保证程切换回来后，还能恢复到原先 状态，就需要一个独立计数器，记录之前中断的地方，可见程序计数器也是线程 私有的。</li>
<li>本地方法栈(Native MethodStack)：和 java 栈的作用差不多，只不过是为 JVM 使 用到 native 方法服务的。</li>
</ul>
<p>4.本地方法接口：主要是调用 C 或 C++实现的本地方法及回调结果。</p>
<h3 id="GC-的原理和回收"><a href="#GC-的原理和回收" class="headerlink" title="GC 的原理和回收"></a>GC 的原理和回收</h3><p>提到垃圾回收，我们可以先思考一下，如果我们去做垃圾回收需要解决哪些问 题？ 一般说来，我们要解决三个问题：<br>1、回收哪些内存？<br>2、什么时候回收？<br>3、如何回收？</p>
<p>可达性分析：<br>可达性分析算法通过一系列称为 GCRoots 的对象作为起始点，从这些节点从上 向下搜索，所走过的路径称为引用链，当一个对象没有任何引用链与 GCRoots 连接时就说明此对象不可用，也就是对象不可达。<br>GC Roots 对象通常包括：</p>
<ul>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表） </li>
<li>方法中类的静态属性引用的对象 </li>
<li>方法区中常量引用的对象 </li>
<li>Native 方法引用的对象</li>
</ul>
<p>可达性分析算法整个流程如下所示：<br>第一次标记：对象在经过可达性分析后发现没有与 GC Roots 有引用链，则进行 第一次标记并进行一次筛选，筛选条件是：该对象是否有必要执行 finalize()方法。 没有覆盖 finalize()方法或者 finalize()方法已经被执行过都会被认为没有必要执行。 如果有必要执行：则该对象会被放在一个 F-Queue 队列，并稍后在由虚拟机建立的低优先级 Finalizer 线程中触发该对象的 finalize()方法，但不保证一定等待它执行结束，因为如果这个对象的 finalize()方法发生了死循环或者执行时间较长的情况，会阻塞 F-Queue 队列里的其他对象，影响 GC。<br>第二次标记：GC 对 F-Queue 队列里的对象进行第二次标记，如果在第二次标记 时该对象又成功被引用，则会被移除即将回收的集合，否则会被回收。<br>总之，JVM 在做垃圾回收的时候，会检查堆中的所有对象否会被这些根集对象 引用，不能够被引用的对象就会被圾收集器回收。一般回收算法也有如下几种：</p>
<p>1).标记-清除（Mark-sweep）<br>标记-清除算法采用从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象 的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效， 但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>
<p>2).标记-整理（Mark-Compact）<br>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不 同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移 动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了 对象的移动，因此成本更高，但是却解决了内存碎片的问题。该垃圾回收算法适 用于对象存活率高的场景（老年代）。</p>
<p>3).复制（Copying）<br>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已 使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存 碎片等复杂情况。</p>
<p>4).分代收集算法<br>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中 不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的 执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就 采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。Java 堆内存一般可以分为新生代、老年代和永久代三个模块：</p>
<p>新生代：<br>1.所有新生成的对象首先都是放在新生代的。新生代的目标就是尽可能快速的收 集掉那些生命周期短的对象。<br>2.新生代内存按照 8:1:1 的比例分为一个 eden 区和两个survivor(survivor0,survivor1)区。大部分对象在 Eden 区中生成。回收时先将 eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区，当这个 survivor0 区也 存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区， 然后清空 eden 和这个 survivor0 区，此时 survivor0 区是空的，然后将 survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。<br>3.当 survivor1 区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次 Full GC，也就是新生代、老 年代都进行回收。<br>4.新生代发生的 GC 也叫做 Minor GC，MinorGC 发生频率比较高(不一定等 Eden 区满了才触发)。</p>
<p>老年代：<br>1.在老年代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到老年代中。因 此，可以认为老年代中存放的都是一些生命周期较长的对象。<br>2.内存比新生代也大很多(大概比例是 1:2)，当老年代内存满时触发 Major GC， 即 Full GC。Full GC 发生频率比较低，老年代对象存活时间比较长。</p>
<p>永久代：<br>永久代主要存放静态文件，如 Java 类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如使用反射、动态代理、CGLib 等 bytecode 框架时，在这种时候需要设置一个比较大的永久代空间来存 放这些运行过程中新增的类。</p>
<p>垃圾收集器：</p>
<ul>
<li>Serial 收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程， 优点是简单高效；</li>
<li>Serial Old 收集器 (标记-整理算法): 老年代单线程收集器，Serial 收集器 的老年代版本；</li>
<li>ParNew 收集器 (复制算法): 新生代收并行集器，实际上是 Serial 收集器 的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现；</li>
<li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行 收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿 的特点，追求最短 GC 回收停顿时间。</li>
<li>Parallel Scavenge 收集器 (复制算法): 新生代并行收集器，追求高吞吐量， 高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC 线程时间)， 高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合 后台应用等对交互相应要求不高的场景；</li>
<li>Parallel Old 收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先， Parallel Scavenge 收集器的老年代版本；</li>
<li>G1(Garbage First)收集器 (标记-整理算法)： Java 堆并行收集器，G1 收 集器是 JDK1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实 现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器 的一个重要特点是：G1 回收的范围是整个 Java 堆(包括新生代，老年代)， 而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<p>Garbage-First（G1，垃圾优先）收集器是服务类型的收集器，目标是多处理器 机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。 Oracle JDK 7 update 4 以及更新发布版完全支持 G1 垃圾收集器。它是将堆内存被划分为多个大小相等的 heap 区,每个 heap 区都是逻辑上连续 的一段内存(virtual memory). 其中一部分区域被当成老一代收集器相同的角色 (eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提 供了更多的灵活性。</p>
<p>JAVA 自动内存管理：给对象分配内存 以及 回收分配给对象的内存。<br>1、对象优先在 Eden 分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起 一次 MinorGC。<br>2、大对象直接进入老年代。如很长的字符串以及数组。很长的字符串以及数组。<br>3、长期存活的对象将进入老年代。当对象在新生代中经历过一定次数（默认为 15）的 Minor GC 后，就会被晋升到老年代中。<br>4、动态对象年龄判定。为了更好地适应不同程序的内存状况，虚拟机并不是永 远地要求对象年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大 于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>启动类加载器（Bootstrap ClassLoader）：负责加载<JAVA_HOME>\lib目录下或者被-Xbootclasspath 参数所指定的路径的，并且是被虚拟机所 识别的库到内存中。<br>扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录下或者被 java.ext.dirs 系统变量所指定的路径的所有类库到内存中。<br>应用类加载器（Application ClassLoader）：负责加载用户类路径上的指 定类库，如果应用程序中没有实现自己的类加载器，一般就是这个类加载 器去加载应用程序中的类库。</p>
<p>ClassLoader 使用的是双亲委托模型来搜索类的，每个 ClassLoader 实例都有一 个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类 加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它classLoader 实例的的父类加载器。<br>当一个 ClassLoader 实例需要加载某个类时，它会在试图搜索某个类之前，先把 这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶 层的类加载器 Bootstrap ClassLoader 试图加载，如果没加载到，则把任务转交给 Extension ClassLoader 试图加载，如果也没加载到，则转交给 App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的 文件系统或网络等待 URL 中加载该类。<br>如果它们都没有加载到这个类时，则抛出 ClassNotFoundException 异常。否则 将这个找到的类生成一个类的定义，将它加载到内存当中，最后返回这个类在内 存中的 Class 实例对象。</p>
<h3 id="JVM-跟-Art、Dalvik-对比？"><a href="#JVM-跟-Art、Dalvik-对比？" class="headerlink" title="JVM 跟 Art、Dalvik 对比？"></a>JVM 跟 Art、Dalvik 对比？</h3><p>Dalvik时期，对象的内存分配和回收都比较慢。因为Dalvik使用的GC是单线程的，在垃圾回收期间要暂停虚拟机上的其他所有线程。所以这个时期的开发建议就是尽可能不要分配内存（GC=卡顿，所以不分配，就不用回收了。。）<br>Dalvik GC采用了并发标记-清除（CMS）算法。标记-清除算法的特点是，不用的对象不会马上回收，而是等到可用内存用尽之后才回收。这样导致了很多对象在用完之后还会在内存中存活较长时间，不能及时释放。<br>而且Dalvik GC只对后台的App进行内存整理（压缩），导致（前台App）堆中出现大量内存碎片，这些碎片往往都比较小，无法被分配给新对象，因为新的对象需要大块的连续内存空间。造成了严重的内存浪费。</p>
<p>ART:<br>内存分配/回收的算法依然是CMS（并发标记-清除），但是优化了很多地方。</p>
<ol>
<li>最明显的改动，就是用RosAlloc代替旧的dlmalloc作为内存分配的算法。在native代码中调用malloc或在Java/C++中使用new关键字创建对象时都会用到RosAlloc算法。该算法的优点在于可以针对特定线程进行内存分配，这个优点给之后Oreo版本的进一步优化提供了基础。</li>
<li>另一个进步是GC终于支持了前台App的堆内存压缩。这样前台的App在需要的时候也可以释放部分内存，降低OOM的概率，减少内存碎片，减少因内存碎片而导致的可用内存不足引发的GC，大幅提升了整体性能。</li>
<li>这一版的GC使用的更细粒度的锁，改善了在最终回收前的那一次停顿（细粒度锁，阻塞的代码更少了）。同时也把第一步的查找Root sets改为并发执行，这样整体上，把运行一次标记-清除的回收操作的耗时从10ms左右减少到3ms左右。</li>
<li>引入分代回收的机制。每次major gc完成后，垃圾回收器会追踪之后每一个分配的对象，按照各自的存活时间和大小，对这些对象进行“分代”，对象一开始会被放到年轻代区域，存活时间够长的话会被转移到老年代，更“大龄”的放到永久代区域。这个优化对性能的提升是最明显的。堆内存中每个“代”区域都有各自的内存上限，当达到上限的时候，系统会在这个区域发起一次gc，gc的耗时取决于该区域是哪一代，以及区域内有多少活跃的对象。<br>分代回收的引入，节省了内存分配（失败）过程的耗时，因为在内存不足的情况下，会针对不同的区域，只在必要的情况下进行内存回收，比如如果在年轻代可以回收到足够的内存，就直接完成分配，而不需要关心进一步去看老年代和永久代的情况，节省时间。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cottony/p/12675072.html">Android GC进化史</a></p>
<h3 id="Jvm调优"><a href="#Jvm调优" class="headerlink" title="Jvm调优"></a>Jvm调优</h3><p>JVM 调优的常见命令工具包括<br>1）jps 命令用于查询正在运行的 JVM 进程，<br>2）jstat 可以实时显示本地或远程 JVM 进程中类装载、内存、垃圾收集、JIT 编 译等数据<br>3）jinfo 用于查询当前运行这的 JVM 属性和参数的值。<br>4）jmap 用于显示当前 Java 堆和永久代的详细信息<br>5）jhat 用于分析使用 jmap 生成的 dump 文件，是 JDK 自带的工具<br>6）jstack 用于生成当前 JVM 的所有线程快照，线程快照是虚拟机每一条线程正 在执行的方法,目的是定位线程出现长时间停顿的原因。</p>
<p>JVM 常见的调优参数包括：<br>-Xmx:指定 java 程序的最大堆内存, 使用 java -Xmx5000M -version 判断当前系统 能分配的最大堆内存<br>-Xms:指定最小堆内存, 通常设置成跟最大堆内存一样，减少 GC<br>-Xmn:设置年轻代大小。整个堆大小=年轻代大小 + 年老代大小。所以增大年轻 代后，将会减小年老代大小。此值对系统性能影响较大，Sun 官方推荐配置为整 个堆的 3/8。<br>-Xss:指定线程的最大栈空间, 此参数决定了 java 函数调用的深度, 值越大调用深 度越深, 若值太小则容易出栈溢出错误(StackOverflowError)<br>-XX:PermSize：指定方法区(永久区)的初始值,默认是物理内存的 1/64， 在 Java8 永久区移 除, 代之的是元数据区， 由-XX:MetaspaceSize 指定<br>-XX:MaxPermSize：指定方法区的最大值, 默认是物理内存的 1/4， 在 java8 中由 -XX:MaxMetaspaceSize 指定元数据区的大小<br>-XX:NewRatio=n:年老代与年轻代的比值，-XX:NewRatio=2, 表示年老代与年轻代的比值为2:1<br>-XX:SurvivorRatio=n:Eden 区与 Survivor 区的大小比值，-XX:SurvivorRatio=8 表示 Eden 区与 Survivor 区的大小比值是 8:1:1，因为 Survivor 区有两个(from, to)</p>
<h3 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h3><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标 的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL， 因此加密的详细内容就需要 SSL。 它是一个 URI scheme（抽象标识符体系），句法类同 http: 体系。用于安全的 HTTP 数据传输。https:URL 表明它使用了 HTTP，但 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP 与 TCP 之间）。这个系统的最初研发由 网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通 讯，例如交易支付方面。</p>
<p>SSL/TLS 的常见开源实现是 OpenSSL，OpenSSL 是一个开放源代码的软件库包，应用程序 可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被 应用在互联网的网页服务器上。TLS 是 SSL 的升级替代版。</p>
<h4 id="Http1-1-和-Http1-0-及-2-0-的区别"><a href="#Http1-1-和-Http1-0-及-2-0-的区别" class="headerlink" title="Http1.1 和 Http1.0 及 2.0 的区别"></a>Http1.1 和 Http1.0 及 2.0 的区别</h4><p>HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络 请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：<br>1、缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做 为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag， If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓 存策略。<br>2、带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户 端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点 续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分， 即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利 用带宽和连接。<br>3、错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict） 表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资 源被永久性的删除。<br>4、Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此， 请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展， 在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它 们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求 消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。<br>5、长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线 （Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建 立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一 定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</p>
<p>SPDY<br>在讲 Http1.1 和 Http2.0 的区别之前，还需要说下 SPDY，它是 HTTP1.x 的优化方案：<br>2012 年 google 如一声惊雷提出了 SPDY 的方案，优化了 HTTP1.X 的请求延迟，解决了 HTTP1.X 的安全性，具体如下：<br>1、降低延迟，针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。 多路复用通过多个请求 stream 共享一个 tcp 连接的方式，解决了 HOL blocking 的 问题，降低了延迟同时提高了带宽的利用率。<br>2、请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接 共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先 级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应 该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能 第一时间看到网页内容。<br>3、header 压缩。前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适 的压缩算法可以减小包的大小和数量。<br>4、基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性。<br>5、服务端推送（server push），采用了 SPDY 的网页，例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户 端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。<br>SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议(将 HTTP1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能。</p>
<p>HTTP2.0 和 HTTP1.X 相比的新特性<br>新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本。基于文本协议的 格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然 很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定 采用二进制格式，实现方便且健壮。<br>多路复用（MultiPlexing），即连接共享，即每一个 request 都是是用作连接共享机 制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属 到各自不同的服务端请求里面。<br>header 压缩，如上文中所言，对前面提到过 HTTP1.x 的 header 带有大量信息，而 且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯 双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需 要传输的大小。<br>服务端推送（server push），同 SPDY 一样，HTTP2.0 也具有 server push 功能。</p>
<p>Https 请求慢的解决办法<br>1、不通过 DNS 解析，直接访问 IP<br>2、解决连接无法复用<br>http/1.0 协议头里可以设置 Connection:Keep-Alive 或者 Connection:Close，选择是否允许 在一定时间内复用连接（时间可由服务器控制）。但是这对 App 端的请求成效不大，因为 App 端的请求比较分散且时间跨度相对较大。</p>
<p>方案 1.基于 tcp 的长连接 (主要） 移动端建立一条自己的长链接通道，通道的实现是基于 tcp 协议。基于 tcp 的 socket 编程技术难度相对复杂很多，而且需要自己定制协议。但信息 的上报和推送变得更及时，请求量爆发的时间点还能减轻服务器压力（避免频繁创建和销毁 连接）</p>
<p>方案 2.http long-polling 客户端在初始状态发送一个 polling 请求到服务器，服务器并不会 马上返回业务数据，而是等待有新的业务数据产生的时候再返回，所以链接会一直被保持。 一但结束当前连接，马上又会发送一个新的 polling 请求，如此反复，保证一个连接被保持。 存在问题： 1）增加了服务器的压力 2）网络环境复杂场景下，需要考虑怎么重建健康的 连接通道 3）polling 的方式稳定性不好 4）polling 的response 可能被中间代理cache 住 ……</p>
<p>方案 3.http streaming 和 long-polling 不同的是，streaming 方式通过再 server response 的头部增加“Transfer Encoding:chuncked”来告诉客户端后续还有新的数据到来 存在问题： 1）有些代理服务器会等待服务器的 response 结束之后才将结果推送给请求客户端。 streaming 不会结束 response 2）业务数据无法按照请求分割 ……</p>
<p>方案 4.web socket 和传统的 tcp socket 相似，基于 tcp 协议，提供双向的数据通道。它的 优势是提供了 message 的概念，比基于字节流的 tcp socket 使用更简单。技术较新，不是 所有浏览器都提供了支持。</p>
<p>3、解决 head of line blocking<br>它的原因是队列的第一个数据包（队头）受阻而导致整列数据包受阻。使用 http pipelining，确保几乎在同一时间把 request 发向了服务器</p>
<p>HTTP 的缓存可以分为两种： 强制缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据是，服务端返 回了缓存的过期时间（Expires 与 Cache-Control），没有过期就可以继续使用缓存，否则则 不适用，无需再向服务端询问。 对比缓存：需要服务端参与判断是否继续使用缓存，当客 户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since 与 Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请 求数据时，客户端将上次备份的缓存 标识发送给服务端，服务端根据缓存标识进行判断， 如果返回 304，则表示通知客户端可以继续使用缓存。 强制缓存优先于对比缓存。</p>
<p>Http 长连接<br>Http1.0 是短连接，HTTP1.1 默认是长连接，也就是默认 Connection 的值就是 keep-alive。 但是长连接实质是指的 TCP 连接，而不是 HTTP 连接。TCP 连接是一个双向的通道，它是可 以保持一段时间不关闭的，因此 TCP 连接才有真正的长连接和短连接这一说。</p>
<p>Http1.1 为什么要用使用 tcp 长连接？<br>长连接是指的 TCP 连接，也就是说复用的是 TCP 连接。即长连接情况下，多个 HTTP 请求 可以复用同一个 TCP 连接，这就节省了很多 TCP 连接建立和断开的消耗。<br>此外，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在 header 当 中进行设置的，也就是所谓的超时时间），这个连接没有 HTTP 请求发出的话，那么这个长 连接就会被断掉。</p>
<p>客户端如何校验 CA 证书：<br>CA 证书中的 Hash 值，其实是用证书的私钥进行加密后的值（证书的私钥不在 CA 证书 中）。然后客户端得到证书后，利用证书中的公钥去解密该 Hash 值，得到 Hash-a ；然 后再利用证书内的签名 Hash 算法去生成一个 Hash-b 。最后比较 Hash-a 和 Hash-b 这 两个的值。如果相等，那么证明了该证书是对的，服务端是可以被信任的；如果不相等，那 么就说明该证书是错误的，可能被篡改了，浏览器会给出相关提示，无法建立起 HTTPS 连 接。除此之外，还会校验 CA 证书的有效时间和域名匹配等。</p>
<p>HTTPS 中的 SSL 握手建立过程<br>假设现在有客户端 A 和服务器 B ：<br>1、首先，客户端 A 访问服务器 B ，比如我们用浏览器打开一个网 页 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> ，这时，浏览器就是客户端 A ，百度的服务器就是服务器 B 了。 这时候客户端 A 会生成一个随机数 1，把随机数 1 、自己支持的 SSL 版本号以及 加密算法等这些信息告诉服务器 B 。<br>2、服务器 B 知道这些信息后，然后确认一下双方的加密算法，然后服务端也生成 一个随机数 B ，并将随机数 B 和 CA 颁发给自己的证书一同返回给客户端 A 。<br>3、客户端 A 得到 CA 证书后，会去校验该 CA 证书的有效性，校验方法在上面 已经说过了。校验通过后，客户端生成一个随机数 3 ，然后用证书中的公钥加密随 机数 3 并传输给服务端 B 。<br>4、服务端 B 得到加密后的随机数 3，然后利用私钥进行解密，得到真正的随机数 3。<br>5、最后，客户端 A 和服务端 B 都有随机数 1、随机数 2、随机数 3，然后双方利 用这三个随机数生成一个对话密钥。之后传输内容就是利用对话密钥来进行加解密 了。这时就是利用了对称加密，一般用的都是 AES 算法。<br>6、客户端 A 通知服务端 B ，指明后面的通讯用对话密钥来完成，同时通知服务 器 B 客户端 A 的握手过程结束。<br>7、服务端 B 通知客户端 A，指明后面的通讯用对话密钥来完成，同时通知客户端 A 服务器 B 的握手过程结束。<br>8、SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户端 A 和服务器 B 开 始使用相同的对话密钥进行数据通讯。</p>
<p>简化如下：<br>1、客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务端的身份；<br>2、互相传递三个随机数，之后通过这随机数来生成一个密钥；<br>3、互相确认密钥，然后握手结束；<br>4、数据通讯开始，都使用同一个对话密钥来加解密；</p>
<p>响应码：<br>1** 信息，服务器收到请求，需要请求者继续执行操作<br>2** 成功，操作被成功接收并处理<br>3** 重定向，需要进一步的操作以完成请求<br>4** 客户端错误，请求包含语法错误或无法完成请求<br>5** 服务器错误，服务器在处理请求的过程中发生了错误</p>
<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><p>为什么 tcp 要经过三次握手，四次挥手？<br>“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生 错误”。主要目的防止 server 端一直等待，浪费资源。换句话说，即是为了保证服务端能收 接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客 户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</p>
<p>“四次挥手”原因是因为 tcp 是全双工模式，接收到 FIN 时意味将没有数据再发来，但是还是 可以继续发送数据。</p>
<p>ACK ： TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的 ACK 必 须为 1。<br>SYN(SYNchronization) ： 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是 一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。<br>FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发 送方的数据已经发送完毕，并要求释放连接。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手：建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务器的确认；<br>第二次握手：服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number+1)；同时， 自己自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将 上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器 进入 SYN_RECV 状态；<br>第三次握手：客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都 进入 ESTABLISHED 状态，完成 TCP 三次握手。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>第一次分手：主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；<br>第二次分手：主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段， Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主 机 2 告诉主机 1，我“同意”你的关闭请求；<br>第三次分手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；<br>第四次分手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭 连接了。</p>
<h4 id="TCP-可靠传输原理实现（滑动窗口）"><a href="#TCP-可靠传输原理实现（滑动窗口）" class="headerlink" title="TCP 可靠传输原理实现（滑动窗口）"></a>TCP 可靠传输原理实现（滑动窗口）</h4><p>确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。 数据校验。<br>数据合理分片与排序，TCP 会对数据进行分片，接收方会缓存为按序到达的数据，重新排序 后再提交给应用层。<br>流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢 失。<br>拥塞控制：当网络发生拥塞时，减少数据的发送。</p>
<h4 id="Tcp-和-Udp-的区别"><a href="#Tcp-和-Udp-的区别" class="headerlink" title="Tcp 和 Udp 的区别"></a>Tcp 和 Udp 的区别</h4><p>1、基于连接与无连接；<br>2、对系统资源的要求（TCP 较多，UDP 少）；<br>3、UDP 程序结构较简单；<br>4、流模式与数据报模式 ；<br>5、TCP 保证数据正确性，UDP 可能丢包；<br>6、TCP 保证数据顺序，UDP 不保证。</p>
<p>如何设计在 UDP 上层保证 UDP 的可靠性传输？<br>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照 tcp 可靠 性传输的方式。如不考虑拥塞处理，可靠 UDP 的简单设计如下：<br>1、添加 seq/ack 机制，确保数据发送到对端<br>2、添加发送和接收缓冲区，主要是用户超时重传。<br>3、添加超时重传机制。<br>具体过程即是：送端发送数据时，生成一个随机 seq=x，然后每一片按照数据大小分配 seq。 数据到达接收端后接收端放入缓存，并发送一个 ack=x 的包，表示对方已经收到了数据。 发送端收到了 ack 包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数 据。<br>目前有如下开源程序利用 udp 实现了可靠的数据传输。分别为 RUDP、RTP、UDT:<br>1、RUDP（Reliable User Datagram Protocol） RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等。<br>2、RTP（Real Time Protocol） RTP 为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视 频音频或模拟数据。<br>3、UDT（UDP-based Data Transfer Protocol） UDT 的主要目的是支持高速广域网上的海量数据传输。</p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>长连接的实现：心跳机制，应用层协议大多都有 HeartBeat 机制，通常是客户端每隔一小段 时间向服务器发送一个数据包，通知服务器自己仍然在线。并传输一些可能必要的数据。使 用心跳包的典型协议是 IM，比如 QQ/MSN/飞信等协议<br>1、在 TCP 的机制里面，本身是存在有心跳包的机制的，也就是 TCP 的选项：SO_KEEPALIVE。 系统默认是设置的 2 小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断 线。 而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。 通过使用 TCP 的 KeepAlive 机制（修改那个 time 参数），可以让连接每隔一小段时间就产 生一些 ack 包，以降低被踢掉的风险，当然，这样的代价是额外的网络和 CPU 负担。<br>2、应用层心跳机制实现。</p>
<p>常见网络流程问题：<br>浏览器输入地址到返回结果发生了什么？<br>1、DNS 解析，此外还有 DNSy 优化（DNS 缓存、DNS 负载均衡）<br>2、TCP 连接<br>3、发送 HTTP 请求<br>4、服务器处理请求并返回 HTTP 报文<br>5、浏览器解析渲染页面<br>6、连接结束</p>
<h2 id="2-Android"><a href="#2-Android" class="headerlink" title="2. Android"></a>2. Android</h2><h3 id="Android-中-ClassLoader"><a href="#Android-中-ClassLoader" class="headerlink" title="Android 中 ClassLoader"></a>Android 中 ClassLoader</h3><p>BootClassLoader（Java 的 BootStrap ClassLoader）： 用于加载 Android Framework 层 class 文件。<br>PathClassLoader（Java 的 App ClassLoader）： 用于加载已经安装到系 统中的 apk 中的 class 文件。<br>DexClassLoader（Java 的 Custom ClassLoader）： 用于加载指定目录中 的 class 文件。 BaseDexClassLoader： 是 PathClassLoader 和 DexClassLoader 的父类。</p>
<h3 id="LruCache原理"><a href="#LruCache原理" class="headerlink" title="LruCache原理"></a>LruCache原理</h3><p>LRU 缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈 中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超 过限定值，则删除栈底元素（即最近最少使用的元素）。</p>
<p>LruCache 中维护了一个集合 LinkedHashMap，该 LinkedHashMap 是以访问顺序排序的。当调用 put()方法时，就会在结合中添加元素，并调用 trimToSize()判断缓存是否已满，如果满了就用 LinkedHashMap 的迭代器删除队 头元素，即近期最少访问的元素。当调用 get()方法访问缓存对象时，就会调用 LinkedHashMap 的 get()方法获得对应集合元素，同时会更新该元素到队尾。</p>
<p>DiskLruCache 与 LruCache 原理相似，只是多了一个 journal 文件来做磁盘文件 的管理。</p>
<p>我们来分析下这个文件的内容： 第一行：libcore.io.DiskLruCache，固定字符串。 第二行：1，DiskLruCache 源 码版本号。 第三行：1，App 的版本号，通过 open()方法传入进去的。 第四行： 1，每个 key 对应几个文件，一般为 1. 第五行：空行 第六行及后续行：缓存操作记录。 第六行及后续行表示缓存操作记录，关于操作记录，我们需要了解以 下三点：</p>
<p>DIRTY 表示一个 entry 正在被写入。写入分两种情况，如果成功会紧接着写入一 行 CLEAN 的记录；如果失败，会增加一行 REMOVE 记录。注意单独只有 DIRTY 状态的记录是非法的。 当手动调用 remove(key)方法的时候也会写入一条 REMOVE 记录。 READ 就是说明有一次读取的记录。 CLEAN 的后面还记录了文 件的长度，注意可能会一个 key 对应多个文件，那么就会有多个数字。</p>
<h3 id="HashMap与SparseArray"><a href="#HashMap与SparseArray" class="headerlink" title="HashMap与SparseArray"></a>HashMap与SparseArray</h3><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源码中可以看到key和value分别是用数组表示。SparseArray在存储和读取数据时候，使用的是二分查找法。</p>
<h3 id="LaunchMode"><a href="#LaunchMode" class="headerlink" title="LaunchMode"></a>LaunchMode</h3><p>standard、singleTop、singleTask、singleInstance</p>
<p>taskAffinity 是 Activity 在 mainfest 中配置的一个属性，暂时可以理解为： taskAffinity为宿主Activity指定了存放的任务栈[不同于App中其他的Activity 的栈]，为 activity 设置 taskAffinity 属性时不能和包名相同，因为 Android 团 队为 taskAffinity 默认设置为包名任务栈。taskAffinity 只有和 SingleTask 启动模式匹配使用时，启动的 Activity 才会运 行在名字和 taskAffinity 相同的任务栈中。</p>
<h3 id="如何保证-Service-不被杀死？"><a href="#如何保证-Service-不被杀死？" class="headerlink" title="如何保证 Service 不被杀死？"></a>如何保证 Service 不被杀死？</h3><p>Android 进程不死从 3 个层面入手：</p>
<p>A.提供进程优先级，降低进程被杀死的概率 </p>
<p>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动 1 个像素的 Activity，在用 户解锁时将 Activity 销毁掉。</p>
<p>方法二：启动前台 service。</p>
<p>方法三：提升 service 优先级：</p>
<p>在 AndroidManifest.xml 文件中对于 intent-filter 可以通过 android:priority = “1000”这个属性设置最高优先级，1000 是最高值，如果数字越小则优先级越低， 同时适用于广播。 </p>
<p>B. 在进程被杀死后，进行拉活 </p>
<p>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等 </p>
<p>方法二：双进程相互唤起。</p>
<p> 方法三：依靠系统唤起。 </p>
<p>方法四：onDestroy 方法里重启 service：service + broadcast 方式，就是当 service 走 ondestory 的时候，发送一个自定义的广播，当收到广播的时候，重新启动 service；</p>
<p>C. 依靠第三方</p>
<p>根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推 送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。</p>
<h3 id="保活方案"><a href="#保活方案" class="headerlink" title="保活方案"></a>保活方案</h3><p>1、AIDL 方式单进程、双进程方式保活 Service。（基于 onStartCommand() return START_STICKY）<br>START_STICKY 在运行 onStartCommand 后 service 进程被 kill 后，那将保留在 开始状态，但是不保留那些传入的 intent。不久后 service 就会再次尝试重新创 建，因为保留在开始状态，在创建 service 后将保证调用 onstartCommand。如 果没有传递任何开始命令给 service，那将获取到 null 的 intent。<br>除了华为此方案无效以及未更改底层的厂商不起作用外（START_STICKY 字段就 可以保持 Service 不被杀）。此方案可以与其他方案混合使用</p>
<p>2、降低 oom_adj 的值（提升 service 进程优先级）：<br>Android 中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进 行进程的回收。Android 将进程分为 5 个等级,它们按优先级顺序由高到低依次是:<br>1.前台进程 (Foreground process)<br>2.可见进程 (Visible process)<br>3.服务进程 (Service process)<br>4.后台进程 (Background process)<br>5.空进程 (Empty process)</p>
<p>当 service 运行在低内存的环境时，将会 kill 掉一些存在的进程。因此进程的优 先级将会很重要，可以使用 startForeground 将 service 放到前台状态。这样在 低内存时被 kill 的几率会低一些。</p>
<p>常驻通知栏（可通过启动另外一个服务关闭 Notification，不对 oom_adj 值有影响）。<br>使用”1 像素“的 Activity 覆盖在 getWindow()的 view 上。此方案无效果<br>循环播放无声音频（黑科技，7.0 下杀不掉）。<br>成功对华为手机保活。小米 8 下也成功突破 20 分钟<br>3、监听锁屏广播：使 Activity 始终保持前台。<br>4、使用自定义锁屏界面：覆盖了系统锁屏界面。<br>5、通过 android:process 属性来为 Service 创建一个进程。<br>6、跳转到系统白名单界面让用户自己添加 app 进入白名单</p>
<p>复活方案:<br>1、onDestroy 方法里重启 service<br>service + broadcast 方式，就是当 service 走 onDestory 的时候，发送一个自定 义的广播，当收到广播的时候，重新启动 service。</p>
<p>2、JobScheduler：原理类似定时器，5.0,5.1,6.0 作用很大，7.0 时候有一定影响 （可以在电源管理中给 APP 授权）。只对 5.0，5.1、6.0 起作用。</p>
<p>3、推送互相唤醒复活：极光、友盟、以及各大厂商的推送。</p>
<p>4、同派系 APP 广播互相唤醒：比如今日头条系、阿里系。</p>
<p>此外还可以监听系统广播判断 Service 状态，通过系统的一些广播，比如：手机 重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的 Service 是 否还存活。<br>结论：高版本情况下可以使用弹出通知栏、双进程、无声音乐提高后台服务的 保活概率。</p>
<h3 id="Activity-Window-View-三者的差别"><a href="#Activity-Window-View-三者的差别" class="headerlink" title="Activity-Window-View 三者的差别"></a>Activity-Window-View 三者的差别</h3><h3 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h3><p>SurfaceView 是在一个新起的单独线程中可以重新绘制画面，而 view 必须在 UI 的主线程中更新画面。 在 UI 的主线程中更新画面可能会引发问题，比如你更新的时间过长，那么你的 主 UI 线程就会被你正在画的函数阻塞。那么将无法响应按键、触屏等消息。当 使用 SurfaceView 由于是在新的线程中更新画面所以不会阻塞你的 UI 主线程。 但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要在 SurfaceView 中的 thread 处理，一般就需要有一个 event queue 的设计来保存 touchevent，这会稍稍复杂一点，因为涉及到线程安全。</p>
<h3 id="ListView-amp-RecyclerView"><a href="#ListView-amp-RecyclerView" class="headerlink" title="ListView &amp; RecyclerView"></a>ListView &amp; RecyclerView</h3><p>ListView 的基础使用：<br>1.继承重写 BaseAdapter 类<br>2.自定义 ViewHolder 和 convertView 一起完成复用优化工作</p>
<p>RecyclerView 基础使用关键点同样有两点：<br>1.继承重写 RecyclerView.Adapter 和 RecyclerView.ViewHolder<br>2.设置布局管理器，控制布局效果</p>
<p>缓存：<br>RecyclerView比ListView多两级缓存，支持多个离ItemView缓存，支持开发者自定义缓存处理逻辑，支持所有RecyclerView共用同一个RecyclerViewPool(缓存池)。<br>具体来说：<br>ListView(两级缓存)：<br>RecyclerView(四级缓存)：</p>
<p>列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。</p>
<p>问题：<br>1.RecyclerView 与 ListView 缓存机制的不同？<br>2.想改变 listview 的高度，怎么做？<br>3.listview 跟 recyclerview 上拉加载的时候分别应该如何处理？<br>4.如何自己实现 RecyclerView 的侧滑删除？<br>5.RecyclerView 的 ItemTouchHelper 的实现原理</p>
<h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><p>Android 通过 WebView 调用 JS 代码：</p>
<p>1、通过 WebView 的 loadUrl()：</p>
<p>webview 只是载体，内容的渲染需要使用 webviewChromClient 类去实现， 通过设置 WebChromeClient 对象处理 JavaScript 的对话框。<br>特别注意：<br>JS 代码调用一定要在 onPageFinished（） 回调之后才能调用，否则不会调用。</p>
<p>2、通过 WebView 的 evaluateJavascript()：<br>该方法比第一种方法效率更高、使用更简洁，因为该方法的执行不会使页 面刷新，而第一种方法（loadUrl ）的执行则会。Android 4.4 后才可使用。</p>
<p>JS 通过 WebView 调用 Android 代码：<br>1、通过 WebView 的 addJavascriptInterface（）进行对象映射：<br>定义一个与 JS 对象映射关系的 Android 类：AndroidtoJs：</p>
<ul>
<li>定义 JS 需要调用的方法，被 JS 调用的方法必须加入@JavascriptInterface 注解。</li>
<li>通过 addJavascriptInterface()将 Java 对象映射到 JS 对象。</li>
</ul>
<p>优点：使用简单，仅将 Android 对象和 JS 对象映射即可。<br>缺点：addJavascriptInterface 接口引起远程代码执行漏洞，漏洞产生原因是：<br>当 JS 拿到 Android 这个对象后，就可以调用这个 Android 对象中所有的方法， 包括系统类（java.lang.Runtime 类），从而进行任意代码执行。</p>
<p>2、通过 WebViewClient 的方法 shouldOverrideUrlLoading ()回调拦截 url：<br>Android 通过 WebViewClient 的回调方法 shouldOverrideUrlLoading () 拦截 url解析该 url 的协议。 如果检测到是预先约定好的协议，就调用相应方法。 根据协议的参数，判断是否是所需要的 url。 一般根据 scheme（协议格 式） &amp; authority（协议名）判断（前两个参数）。<br>缺点：JS 获取 Android 方法的返回值复杂,如果 JS 想要得到 Android 方法的返回 值，只能通过 WebView 的 loadUrl （）去执行 JS 方法把返回值传递回去。</p>
<p>3、通过 WebChromeClient 的 onJsAlert()、onJsConfirm()、onJsPrompt（）方 法回调拦截 JS 对话框 alert()、confirm()、prompt（） 消息：<br>Android 通过 WebChromeClient 的 onJsAlert()、onJsConfirm()、onJsPrompt （）方法回调分别拦截 JS 对话框 （警告框、确认框、输入框），得到他们的消 息内容，然后解析即可。 常用的拦截是：拦截 JS 的输入框（即 prompt（）方法），因为只有 prompt（） 可以返回任意类型的值，操作最全面方便、更加灵活；而 alert（）对话框没有 返回值；confirm（）对话框只能返回两种状态（确定 / 取消）两个值。</p>
<h3 id="HandlerThread、IntentService"><a href="#HandlerThread、IntentService" class="headerlink" title="HandlerThread、IntentService"></a>HandlerThread、IntentService</h3><h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h4><p>当系统有多个耗时任务需要执行时，每个任务都会开启个新线程去执行耗时任 务，这样会导致系统多次创建和销毁线程，从而影响性能。为了解决这一问题， Google 提出了 HandlerThread，HandlerThread 本质上是一个线程类，它继承了 Thread。HandlerThread 有自己的内部 Looper 对象，可以进行 loopr 循环。通 过获取 HandlerThread 的 looper 对象传递给 Handler 对象，可以在 handleMessage()方法中执行异步任务。创建 HandlerThread 后必须先调用 HandlerThread.start()方法，Thread 会先调用 run 方法，创建 Looper 对象。当 有耗时任务进入队列时，则不需要开启新线程，在原有的线程中执行耗时任务即 可，否则线程阻塞。它在 Android 中的一个具体的使用场景是 IntentService。由 于 HanlderThread 的 run()方法是一个无限循环，因此当明确不需要再使用 HandlerThread 时，可以通过它的 quit 或者 quitSafely 方法来终止线程的执行。</p>
<p>优缺点：<br>1.HandlerThread 优点是异步不会堵塞，减少对性能的消耗。<br>2.HandlerThread 缺点是不能同时继续进行多任务处理，要等待进行处理， 处理效率较低。<br>3.HandlerThread 与线程池不同，HandlerThread 是一个串队列，背后只有 一个线程。</p>
<h4 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h4><p>IntentService 是一种特殊的 Service，它继承了 Service 并且它是一个抽象类，因 此必须创建它的子类才能使用 IntentService。</p>
<p>在实现上，IntentService 封装了 HandlerThread 和 Handler。当 IntentService 被 第一次启动时，它的 onCreate()方法会被调用，onCreat()方法会创建一个 HandlerThread，然后使用它的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最终都会在 HandlerThread 中执行。 生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至 onStartCommand()方法的 Intetnt。 生成一个工作队列来传送 Intent 对象给 onHandleIntent()方法，同一时刻只传送 一个 Intent 对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent) 都被执行完以后会自动停止服务，所以，你不需要自己去调用 stopSelf()方法来 停止。 该服务提供了一个 onBind()方法的默认实现，它返回 null。</p>
<p>提供了一个 onStartCommand()方法的默认实现，它将 Intent 先传送至工作队列， 然后从工作队列中每次取出一个传送至 onHandleIntent()方法，在该方法中对 Intent 做相应的处理。</p>
<p>为什么在 mServiceHandler 的 handleMessage()回调方法中执行完 onHandlerIntent()方法后要使用带 参数的 stopSelf()方法？</p>
<p>因为 stopSel()方法会立即停止服务，而 stopSelf（int startId）会等待所有的消 息都处理完毕后才终止服务，一般来说，stopSelf(int startId)在尝试停止服务之 前会判断最近启动服务的次数是否和 startId 相等，如果相等就立刻停止服务， 不相等则不停止服务。</p>
<h3 id="ContentProvider、ContentResolver、ContentObserver-之间的关系？"><a href="#ContentProvider、ContentResolver、ContentObserver-之间的关系？" class="headerlink" title="ContentProvider、ContentResolver、ContentObserver 之间的关系？"></a>ContentProvider、ContentResolver、ContentObserver 之间的关系？</h3><p>ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、 文件、XML、网络等，ContentProvider 为这些数据的访问提供了统一的接口， 可以用来做进程间数据共享。 </p>
<p>ContentResolver：ContentResolver 可以为不同 URI 操作不同的 ContentProvider 中的数据，外部进程可以通过 ContentResolver 与 ContentProvider 进行交互。</p>
<p>ContentObserver：观察 ContentProvider 中的数据变化，并将变化通知给外界。</p>
<h3 id="activty-和-Fragmengt-之间怎么通信？"><a href="#activty-和-Fragmengt-之间怎么通信？" class="headerlink" title="activty 和 Fragmengt 之间怎么通信？"></a>activty 和 Fragmengt 之间怎么通信？</h3><p>（一）Handler </p>
<p>（二）广播 </p>
<p>（三）事件总线：EventBus、RxBus、Otto </p>
<p>（四）接口回调 </p>
<p>（五）Bundle 和 setArguments(bundle)</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>1.资源对象没关闭造成的内存泄漏，Cursor，File 文件、Bitmap等在不适用时没有释放</p>
<p>2.注册没取消造成的内存泄漏</p>
<p>3.使用关于 application 的 context 来替代和 activity 相关的 context</p>
<p>查找内存泄漏：</p>
<p>1、使用 AndroidProfiler 的 MEMORY 工具：</p>
<p>运行程序，对每一个页面进行内存分析检查。首先，反复打开关闭页面 5 次，然 后收到 GC（点击 Profile MEMORY 左上角的垃圾桶图标），如果此时 total 内存 还没有恢复到之前的数值，则可能发生了内存泄露。此时，再点击 Profile MEMORY 左上角的垃圾桶图标旁的 heap dump 按钮查看当前的内存堆栈情况， 选择按包名查找，找到当前测试的 Activity，如果引用了多个实例，则表明发生 了内存泄露。</p>
<p>2、使用 MAT：</p>
<p>1、运行程序，所有功能跑一遍，确保没有改出问题，完全退出程序，手动触发 GC，然后使用 adb shell dumpsys meminfo packagename -d 命令查看退出界面 后 Objects 下的 Views 和 Activities 数目是否为 0，如果不是则通过 Leakcanary 检查可能存在内存泄露的地方，最后通过 MAT 分析，如此反复，改善满意为止。 1、在使用 MAT 之前，先使用 as 的 Profile 中的 Memory 去获取要分析的堆内存 快照文件.hprof，如果要测试某个页面是否产生内存泄漏，可以先 dump 出没进 入该页面的内存快照文件.hprof，然后，通常执行 5 次进入/退出该页面，然后再 dump 出此刻的内存快照文件.hprof，最后，将两者比较，如果内存相除明显， 则可能发生内存泄露。（注意:MAT 需要标准的.hprof 文件，因此在 as 的 Profiler 中 GC 后 dump 出的内存快照文件.hprof 必须手动使用 android sdk platform-tools 下的 hprof-conv 程序进行转换才能被 MAT 打开）</p>
<p>2、然后，使用 MAT 打开前面保存的 2 份.hprof 文件，打开 Overview 界面，在 Overview 界面下面有 4 中 action，其中最常用的就是 Histogram 和 Dominator Tree。</p>
<p>Dominator Tree：支配树，按对象大小降序列出对象和其所引用的对象，注重引 用关系分析。选择 Group by package，找到当前要检测的类（或者使用顶部的 Regex 直接搜索），查看它的 Object 数目是否正确，如果多了，则判断发生了 内存泄露。然后，右击该类，选择 Merge Shortest Paths to GC Root 中的 exclude all phantom/weak/soft etc.references 选项来查看该类的 GC 强引用链。最后， 通过引用链即可看到最终强引用该类的对象。 Histogram：直方图注重量的分析。使用方式与 Dominator Tree 类似。</p>
<p>3、对比 hprof 文件，检测出复杂情况下的内存泄露：</p>
<p>通用对比方式：在 Navigation History 下面选择想要对比的 dominator_tree/histogram，右击选择 Add to Compare Basket，然后在 Compare Basket 一栏中点击红色感叹号（Compare the results）生成对比表格（Compared Tables），在顶部 Regex 输入要检测的类，查看引用关系或对象数量去进行分析 即可。 针对于 Historam 的快速对比方式：直接选择 Histogram 上方的 Compare to another Heap Dump 选择要比较的 hprof 文件的 Historam 即可。</p>
<h4 id="Traceview"><a href="#Traceview" class="headerlink" title="Traceview"></a>Traceview</h4><p>Traceview 是 Android 平台特有的数据采集和分析工具，它主要用于分析 Android 中应用程序的 hotspot（瓶颈）。Traceview 本身只是一个数据分析工 具，而数据的采集则需要使用 Android SDK 中的 Debug 类或者利用 DDMS 工 具。二者的用法如下：开发者在一些关键代码段开始前调用 Android SDK 中 Debug 类的 startMethodTracing 函数，并在关键代码段结束前调用 stopMethodTracing 函数。这两个函数运行过程中将采集运行时间内该应用所 有线程（注意，只能是 Java 线程） 的函数执行情况， 并将采集数据保存到 /mnt/sdcard/下的一个文件中。 开发者然后需要利用 SDK 中的 Traceview 工 具来分析这些数据。</p>
<p>随着android ide的升级，之前的一些调试工具逐渐废弃并被新的工具替代。之前大部分的调试工具都位于Android Device Monitor中，该工具集在android studio 3.1中被废弃并在android studio 3.2中被移除。如下表格列出以前Android Device Monitor的官方替代工具。</p>
<table>
<thead>
<tr>
<th>原工具</th>
<th>替代工具</th>
</tr>
</thead>
<tbody><tr>
<td>Dalvik Debug Monitor Server (DDMS)</td>
<td>使用Android studio 3.0中引入的<a target="_blank" rel="noopener" href="https://developer.android.com/studio/profile/android-profiler.html">Android Profiler</a> 调试应用的cpu，内存和网络使用，对于其它调试任务，比如给连接的设备发送命令来实现端口转发、文件传输、截图等，可以使用<a target="_blank" rel="noopener" href="https://developer.android.com/studio/command-line/adb.html">ADB</a> 、<a target="_blank" rel="noopener" href="https://developer.android.com/studio/run/emulator.html">Android Emulator</a>、<a target="_blank" rel="noopener" href="https://developer.android.com/studio/debug/device-file-explorer.html">Device File Explorer</a>或者<a target="_blank" rel="noopener" href="https://developer.android.com/studio/debug/index.html">Debugger Window</a></td>
</tr>
<tr>
<td>Traceview</td>
<td>参照<a target="_blank" rel="noopener" href="https://developer.android.com/studio/profile/generate-trace-logs.html">Instrumenting your app</a>在代码中使用<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/os/Debug.html">Debug</a>类，记录并导出.trace文件。可以使用android studio的<a target="_blank" rel="noopener" href="https://developer.android.com/studio/profile/cpu-profiler.html">CPU Profiler</a>来检查应用的实时CPU使用</td>
</tr>
<tr>
<td>Systrace</td>
<td>如果你想检查原生系统进程或者定位应用中的ui卡顿，可以使用命令行版本的<a target="_blank" rel="noopener" href="https://developer.android.com/studio/profile/systrace-commandline.html">Systrace</a>或者CPU profiler中简化版的<strong>System Trace</strong>。</td>
</tr>
<tr>
<td>Tracer for OpenGL ES</td>
<td>使用<a target="_blank" rel="noopener" href="https://github.com/google/gapid">Graphic API Debugger</a></td>
</tr>
<tr>
<td>Hierarchy Viewer</td>
<td>如果想检查应用实时的布局，可以使用<a target="_blank" rel="noopener" href="https://developer.android.com/studio/debug/layout-inspector.html">Layout Inspector</a>。 如果想测量应用的帧率，可以使用<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/view/Window.OnFrameMetricsAvailableListener.html">Window.OnFrameMetricsAvailableListener </a>接口，在<a target="_blank" rel="noopener" href="https://android-developers.googleblog.com/2017/08/understanding-performance-benefits-of.html">这里</a>有详细描述</td>
</tr>
<tr>
<td>Pixel Perfect</td>
<td>使用Layout Inspector</td>
</tr>
<tr>
<td>Network Traffic tool</td>
<td>如果想检查网络访问数据，可以使用<a target="_blank" rel="noopener" href="https://developer.android.com/studio/profile/network-profiler">Network Profiler</a></td>
</tr>
</tbody></table>
<h3 id="什么是-ANR？-如何避免它？"><a href="#什么是-ANR？-如何避免它？" class="headerlink" title="什么是 ANR？ 如何避免它？"></a>什么是 ANR？ 如何避免它？</h3><p>在 Android 上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户 显示一个对话框，这个对话框称作应 用程序无响应（ANR：Application NotResponding）对话框。 用户可以选择让程序继续运行，但是，他们在使用 你的 应用程序时，并不希望每次都要处理这个对话框。因此 ，在程序里对响应 性能的设计很重要这样，这样系统就不会显 示 ANR 给用户。</p>
<p>不同的组件发生 ANR 的时间不一样，Activity 是 5 秒，BroadCastReceiver 是 10 秒，Service 是 20 秒、contentProvider(onCreate)为10秒（均为前台）。</p>
<p>如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt 即可，最新的 ANR 信息在最开始部分。</p>
<ul>
<li>主线程被 IO 操作（从 4.0 之后网络 IO 不允许在主线程中）阻塞。</li>
<li>主线程中存在耗时的计算</li>
<li>主线程中错误的操作，比如 Thread.wait 或者 Thread.sleep 等 Android 系 统会监控程序的响应状况，一旦出现上面两种情况，则弹出 ANR 对话框</li>
<li>应用在 5 秒内未响应用户的输入事件（如按键或者触摸）</li>
<li>BroadcastReceiver 未在 10 秒内完成相关的处理</li>
<li>Service 在特定的时间内无法处理完成 20 秒</li>
</ul>
<h3 id="android-中进程的优先级？"><a href="#android-中进程的优先级？" class="headerlink" title="android 中进程的优先级？"></a>android 中进程的优先级？</h3><p>前台进程：即与用户正在交互的 Activity 或者 Activity 用到的 Service 等，如果系统内存不足 时前台进程是最晚被杀死的</p>
<p>可见进程：可以是处于暂停状态(onPause)的 Activity 或者绑定在其上的 Service，即被用户 可见，但由于失了焦点而不能与用户交互</p>
<p>服务进程：其中运行着使用 startService 方法启动的 Service，虽然不被用户可见，但是却是 用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面下载的文件 等；当系统要空间运行，前两者进程才会被终止</p>
<p>后台进程：其中运行着执行 onStop 方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的 QQ，这时的进程系统一旦没了有内存就首先被杀死</p>
<p>空进程：不包含任何应用程序的进程，这样的进程系统是一般不会让他存在的</p>
<h3 id="AsyncTask与线程池"><a href="#AsyncTask与线程池" class="headerlink" title="AsyncTask与线程池"></a>AsyncTask与线程池</h3><p>核心参数:<br>corePoolSize:核心线程数<br>maximumPoolSize:最大线程数<br>keepAliveTime:非核心线程的闲置时间限制，超过则回收该非核心线程<br>workQueue:BlockingQueue类型，阻塞队列<br>threadFactory：线程的工厂类<br>handler：RejectedExecutionHandler线程池的饱和策略，默认策略是抛出运行时exception</p>
<p>在execute提交时：<br>1.如果线程数小于核心线程，则新建核心线程去执行任务Runable<br>2.将任务Runable加入workQueue中，然后检查是否可以新建线程<br>3.如果队列无法加入Runnable，检查是否可以新建线程(防止线程有回收的),如果不能，执行handler的拒绝策略</p>
<p>thread执行的对象是Worker对象，在worker中run方法会从queue中不停的取任务执行。</p>
<p>Runnable、Callable、Future是三个基础interface，分别是不带结果的运行，带结果的运行，对异步任务整个生命周期的表示。</p>
<p>FutureTask是class，继承了Runnable与Future，内部持有callable。一般外部传入callable。</p>
<p>java内置5中线程池：在Executors中提供静态方法<br>newCachedThreadPool：核心线程0，最大Integer.MAX_VALUE, keepAliveTime为60秒,SynchronousQueue同步阻塞队列。只有非核心线程,最大线程数非常大,所有线程都活动时会为新任务创建新线程, 否则会利用空闲线程(60s 空闲时间,过了就会被回收,所以线程池中有 0 个线程的 可能)处理任务。优点:任何任务都会被立即执行(任务队列 SynchronousQuue 相当于一个空集合); 比较适合执行大量的耗时较少的任务.<br>newSingleThreadExecutor：核心1，最大1，keepAliveTime为0，LinkedBlockingQueue。只有一个核心线程,确保所有的任务都在同一线程中按序完成.因此不需要处理线 程同步的问题.<br>newFixedThreadPool：核心n,最大n，keepAliveTime为0，LinkedBlockingQueue。只有核心线程,并且数量固定的,也不会被回收,所有线程都活动时,因为队列没有 限制大小,新任务会等待执行。优点:更快的响应外界请求。<br>newScheduledThreadPool：线程池为ScheduledThreadPoolExecutor，核心n，最大Integer.MAX_VALUE，keepAliveTime为10秒,DelayedWorkQueue（利用数组模拟堆实现）。主要处理定时任务，和Timer功能类似。核心线程数固定,非核心线程（闲着没活干会被立即回收数）没有限制.优点:执行定时任务以及有固定周期的重复任务<br>newWorkStealingPool：ForkJoinPool，使用一个无限队列来保存需要执行的任务，可以传入线程的数量，不传入，则默认使用当前计算机中可用的cpu数量，使用分治法来解决问题，使用fork()和join()来进行调用.</p>
<p>可以引入rxjava、kotlin线程池框架的比较？</p>
<h3 id="Serializable与Parcelable？"><a href="#Serializable与Parcelable？" class="headerlink" title="Serializable与Parcelable？"></a>Serializable与Parcelable？</h3><p>Serializable（Java 自带）：序列化的意思，表示将一个对象转换成存储或可传输的状态。序 列化后的对象可以在网络上进传输，也可以存储到本地。</p>
<p>Parcelable（android 专用）：是将一个完整的对象进行分解，而 分解后的每一部分都是 Intent 所支持的数据类型，这也就实现传递对象的功能 了。</p>
<p>编码上：Serializable代码量少，写起来方便，Parcelable代码多一些；效率上：Parcelable的速度比高十倍以上。</p>
<p>Serializable方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p>
<h3 id="Bitmap-使用时候注意什么"><a href="#Bitmap-使用时候注意什么" class="headerlink" title="Bitmap 使用时候注意什么"></a>Bitmap 使用时候注意什么</h3><p>1、要选择合适的图片规格（bitmap 类型）：</p>
<p>ALPHA_8每个像素占用 1byte 内存 </p>
<p>ARGB_4444 每个像素占用 2byte 内存 </p>
<p>ARGB_8888 每个像素占用 4byte 内存（默认） </p>
<p>RGB_565 每个像素占用 2byte 内存</p>
<p>2、降低采样率。BitmapFactory.Options 参数 inSampleSize 的使用，先把 options.inJustDecodeBounds 设为 true，只是去读取图片的大小，在拿到图片的 大小之后和要显示的大小做比较通过 calculateInSampleSize()函数计算 inSampleSize 的具体值，得到值之后。options.inJustDecodeBounds 设为 false 读图片资源。</p>
<p>3、复用内存。即，通过软引用(内存不够的时候才会回收掉)，复用内存块，不 需要再重新给这个 bitmap 申请一块新的内存，避免了一次内存的分配和回收， 从而改善了运行效率。</p>
<p>4、使用 recycle()方法及时回收内存。</p>
<p>5、压缩图片。</p>
<p>在 Android 中，Bitmap 的存储分为两部分，一部分是 Bitmap 的数据，一部分是 Bitmap 的引用。 在 Android2.3 时代，Bitmap 的引用是放在堆中的，而 Bitmap 的数据部分是放在栈中的，需要用户调用 recycle 方法手动进行内存回收，而在 Android2.3 之后，整个 Bitmap，包括数据和引用，都放在了堆中，这样，整个 Bitmap 的回收就全部交给 GC 了，这个 recycle 方法就再也不需要使用了。</p>
<p>bitmap recycler 引发的问题：当图像的旋转角度小余两个像素点之间的夹角时， 图像即使旋转也无法显示，因此，系统完全可以认为图像没有发生变化。这时系 统就直接引用同一个对象来进行操作，避免内存浪费。</p>
<p>BitmapFactory 四类方法：<br>decodeFile( 文件系统 )<br>decodeResourece( 资源 )<br>decodeStream( 输入流 )<br>decodeByteArray( 字节数 )</p>
<h4 id="Bitmap-占用内存"><a href="#Bitmap-占用内存" class="headerlink" title="Bitmap 占用内存"></a>Bitmap 占用内存</h4><p>Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存</p>
<p>注：这里 inDensity 表示目标图片的 dpi（放在哪个资源文件夹下）， inTargetDensity 表示目标屏幕的 dpi，所以你可以发现 inDensity 和 inTargetDensity 会对 Bitmap 的宽高进行拉伸，进而改变 Bitmap 占用内存的大 小。 在 Bitmap 里有两个获取内存占用大小的方法。</p>
<p>getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。 getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存 大小，代替了 getByteCount() 方法。 在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片 时，那么 getByteCount() 表示新解码图片占用内存的大 小， getAllocationByteCount() 表示被复用 Bitmap 真实占用的内存大小（即 mBuffer 的长度）。</p>
<p>为了保证在加载 Bitmap 的时候不产生内存溢出，可以使用 BitmapFactory 进行 图片压缩，主要有以下几个参数：<br>BitmapFactory.Options.inPreferredConfig：将 ARGB_8888 改为 RGB_565，改变 编码方式，节约内存。<br>BitmapFactory.Options.inSampleSize：缩放比例，可以 参考 Luban 那个库，根据图片宽高计算出合适的缩放比例。<br>BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。<br>inJustDecodeBounds 获取图片的宽高信息，交给 inSampleSize 参数选 择缩放比</p>
<p>高效加载 Bitmap 的流程:<br>1、将 BitmapFactory.Options 的 inJustDecodeBounds 参数设为 true 并加载图片<br>2、从 BitmapFactory.Options 中取出图片原始的宽高信息， 对应于 outWidth 和 outHeight 参数 3、根据采样率规则并结合目标 view 的大小计算出采样率 inSampleSize<br>4、将 BitmapFactory.Options 的 inJustDecodeBounds 设置为 false 重 新加载图片</p>
<p>针对清明上河图这种大图可以使用 BitmapRegionDecoder 动态加载图片的显示区域。</p>
<h4 id="Bitmap-如何处理大图，如一张-30M-的大图，如何预防-OOM"><a href="#Bitmap-如何处理大图，如一张-30M-的大图，如何预防-OOM" class="headerlink" title="Bitmap 如何处理大图，如一张 30M 的大图，如何预防 OOM?"></a>Bitmap 如何处理大图，如一张 30M 的大图，如何预防 OOM?</h4><p>上面减少bitmap内存的各种策略</p>
<h4 id="Bitmap-对象的理解"><a href="#Bitmap-对象的理解" class="headerlink" title="Bitmap 对象的理解"></a>Bitmap 对象的理解</h4><h3 id="广播传输的数据是否有限制，是多少，为什么要限制？"><a href="#广播传输的数据是否有限制，是多少，为什么要限制？" class="headerlink" title="广播传输的数据是否有限制，是多少，为什么要限制？"></a>广播传输的数据是否有限制，是多少，为什么要限制？</h3><p>Intent 在传递数据时是有大小限制的，大约限制在 1MB 之内，你用 Intent 传递 数据，实际上走的是跨进程通信（IPC），跨进程通信需要把数据从内核 copy</p>
<p>到进程中，每一个进程有一个接收内核数据的缓冲区，默认是 1M；如果一次传 递的数据超过限制，就会出现异常。</p>
<p>不同厂商表现不一样有可能是厂商修改了此限制的大小，也可能同样的对象在不 同的机器上大小不一样。</p>
<p>传递大数据，不应该用 Intent；考虑使用 ContentProvider 或者直接匿名共享内 存。简单情况下可以考虑分段传输。</p>
<h3 id="Android-程序运行时权限与文件系统权限"><a href="#Android-程序运行时权限与文件系统权限" class="headerlink" title="Android 程序运行时权限与文件系统权限"></a>Android 程序运行时权限与文件系统权限</h3><p>1、Linux 文件系统权限。不同的用户对文件有不同的读写执行权限。在 android 系统中，system 和应用程序是分开的，system 里的数据是不可更改的。</p>
<p>2、Android 中有 3 种权限，进程权限 UserID，签名，应用申明权限。每次安装 时，系统根据包名为应用分配唯一的 userID，不同的 userID 运行在不同的进程 里，进程间的内存是独立的，不可以相互访问，除非通过特定的 Binder 机制。</p>
<p>Android 提供了如下的一种机制，可以使两个 apk 打破前面讲的这种壁垒。</p>
<p>在 AndroidManifest.xml 中利用 sharedUserId 属性给不同的 package 分配相同 的 userID，通过这样做，两个 package 可以被当做同一个程序，系统会分配给 两个程序相同的 UserID。当然，基于安全考虑，两个 package 需要有相同的签 名，否则没有验证也就没有意义了。</p>
<p>Android 安全架构的中心设计点是：在默认情况下任何应用都没有权限执行对其 他应用、操作系统或用户有不利影响的任何操作。这包括读取或写入用户的私有 数据（例如联系人或电子邮件）、读取或写入其他应用程序的文件、执行网络访 问、使设备保持唤醒状态等。由于每个 Android 应用都是在进程沙盒中运行，因此应用必须显式共享资源和 数据。它们的方法是声明需要哪些权限来获取基本沙盒未提供的额外功能。应用 以静态方式声明它们需要的权限，然后 Android 系统提示用户同意。</p>
<h3 id="MVP、MVVM、MVC"><a href="#MVP、MVVM、MVC" class="headerlink" title="MVP、MVVM、MVC"></a>MVP、MVVM、MVC</h3><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC:"></a>MVC:</h4><p>视图层(View) 对应于 xml 布局文件和 java 代码动态 view 部分；<br>控制层(Controller) MVC 中 Android 的控制层是由 Activity 来承担的， Activity 本来主要是作为初始化页面，展示数据的操作，但是因为 XML 视 图功能太弱，所以 Activity 既要负责视图的显示又要加入控制逻辑，承担 的功能过多。<br>模型层(Model) 针对业务模型，建立数据结构和相关的类，它主要负责网 络请求，数据库处理，I/O 的操作。</p>
<p>总结：具有一定的分层，model 彻底解耦，controller 和 view 并没有解耦 层与层之间 的交互尽量使用回调或者去使用消息机制去完成，尽量避免直接持有 controller 和 view 在 android 中无法做到彻底分离，但在代码逻辑层面一定要分清 业务逻 辑被放置在 model 层，能够更好的复用和修改增加业务。</p>
<h4 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h4><p>通过引入接口 BaseView，让相应的视图组件如 Activity，Fragment 去实现 BaseView，实现了视图层的独立，通过中间层 Preseter 实现了 Model 和 View 的完全解耦。MVP 彻底解决了 MVC 中 View 和 Controller 傻傻分不清楚的问题， 但是随着业务逻辑的增加，一个页面可能会非常复杂，UI 的改变是非常多，会 有非常多的 case，这样就会造成 View 的接口会很庞大。</p>
<h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>MVP 中我们说过随着业务逻辑的增加，UI 的改变多的情况下，会有非常多的跟 UI 相关的 case，这样就会造成 View 的接口会很庞大。而 MVVM 就解决了这个 问题，通过双向绑定的机制，实现数据和 UI 内容，只要想改其中一方，另一方 都能够及时更新的一种设计理念，这样就省去了很多在 View 层中写很多 case 的情况，只需要改变数据就行。</p>
<p>MVVM 与 DataBinding 的关系？</p>
<p>MVVM 是一种思想，DataBinding 是谷歌推出的方便实现 MVVM 的工具。</p>
<p>看起来 MVVM 很好的解决了 MVC 和 MVP 的不足，但是由于数据和视图的双向 绑定，导致出现问题时不太好定位来源，有可能数据问题导致，也有可能业务逻 辑中对视图属性的修改导致。如果项目中打算用 MVVM 的话可以考虑使用官方 的架构组件 ViewModel、LiveData、DataBinding 去实现 MVVM。</p>
<p>三者如何选择？</p>
<ul>
<li>如果项目简单，没什么复杂性，未来改动也不大的话，那就不要用设计模 式或者架构方法，只需要将每个模块封装好，方便调用即可，不要为了使 用设计模式或架构方法而使用。</li>
<li>对于偏向展示型的 app，绝大多数业务逻辑都在后端，app 主要功能就是 展示数据，交互等，建议使用 mvvm。 </li>
<li>对于工具类或者需要写很多业务逻辑 app，使用 mvp 或者 mvvm 都可。</li>
</ul>
<h3 id="是否了解硬件加速？"><a href="#是否了解硬件加速？" class="headerlink" title="是否了解硬件加速？"></a>是否了解硬件加速？</h3><p>硬件加速就是运用 GPU 优秀的运算能力来加快渲染的速度，而通常的基于软件 的绘制渲染模式是完全利用 CPU 来完成渲染。</p>
<p>1.硬件加速是从 API 11 引入，API 14 之后才默认开启。对于标准的绘制操作和 控件都是支持的，但是对于自定义 View 的时候或者一些特殊的绘制函数就需要 考虑是否需要关闭硬件加速。</p>
<p>2.我们面对不支持硬件加速的情况，就需要限制硬件加速，这个兼容性的问题是 因为硬件加速是把 View 的绘制函数转化为使用 OpenGL 的函数来进完成实际的 绘制的，那么必然会存在 OpenGL 中不支持原始回执函数的情况，对于这些绘制 函数，就会失效。</p>
<p>3.硬件加速的消耗问题，因为是使用 OpenGL，需要把系统中 OpenGL 加载到内 存中，OpenGL API 调用就会占用 8MB，而实际上会占用更多内存，并且使用了 硬件必然增加耗电量了。</p>
<p>4.硬件加速的优势还有 display list 的设计，使用这个我们不需要每次重绘都执行 大量的代码，基于软件的绘制模式会重绘脏区域内的所有控件，而 display 只会 更新列表，然后绘制列表内的控件。</p>
<ol>
<li>CPU 更擅长复杂逻辑控制，而 GPU 得益于大量 ALU 和并行结构设计，更 擅长数学运算。</li>
</ol>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>1、Activity 和 Service 以及 Application 的 Context 是不一样的,Activity 继 承自 ContextThemeWraper.其他的继承自 ContextWrapper。</p>
<p>2、每一个 Activity 和 Service 以及 Application 的 Context 是一个新的 ContextImpl 对象。</p>
<p>3、getApplication()用来获取 Application 实例的，但是这个方法只有在 Activity 和 Service 中才能调用的到。那也许在绝大多数情况下我们都是在 Activity 或者 Servic 中使用 Application 的，但是如果在一些其它的场景， 比如 BroadcastReceiver 中也想获得 Application 的实例，这时就可以借助 getApplicationContext()方法，getApplicationContext()比 getApplication() 方法的作用域会更广一些，任何一个 Context 的实例，只要调用 getApplicationContext()方法都可以拿到我们的 Application 对象。</p>
<p>4、创建对话框时不可以用 Application 的 context，只能用 Activity 的 context。</p>
<p>5、Context 的数量等于 Activity 的个数 + Service 的个数 +1，这个 1 为 Application。</p>
<h3 id="View-的事件分发机制？滑动冲突怎么解决？"><a href="#View-的事件分发机制？滑动冲突怎么解决？" class="headerlink" title="View 的事件分发机制？滑动冲突怎么解决？"></a>View 的事件分发机制？滑动冲突怎么解决？</h3><p>了解 Activity 的构成</p>
<p>一个 Activity 包含了一个 Window 对象，这个对象是由 PhoneWindow 来实现的。 PhoneWindow 将 DecorView 作为整个应用窗口的根 View，而这个 DecorView 又将屏幕划分为两个区域：一个是 TitleView，另一个是 ContentView，而我们 平时所写的就是展示在 ContentView 中的。</p>
<p>触摸事件的类型</p>
<p>触摸事件对应的是 MotionEvent 类，事件的类型主要有如下三种：ACTION_DOWN、ACTION_MOVE(移动的距离超过一定的阈值会被判定为 ACTION_MOVE 操作) 、ACTION_UP</p>
<p>View 事件分发本质就是对 MotionEvent 事件分发的过程。即当一个 MotionEvent 发生后，系统将这个点击事件传递到一个具体的 View 上。</p>
<p>事件分发流程</p>
<p>事件分发过程由三个方法共同完成： dispatchTouchEvent：方法返回值为 true 表示事件被当前视图消费掉；返回为 super.dispatchTouchEvent 表示继续分发该事件，返回为 false 表示交给父类的 onTouchEvent 处理。</p>
<p>onInterceptTouchEvent：方法返回值为 true 表示拦截这个事件并交由自身的 onTouchEvent 方法进行消费；返回 false 表示不拦截，需要继续传递给子视图。 如果 return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: </p>
<p>1.如果该View存在子View且点击到了该子View, 则不拦截, 继续分发 给 子 View 处理, 此时相当于 return false。</p>
<p>2.如果该 View 没有子 View 或者有子 View 但是没有点击中子 View(此时 ViewGroup 相当于普通 View), 则交由该 View 的 onTouchEvent 响应，此 时相当于 return true。</p>
<p>注意：一般的 LinearLayout、 RelativeLayout、FrameLayout 等 ViewGroup 默认 不拦截， 而 ScrollView、ListView 等 ViewGroup 则可能拦截，得看具体情况。</p>
<p>onTouchEvent：方法返回值为 true 表示当前视图可以处理对应的事件；返回值 为 false 表示当前视图不处理这个事件，它会被传递给父视图的 onTouchEvent 方法进行处理。如果 return super.onTouchEvent(ev)，事件处理分为两种情况：</p>
<p>1.如果该 View 是 clickable 或者 longclickable 的,则会返回 true, 表示消费 了该事件, 与返回 true 一样;</p>
<p>2.如果该 View 不是 clickable 或者 longclickable 的,则会返回 false, 表示不 消费该事件,将会向上传递,与返回 false 一样。</p>
<p>注意：在 Android 系统中，拥有事件传递处理能力的类有以下三种：</p>
<p>Activity：拥有分发和消费两个方法。 ViewGroup：拥有分发、拦截和消费三个方法。 View：拥有分发、消费两个方法。</p>
<p>三个方法的关系用伪代码表示如下：</p>
<p>public boolean dispatchTouchEvent(MotionEvent ev) { </p>
<p>boolean consume = false; </p>
<p>if (onInterceptTouchEvent(ev)) {</p>
<p>consume = onTouchEvent(ev); </p>
<p>} else {</p>
<p>coonsume = child.dispatchTouchEvent(ev); </p>
<p>}</p>
<p>return consume;</p>
<p>}</p>
<p>通过上面的伪代码，我们可以大致了解点击事件的传递规则：对应一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，这是它的 dispatchTouchEvent 就会被调用，如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 true 就表示它要拦截当前事件，接着事件就会 交给这个 ViewGroup 处理，这时如果它的 mOnTouchListener 被设置，则 onTouch 会被调用，否则 onTouchEvent 会被调用。在 onTouchEvent 中，如果 设置了 mOnCLickListener，则 onClick 会被调用。只要 View 的 CLICKABLE 和 LONG_CLICKABLE 有一个为 true，onTouchEvent()就会返回 true 消耗这个事件。 如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 false 就表示它不拦截 当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 dispatchTouchEvent 方法就会被调用，如此反复直到事件被最终处理。</p>
<p>一些重要的结论：</p>
<p>1、事件传递优先级：onTouchListener.onTouch &gt; onTouchEvent &gt; onClickListener.onClick。 2、正常情况下，一个时间序列只能被一个 View 拦截且消耗。因为一旦一个元 素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不 会再调用这个 View 的拦截方法去询问它是否要拦截了，而是把剩余的 ACTION_MOVE、ACTION_DOWN 等事件直接交给它来处理）。特例：通过将重 写 View 的 onTouchEvent 返回 false 可强行将事件转交给其他 View 处理。</p>
<p>3、如果 View 不消耗除 ACTION_DOWN 以外的其他事件，那么这个点击事件会 消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续收 到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。</p>
<p>4、ViewGroup 默认不拦截任何事件（返回 false）。</p>
<p>5、View 的 onTouchEvent 默认都会消耗事件（返回 true），除非它是不可点击 的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认 都为 false，clickable 属性要分情况，比如 Button 的 clickable 属性默认为 true， 而 TextView 的 clickable 默认为 false。</p>
<p>6、View 的 enable 属性不影响 onTouchEvent 的默认返回值。</p>
<p>7、通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的 事件分发过程，但是 ACTION_DOWN 事件除外。</p>
<p>ACTION_CANCEL 什么时候触发，触摸 button 然后滑动到外部抬起会触发点 击事件吗，再滑动回去抬起会么？</p>
<p>一般 ACTION_CANCEL 和 ACTION_UP 都作为 View 一段事件处理的结束。</p>
<p>如果在父 View 中拦截 ACTION_UP 或 ACTION_MOVE，在第一次父视图 拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收 到 ACTION_CANCEL 事件。 </p>
<p>如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地 方了），就会出现 action_cancel。</p>
<p>点击事件被拦截，但是想传到下面的 View， 如何操作？</p>
<p>重写子类的 requestDisallowInterceptTouchEvent()方法返回 true 就不会执行父类的 onInterceptTouchEvent()，即可将点击事件传到下面的 View。</p>
<p>如何解决 View 的事件冲突？举个开发中遇到的例子？</p>
<p>常见开发中事件冲突的有 ScrollView 与 RecyclerView 的滑动冲突、RecyclerView 内嵌同时滑动同一方向。 滑动冲突的处理规则：</p>
<p>对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动 的方向判断谁来拦截事件。对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业 务需求，规定何时让外部 View 拦截事件，何时由内部 View 拦截事件。 对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破 点。</p>
<p>滑动冲突的实现方法：</p>
<p>外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此 事件就拦截，否则就不拦截。具体方法：需要重写父容器的 onInterceptTouchEvent 方法，在内部做出相应的拦截。 </p>
<p>内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器， 如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方 法：需要配合 requestDisallowInterceptTouchEvent 方法。</p>
<h3 id="View-的绘制流程"><a href="#View-的绘制流程" class="headerlink" title="View 的绘制流程"></a>View 的绘制流程</h3><p>DecorView 被加载到 Window 中</p>
<p>从 Activity 的 startActivity 开 始 ， 最 终 调 用 到 ActivityThread 的 handleLaunchActivity 方 法 来 创 建 Activity ， 首 先 ， 会 调 用 performLaunchActivity 方法，内部会执行 Activity 的 onCreate 方法，从 而 完 成 DecorView 和 Activity 的 创 建 。 然 后 ， 会 调 用 handleResumeActivity，里面首先会调用 performResumeActivity 去执行 Activity 的 onResume()方法， 执行完后会得到一个 ActivityClientRecord 对象，然后通过 r.window.getDecorView()的方式得到 DecorView，然后会 通 过 a.getWindowManager() 得 到 WindowManager ， 最 终 调 用 其 addView()方法将 DecorView 加进去。 </p>
<p>WindowManager 的 实 现 类 是 WindowManagerImpl ， 它 内 部 会 将 addView 的逻辑委托给 WindowManagerGlobal，可见这里使用了接口隔 离和委托模式将实现和抽象充分解耦。 在 WindowManagerGlobal 的 addView()方法中不仅会将 DecorView 添加到 Window 中， 同时会创建 ViewRootImpl 对 象 ， 并 将 ViewRootImpl 对 象 和 DecorView 通 过 root.setView()把 DecorView 加载到 Window 中。 这里的 ViewRootImpl 是 ViewRoot 的实现类，是连接 WindowManager 和 DecorView 的纽带。 View 的三大流程均是通过 ViewRoot 来完成的。</p>
<p>了解绘制的整体流程</p>
<p>绘制会从根视图 ViewRoot 的 performTraversals()方法开始，从上到下遍历整个 视图树，每个 View 控件负责绘制自己，而 ViewGroup 还需要负责通知自己的子 View 进行绘制操作。 理解 MeasureSpec</p>
<p>MeasureSpec 表示的是一个 32 位的整形值，它的高 2 位表示测量模式 SpecMode，低 30 位表示某种测量模式下的规格大小 SpecSize。MeasureSpec</p>
<p>是 View 类的一个静态内部类，用来说明应该如何测量这个 View。它由三种测量 模式，如下：</p>
<p>EXACTLY：精确测量模式，视图宽高指定为 match_parent 或具体数值时生效，表示父视图已经决定了子视图的精确大小，这种模式下 View 的测量值就是 SpecSize 的值。</p>
<p>AT_MOST：最大值测量模式，当视图的宽高指定为 wrap_content 时生效， 此时子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。 UNSPECIFIED：不指定测量模式, 父视图没有限制子视图的大小，子视图 可以是想要的任何尺寸，通常用于系统内部，应用开发中很少用到。</p>
<p>MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对 象内存分配，为了方便操作，其提供了打包和解包的方法，打包方法为 makeMeasureSpec，解包方法为 getMode 和 getSize。</p>
<p>普通 View 的 MeasureSpec 的创建规则如下：</p>
<p>对于 DecorView 而言，它的 MeasureSpec 由窗口尺寸和其自身的 LayoutParams共同决定；对于普通的 View，它的 MeasureSpec 由父视图的 MeasureSpec 和其自身的 LayoutParams 共同决定。</p>
<h4 id="如何根据-MeasureSpec-去实现一个瀑布流的自定义-ViewGroup？"><a href="#如何根据-MeasureSpec-去实现一个瀑布流的自定义-ViewGroup？" class="headerlink" title="如何根据 MeasureSpec 去实现一个瀑布流的自定义 ViewGroup？"></a>如何根据 MeasureSpec 去实现一个瀑布流的自定义 ViewGroup？</h4><h4 id="View-绘制流程之-Measure"><a href="#View-绘制流程之-Measure" class="headerlink" title="View 绘制流程之 Measure"></a>View 绘制流程之 Measure</h4><p>首 先 ， 在 ViewGroup 中 的 measureChildren() 方 法 中 会 遍 历 测 量 ViewGroup 中所有的 View，当 View 的可见性处于 GONE 状态时，不对 其进行测量。 然后，测量某个指定的 View 时，根据父容器的 MeasureSpec 和子 View 的 LayoutParams 等信息计算子 View 的 MeasureSpec。 最后， 将计算出的 MeasureSpec 传入 View 的 measure 方法， 这里 ViewGroup 没有定义测量的具体过程，因为 ViewGroup 是一个抽象类， 其测量过程的 onMeasure 方法需要各个子类去实现。不同的 ViewGroup 子类有不同的布局特性，这导致它们的测量细节各不相同，如果需要自定 义测量过程，则子类可以重写这个方法。（setMeasureDimension 方法用 于设置 View 的测量宽高，如果 View 没有重写 onMeasure 方法，则会默 认调用 getDefaultSize 来获得 View 的宽高）</p>
<p>getSuggestMinimumWidth 分析</p>
<p>如果 View 没有设置背景，那么返回 android:minWidth 这个属性所指定的值，这 个值可以为 0；如果 View 设置了背景，则返回 android:minWidth 和背景的最小 宽度这两者中的最大值。</p>
<p>自定义 View 时手动处理 wrap_content 时的情形</p>
<p>直接继承 View 的控件需要重写 onMeasure 方法并设置 wrap_content 时的自身 大小，否则在布局中使用 wrap_content 就相当于使用 match_parent。此时，可 以在 wrap_content 的情况下（对应 MeasureSpec.AT_MOST）指定内部宽/高 (mWidth 和 mHeight)。 LinearLayout 的 onMeasure 方法实现解析（这里仅分析 measureVertical 核心源码）</p>
<p>系统会遍历子元素并对每个子元素执行 measureChildBeforeLayout 方法，这个 方法内部会调用子元素的 measure 方法，这样各个子元素就开始依次进入 measure 过程，并且系统会通过 mTotalLength 这个变量来存储 LinearLayout 在 竖直方向的初步高度。每测量一个子元素，mTotalLength 就会增加，增加的部 分主要包括了子元素的高度以及子元素在竖直方向上的 margin 等。</p>
<p>在Activity中获取某个View的宽高</p>
<p>由于View的measure过程和Activity的生命周期方法不是同步执行的，如果View 还没有测量完毕，那么获得的宽/高就是 0。所以在 onCreate、onStart、onResume 中均无法正确得到某个 View 的宽高信息。解决方式如下：</p>
<p>Activity/View#onWindowFocusChanged：此时 View 已经初始化完毕， 当 Activity 的窗口得到焦点和失去焦点时均会被调用一次，如果频繁地进 行 onResume 和 onPause，那么 onWindowFocusChanged 也会被频繁地 调用。 view.post(runnable)： 通过 post 可以将一个 runnable 投递到消息队列的 尾部，始化好了然后等待 Looper 调用次 runnable 的时候，View 也已经 初始化好了。 ViewTreeObserver#addOnGlobalLayoutListener：当 View 树的状态发生 改变或者 View 树内部的 View 的可见性发生改变时，onGlobalLayout 方 法将被回调。 View.measure(int widthMeasureSpec, int heightMeasureSpec) ： match_parent 时不知道 parentSize 的大小，测不出；具体数值时，直接 makeMeasureSpec 固 定 值 ， 然 后 调 用 view..measure 就 可 以 了 ； wrap_content 时，在最大化模式下，用 View 理论上能支持的最大值去构 造 MeasureSpec 是合理的。</p>
<h4 id="View-的绘制流程之-Layout"><a href="#View-的绘制流程之-Layout" class="headerlink" title="View 的绘制流程之 Layout"></a>View 的绘制流程之 Layout</h4><p>首先，会通过 setFrame 方法来设定 View 的四个顶点的位置，即 View 在父容器 中的位置。然后，会执行到 onLayout 空方法，子类如果是 ViewGroup 类型，则 重写这个方法，实现 ViewGroup 中所有 View 控件布局流程。</p>
<p>LinearLayout 的 onLayout 方法实现解析（layoutVertical 核心源码）</p>
<p>其中会遍历调用每个子 View 的 setChildFrame 方法为子元素确定对应的位置。 其中的 childTop 会逐渐增大，意味着后面的子元素会被放置在靠下的位置。</p>
<p>注意：在 View 的默认实现中，View 的测量宽/高和最终宽/高是相等的，只不过 测量宽/高形成于 View 的 measure 过程，而最终宽/高形成于 View 的 layout 过 程，即两者的赋值时机不同，测量宽/高的赋值时机稍微早一些。在一些特殊的 情况下则两者不相等：</p>
<p>重写 View 的 layout 方法,使最终宽度总是比测量宽/高大 100px。 </p>
<p>View 需要多次 measure 才能确定自己的测量宽/高，在前几次测量的过程 中，其得出的测量宽/高有可能和最终宽/高不一致，但最终来说，测量宽 /高还是和最终宽/高相同。</p>
<h4 id="View-的绘制流程之-Draw"><a href="#View-的绘制流程之-Draw" class="headerlink" title="View 的绘制流程之 Draw"></a>View 的绘制流程之 Draw</h4><p>Draw 的基本流程</p>
<p>绘制基本上可以分为六个步骤： </p>
<p>首先绘制 View 的背景；</p>
<p> 如果需要的话，保持 canvas 的图层，为 fading 做准备； </p>
<p>然后，绘制 View 的内容； </p>
<p>接着，绘制 View 的子 View； </p>
<p>如果需要的话，绘制 View 的 fading 边缘并恢复图层； </p>
<p>最后，绘制 View 的装饰(例如滚动条等等)。</p>
<h4 id="setWillNotDraw-的作用"><a href="#setWillNotDraw-的作用" class="headerlink" title="setWillNotDraw 的作用"></a>setWillNotDraw 的作用</h4><p>如果一个 View 不需要绘制任何内容，那么设置这个标记位为 true 以后，系统会 进行相应的优化。 </p>
<p>默认情况下，View 没有启用这个优化标记位，但是 ViewGroup 会默认启 用这个优化标记位。  当我们的自定义控件继承于 ViewGroup 并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。  当明确知道一个 ViewGroup 需要通过 onDraw 来绘制内容时，我们需要显示地关闭 WILL_NOT_DRAW 这个标记位。</p>
<p>requestLayout()方法 ：会导致调用 measure()过程 和 layout()过程，将会根据 标志位判断是否需要 ondraw。</p>
<h3 id="Handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析</h3><ol>
<li>消息是通过 MessageQueen 中的 enqueueMessage()方法加入消息队列中的，并 且它在放入中就进行好排序，链表头的延迟时间小，尾部延迟时间最大</li>
<li>Looper.loop()通过 MessageQueue 中的 next()去取消息</li>
<li>next()中如果当前链表头部消息是延迟消息，则根据延迟时间进行消息队列会 阻塞，不返回给 Looper message，直到时间到了，返回给 message</li>
<li>如果在阻塞中有新的消息插入到链表头部则唤醒线程</li>
<li>Looper 将新消息交给回调给 handler 中的 handleMessage 后，继续调用MessageQueen 的 next()方法，如果刚刚的延迟消息还是时间未到，则计算时间 继续阻塞</li>
</ol>
<h5 id="屏障消息"><a href="#屏障消息" class="headerlink" title="屏障消息"></a>屏障消息</h5><p>在ViewRootImpl中scheduleTraversals里面先调用postSyncBarrier发送同步消息(message中没有target)，然后向Choreographer注册同步回调监听接口，收到同步回调后向handler发送异步消息。在messagequeue中next取消息时，一旦发现没有target的消息，则优先执行异步消息。</p>
<p>设置了屏障消息，此时只会处理异步消息，处理完异步消息后就会堵塞。如果想要恢复同步消息，需要调用 removeSyncBarrier()移除。</p>
<p>子线程中Toast和Dialog的show发生crash原因：Toast和dialog里面有使用到new Handler()，如果子线程没有Looper.prepare();则会导致crash。</p>
<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>为什么选用 Binder，在讨论这个问题之前，我们知道 Android 也是基于 Linux 内核，Linux 现有的进程通信手段有以下几种：</p>
<p>1.管道：在创建时分配一个 page 大小的内存，缓存区大小比较有限；<br>2.消息队列：信息复制两次，额外的 CPU 消耗；不合适频繁或信息量大的通信；<br>3.共享内存：无须复制，共享缓冲区直接附加到进程虚拟地址空间，速度快； 但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；<br>4.套接字：作为更通用的接口，传输效率低，主要用于不同机器或跨网络的 通信；<br>5.信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程 也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同 步手段。 不适用于信息交换，更适用于进程中断控制，比如非法内存访 问，杀死某个进程等；</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：<br>1.首先 Binder 驱动在内核空间创建一个数据接收缓存区。<br>2.接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收 缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间 地址的映射关系。<br>3.发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也 就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间 的通信。</p>
<p>Binder系列1—Binder Driver初探</p>
<h3 id="AMS解析"><a href="#AMS解析" class="headerlink" title="AMS解析"></a>AMS解析</h3><p>1.ActivityManagerServices，简称 AMS，服务端对象，负责系统中所有 Activity 的生命周期。</p>
<p>2.ActivityThread，App 的真正入口。当开启 App 之后，调用 main()开始运行， 开启消息循环队列，这就是传说的 UI 线程或者叫主线程。与 ActivityManagerService 一起完成 Activity 的管理工作。 3.ApplicationThread，用来实现 ActivityManagerServie 与 ActivityThread 之间的 交互。在 ActivityManagerSevice 需要管理相关 Application 中的 Activity 的生命 周期时，通过 ApplicationThread 的代理对象与 ActivityThread 通信。</p>
<p>4.ApplicationThreadProxy，是 ApplicationThread 在服务器端的代理，负责和客 户端的 ApplicationThread 通信。AMS 就是通过该代理与 ActivityThread 进行通 信的。</p>
<p>5.Instrumentation，每一个应用程序只有一个 Instrumetation 对象，每个 Activity 内都有一个对该对象的引用，Instrumentation 可以理解为应用进程的管家， ActivityThread 要创建或暂停某个 Activity 时，都需要通过 Instrumentation 来进 行具体的操作。</p>
<p>6.ActivityStack，Activity 在 AMS 的栈管理，用来记录经启动的 Activity 的先后 关系，状态信息等。通过 ActivtyStack 决定是否需要启动新的进程。</p>
<p>7.ActivityRecord，ActivityStack 的管理对象，每个 Acivity 在 AMS 对应一个 ActivityRecord，来记录 Activity 状态以及其他的管理信息。其实就是服务器端的 Activit 对象的映像。</p>
<p>8.TaskRecord，AMS 抽象出来的一个“任务”的概念，是记录 ActivityRecord 的栈， 一个“Task”包含若干个 ActivityRecord。AMS 用 TaskRecord 确保 Activity 启动和 退出的顺序。如果你清楚 Activity 的 4 种 launchMode，那么对这概念应该不陌 生。</p>
<p>调用流程：<br>1、点击桌面应用图标，Launcher 进程将启动 Activity（MainActivity）的 请求以 Binder 的方式发送给了 AMS。<br>2、AMS 接收到启动请求后，交付 ActivityStarter 处理 Intent 和 Flag 等信 息，然后再交给 ActivityStackSupervisior/ActivityStack 处理 Activity 进栈 相关流程。同时以 Socket 方式请求 Zygote 进程 fork 新进程。<br>3、Zygote 接收到新进程创建请求后 fork 出新进程。<br>4、在新进程里创建 ActivityThread 对象，新创建的进程就是应用的主线 程，在主线程里开启 Looper 消息循环，开始处理创建 Activity。<br>5、ActivityThread 利用 ClassLoader 去加载 Activity、创建 Activity 实例， 并回调 Activity 的 onCreate()方法，这样便完成了 Activity 的启动。</p>
<h3 id="Window-和-WindowManager"><a href="#Window-和-WindowManager" class="headerlink" title="Window 和 WindowManager"></a>Window 和 WindowManager</h3><p>1.Window 用于显示 View 和接收各种事件，Window 有三种型：应用 Window(每 个 Activity 对应一个 Window)、子 Widow(不能单独存在，附属于特定 Window)、 系统 window(toast 和状态栏)<br>2.Window分层级，应用Window在1-99、子Window在1000-1999、系统Window 在 2000-2999.WindowManager 提供了增删改 View 的三个功能。<br>3.Window 是个抽象概念：每一个 Window 对应着一个 ViewRootImpl，Window 通过 ViewRootImpl 来和 View 建立联系，View 是 Window 存在的实体，只能通 过 WindowManager 来访问 Window。<br>4.WindowManager 的实现是 WindowManagerImpl，其再委托 WindowManagerGlobal 来对 Window 进行操作，其中有四种 List 分别储存对应 的 View、ViewRootImpl、WindowManger.LayoutParams 和正在被删除的 View。<br>5.Window 的实体是存在于远端的 WindowMangerService，所以增删改 Window 在本端是修改上面的几个 List 然后通过 ViewRootImpl 重绘 View，通过 WindowSession(每 Window 个对应一个)在远端修改 Window。<br>6.Activity 创建 Window：Activity 会在 attach()中创建 Window 并设置其回调 (onAttachedToWindow()、dispatchTouchEvent())，Activity 的 Window 是由 Policy 类创建 PhoneWindow 实现的。然后通过 Activity#setContentView()调用 PhoneWindow 的 setContentView。</p>
<h3 id="Android系统的启动过程"><a href="#Android系统的启动过程" class="headerlink" title="Android系统的启动过程"></a>Android系统的启动过程</h3><ol>
<li>linux内核启动后会启动第一个用户空间进程Init(pId=1),Init进程会解析和分析init.rc文件，rc文件中配置了各种程序和服务的启动项</li>
<li>在init.rc中也配置了Zygote进程的启动项，Zygote进程的执行文件/system/bin/app_process，实现代码为app_main.cpp，在main方法中启动了AppRuntime虚拟机，同时指定虚拟机执行com.android.internal.os.ZygoteInit，进入java世界</li>
<li>ZygoteInit的main方法中registerZygoteSocket(注册socket长连接)、preloadClasses、preloadResources、startSystemServer（开启system_server进程）、runSelectLoop(Zygote执行死循环监听socket)</li>
<li>startSystemServer中fork出system_server进程后执行handleSystemServerProcess初始化相关信息，其中层层调用到app_main.cpp中的onZygoteInit方法来初始化binder线程池。其中的RuntimeInit.zygoteInit故意抛出异常，ZygoteInit的main方法中捕获该异常，然后使用反射的方式执行异常中指定的class和method（system_server进程是SystemServer.main,该参数在startSystemServer方法中由代码指定；普通应用进程是ActivityThread.main，该参数从socket中读取）。SystemServer.main中启动system_server进程中的各种系统服务。</li>
</ol>
<h3 id="APK安装"><a href="#APK安装" class="headerlink" title="APK安装"></a>APK安装</h3><p>复制 APK 到/data/app 目录下，解压并扫描安装包。</p>
<p>资源管理器解析 APK 里的资源文件。</p>
<p>解析 AndroidManifest 文件，并在/data/data/目录下创建对应的应用数据目录。</p>
<p>然后对 dex 文件进行优化，并保存在 dalvik-cache 目录下。</p>
<p>将 AndroidManifest 文件解析出的四大组件信息注册到 PackageManagerService 中。</p>
<p>安装完成后，发送广播。</p>
<h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><p>1.通过 AAPT 工具进行资源文件（包括 AndroidManifest.xml、布局文件、 各种 xml 资源等）的打包，生成 R.java 文件。<br>2.通过 AIDL 工具处理 AIDL 文件，生成相应的 Java 文件。<br>3.通过 Java Compiler 编译 R.java、Java 接口文件、Java 源文件，生成.class 文件。<br>4.通 过 dex 命 令 ， 将 .class 文 件 和第 三 方 库 中 的 .class 文 件 处 理生成 classes.dex，该过程主要完成 Java 字节码转换成 Dalvik 字节码，压缩常 量池以及清除冗余信息等工作。<br>5.通过 ApkBuilder 工具将资源文件、DEX 文件打包生成 APK 文件。<br>6.通过 Jarsigner 工具，利用 KeyStore 对生成的 APK 文件进行签名。<br>7.如果是正式版的 APK，还会利用 ZipAlign 工具进行对齐处理，对齐的过 程就是将 APK 文件中所有的资源文件距离文件的起始距位置都偏移 4 字 节的整数倍，这样通过内存映射访问 APK 文件的速度会更快，并且会减 少其在设备上运行时的内存占用。 </p>
<p>apk 组成<br>1.dex：最终生成的 Dalvik 字节码。<br>2.res：存放资源文件的目录。<br>3.asserts：额外建立的资源文件夹。<br>4.lib：如果存在的话，存放的是 ndk 编出来的 so 库。<br>5.META-INF：存放签名信息 MANIFEST.MF（清单文件）：其中每一个资源文件都有一个 SHA-256-Digest 签 名，MANIFEST.MF 文件的 SHA256（SHA1）并 base64 编码的结果即为 CERT.SF 中的 SHA256-Digest-Manifest 值。</p>
<p>CERT.SF（待签名文件）：除了开头处定义的 SHA256（SHA1）-Digest-Manifest 值，后面几项的值是对 MANIFEST.MF 文件中的每项再次 SHA256 并 base64 编 码后的值。<br>CERT.RSA（签名结果文件）：其中包含了公钥、加密算法等信息。首先对前一 步生成的 MANIFEST.MF 使用了 SHA256（SHA1）-RSA 算法，用开发者私钥签 名，然后在安装时使用公钥解密。最后，将其与未加密的摘要信息（MANIFEST.MF 文件）进行对比，如果相符，则表明内容没有被修改。</p>
<p>androidManifest：程序的全局清单配置文件。<br>resources.arsc：编译后的二进制资源文件</p>
<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><h4 id="v1签名"><a href="#v1签名" class="headerlink" title="v1签名"></a>v1签名</h4><p>1.对Apk中的每个文件做一次算法(数据摘要+Base64编码)，保存到MANIFEST.MF文件中<br>2.对MANIFEST.MF整个文件做一次算法(数据摘要+Base64编码)，存放到CERT.SF文件的头属性中，在对MANIFEST.MF文件中各个属性块做一次算法(数据摘要+Base64编码)，存到到一个属性块中<br>3.对CERT.SF文件做签名，内容存档到CERT.RSA中</p>
<h4 id="V2签名（Android-7-0）"><a href="#V2签名（Android-7-0）" class="headerlink" title="V2签名（Android 7.0）"></a>V2签名（Android 7.0）</h4><p>由于在 v1 仅针对单个 ZIP 条目进行验证，因此，在 APK 签署后可进行许多修改 — 可以移动甚至重新压缩文件。事实上，编译过程中要用到的 ZIPalign 工具就是这么做的，它用于根据正确的字节限制调整 ZIP 条目，以改进运行时性能。而且我们也可以利用这个东西，在打包之后修改 META-INF 目录下面的内容，或者修改 ZIP 的注释来实现多渠道的打包，在 v1 签名中都可以校验通过。</p>
<p>v2 签名将验证归档中的所有字节，而不是单个 ZIP 条目，因此，在签署后无法再运行 ZIPalign（必须在签名之前执行）。正因如此，现在，在编译过程中，Google 将压缩、调整和签署合并成一步完成。</p>
<p>签名过程</p>
<p>首先，说一下 APK 摘要计算规则，对于每个摘要算法，计算结果如下:</p>
<ul>
<li>将 APK 中文件 ZIP 条目的内容、ZIP 中央目录、ZIP 中央目录结尾按照 1MB 大小分割成一些小块。</li>
<li>计算每个小块的数据摘要，数据内容是 0xa5 + 块字节长度 + 块内容。</li>
<li>计算整体的数据摘要，数据内容是 0x5a + 数据块的数量 + 每个数据块的摘要内容</li>
</ul>
<p>总之，就是把 APK 按照 1M 大小分割，分别计算这些分段的摘要，最后把这些分段的摘要在进行计算得到最终的摘要也就是 APK 的摘要。然后将 APK 的摘要 + 数字证书 + 其他属性生成签名数据写入到 APK Signing Block 区块。</p>
<h4 id="V3签名（Android-9-0）"><a href="#V3签名（Android-9-0）" class="headerlink" title="V3签名（Android 9.0）"></a>V3签名（Android 9.0）</h4><p>新版v3签名在v2的基础上，仍然采用检查整个压缩包的校验方式。不同的是在签名部分增可以添加新的证书（Attr块）。在这个新块中，会记录我们之前的签名信息以及新的签名信息，以密钥转轮的方案，来做签名的替换和升级。这意味着，只要旧签名证书在手，我们就可以通过它在新的 APK 文件中，更改签名。</p>
<p>v3 签名新增的新块（attr）存储了所有的签名信息，由更小的 Level 块，以链表的形式存储。</p>
<p>其中每个节点都包含用于为之前版本的应用签名的签名证书，最旧的签名证书对应根节点，系统会让每个节点中的证书为列表中下一个证书签名，从而为每个新密钥提供证据来证明它应该像旧密钥一样可信。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h3 id="Davilk、ART区别"><a href="#Davilk、ART区别" class="headerlink" title="Davilk、ART区别"></a>Davilk、ART区别</h3><p>Dalvik:从安卓诞生之初到4.4版本，最开始使用解析器解析字节码，在2.2中引入JIT编译器，使得Dalvik 的性能提升了 3~6 倍。但是由于JIT每次启动应用都要重新编译，导致耗电严重。在4.4中引入ART虚拟机的预览版和AOT编译策略，此时Davilk和ART是共存的，用户可以自由选择。</p>
<p>ART：5.0时正式取代Dalvik，AOT也成为唯一的编译策略，同时也改成了GC的过程。AOT虽然解决了每次都要重新编译和耗电的问题，但是也引入了新问题：应用安装和系统升级之后的应用优化比较耗时、优化后的文件会占用额外的存储空间。于是在7.0的时候JIT编译器回归，这种混合编译的特点：</p>
<ol>
<li>应用在安装的时候 dex 不会被编译；</li>
<li>应用在运行时 dex 文件先通过解析器（Interpreter）后会被直接执行，与此同时，热点函数（Hot Code）会被识别并被 JIT 编译后存储在 jit code cache 中并生成 profile 文件以记录热点函数的信息；</li>
<li>手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译。</li>
</ol>
<p>混合编译模式综合了 AOT 和 JIT 的各种优点，使得应用在安装速度加快的同时，运行速度、存储空间和耗电量等指标都得到了优化。</p>
<p>OT 和 JIT 的不同之处在于：JIT 是在运行时进行编译，是动态编译，并且每次运行程序的时候都需要对 odex 重新进行编译；而 AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex 预编译成 ELF 文件，每次运行程序的时候不用重新编译，是真正意义上的本地应用。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903748058218509">详细参考</a></p>
<h3 id="ART-和-Davlik-中垃圾回收的区别"><a href="#ART-和-Davlik-中垃圾回收的区别" class="headerlink" title="ART 和 Davlik 中垃圾回收的区别"></a>ART 和 Davlik 中垃圾回收的区别</h3><h3 id="安卓内存管理"><a href="#安卓内存管理" class="headerlink" title="安卓内存管理"></a>安卓内存管理</h3><h3 id="App-是如何沙箱化"><a href="#App-是如何沙箱化" class="headerlink" title="App 是如何沙箱化"></a>App 是如何沙箱化</h3><h2 id="3-项目"><a href="#3-项目" class="headerlink" title="3. 项目"></a>3. 项目</h2><h3 id="应用更新"><a href="#应用更新" class="headerlink" title="应用更新"></a>应用更新</h3><p>灰度，强制更新，分区域更新</p>
<p>1、通过接口获取线上版本号，versionCode 2、比较线上的 versionCode 和本地 的 versionCode，弹出更新窗口 3、下载 APK 文件（文件下载） 4、安装 APK</p>
<p>灰度： (1)找单一渠道投放特别版本。 (2)做升级平台的改造，允许针对部分用 户推送升级通知甚至版本强制升级。 (3)开放单独的下载入口。 (4)是两个版本 的代码都打到 app 包里，然后在 app 端植入测试框架，用来控制显示哪个版本。 测试框架负责与服务器端 api 通信，由服务器端控制 app 上 A/B 版本的分布， 可以实现指定的一组用户看到 A 版本，其它用户看到 B 版本。服务端会有相应 的报表来显示 A/B 版本的数量和效果对比。最后可以由服务端的后台来控制，全 部用户在线切换到 A 或者 B 版本~ 无论哪种方法都需要做好版本管理工作，分配特别的版本号以示区别。 当然， 既然是做灰度，数据监控（常规数据、新特性数据、主要业务数据）还是要做到 位，该打的数据桩要打。 还有，灰度版最好有收回的能力，一般就是强制升级 下一个正式版。 强制更新:一般的处理就是进入应用就弹窗通知用户有版本更新，弹窗可以没有 取消按钮并不能取消。这样用户就只能选择更新或者关闭应用了，当然也可以添 加取消按钮，但是如果用户选择取消则直接退出应用。 增量更新：bsdiff：二进制差分工具 bsdiff 是相应的补丁合成工具,根据两个不同 版本的二进制文件，生成补丁文件.patch 文件。通过 bspatch 使旧的 apk 文件与 不定文件合成新的 apk。 注意通过 apk 文件的 md5 值进行区分版本。</p>
<h3 id="OkHttp-实现原理"><a href="#OkHttp-实现原理" class="headerlink" title="OkHttp 实现原理"></a>OkHttp 实现原理</h3><p>网络底层库，它是基于 http 协议封装的一套请求客户端，虽然它也可以开线程， 但根本上它更偏向真正的请求，跟 HttpClient, HttpUrlConnection 的职责是一样 的。其中封装了网络请求 get、post 等底层操作的实现。</p>
<p>为什么要在项目中使用这个库？</p>
<p>1.OkHttp 提供了对最新的 HTTP 协议版本 HTTP/2 和 SPDY 的支持，这 使得对同一个主机发出的所有请求都可以共享相同的套接字连接。<br>2.如果 HTTP/2 和 SPDY 不可用，OkHttp 会使用连接池来复用连接以提 高效率。<br>3.OkHttp 提供了对 GZIP 的默认支持来降低传输内容的大小。<br>4.OkHttp 也提供了对 HTTP 响应的缓存机制，可以避免不必要的网络请求。<br>5.当网络出现问题时，OkHttp 会自动重试一个主机的多个 IP 地址。</p>
<p>OkHttp 内部的请求流程：使用 OkHttp 会在请求的时候初始化一个 Call 的实例， 然后执行它的 execute()方法或 enqueue()方法，内部最后都会执行到 getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任 链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、 连接拦截器和用户自定义网络拦截器以及访问服务器拦截器等拦截处理过程，来 获取到一个响应并交给用户。其中，除了 OKHttp 的内部请求流程这点之外，缓存和连接这两部分内容也是两个很重要的点，掌握了这 3 点就说明你理解了OkHttp。</p>
<p>各个拦截器的作用：</p>
<p>interceptors：用户自定义拦截器<br>retryAndFollowUpInterceptor：负责失败重试以及重定向<br>BridgeInterceptor：请求时，对必要的 Header 进行一些添加，接收响应时，移除必要的 Header<br>CacheInterceptor：负责读取缓存直接返回（根据请求的信息和缓存的响 应的信息来判断是否存在缓存可用）、更新缓存<br>ConnectInterceptor：负责和服务器建立连接</p>
<p>ConnectionPool：</p>
<p>1、判断连接是否可用，不可用则从 ConnectionPool 获取连接，ConnectionPool</p>
<p>无连接，创建新连接，握手，放入 ConnectionPool。</p>
<p>2、它是一个 Deque，add 添加 Connection，使用线程池负责定时清理缓存。</p>
<p>3、使用连接复用省去了进行 TCP 和 TLS 握手的一个过程。</p>
<p>networkInterceptors：用户定义网络拦截器</p>
<p>CallServerInterceptor：负责向服务器发送请求数据、从服务器读取响应 数据</p>
<p>你从这个库中学到什么有价值的或者说可借鉴的设计思想？</p>
<p>使用责任链模式实现拦截器的分层设计，每一个拦截器对应一个功能，充分实现 了功能解耦，易维护。</p>
<h4 id="HttpUrlConnection-和-okhttp-关系"><a href="#HttpUrlConnection-和-okhttp-关系" class="headerlink" title="HttpUrlConnection 和 okhttp 关系"></a>HttpUrlConnection 和 okhttp 关系</h4><p>从Android4.4开始HttpURLConnection的底层实现采用的是okHttp。</p>
<h4 id="Volley-与-OkHttp-的对比："><a href="#Volley-与-OkHttp-的对比：" class="headerlink" title="Volley 与 OkHttp 的对比："></a>Volley 与 OkHttp 的对比：</h4><p>Volley：支持 HTTPS。缓存、异步请求，不支持同步请求。协议类型是 Http/1.0, Http/1.1，网络传输使用的是 HttpUrlConnection/HttpClient，数据读写使用的 IO。 OkHttp：支持 HTTPS。缓存、异步请求、同步请求。协议类型是 Http/1.0, Http/1.1, SPDY, Http/2.0, WebSocket，网络传输使用的是封装的 Socket，数据 读写使用的 NIO（Okio）。 SPDY 协议类似于 HTTP，但旨在缩短网页的加载时 间和提高安全性。SPDY 协议通过压缩、多路复用和优先级来缩短加载时间。</p>
<h4 id="衍生问题："><a href="#衍生问题：" class="headerlink" title="衍生问题："></a>衍生问题：</h4><p>自己去设计网络请求框架，怎么做？</p>
<p>从网络加载一个 10M 的图片，说下注意事项？</p>
<p>http怎么知道文件过大是否传输完毕的响应？</p>
<p>谈谈你对 WebSocket 的理解？</p>
<p>WebSocket 与 socket 的区别？</p>
<h3 id="Retrofit-实现原理"><a href="#Retrofit-实现原理" class="headerlink" title="Retrofit 实现原理"></a>Retrofit 实现原理</h3><p>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。Retrofit 2.0 开始内置OkHttp，前者专注于接口的封装，后者专注于网络请求的高效。</p>
<p>为什么要在项目中使用这个库？</p>
<p>1.功能强大：支持同步、异步；支持多种数据的解析 &amp; 序列化格式；支持 RxJava<br>2.简洁易用:通过注解配置网络请求参数;采用大量设计模式简化使用<br>3.可扩展性好:功能模块高度封装;解耦彻底，如自定义 Converters</p>
<p>Retrofit 主要是在 create 方法中采用动态代理模式（通过访问代理对象的方式来间接访问目标对象）实现接口方法，这个过程构建了一个 ServiceMethod 对象， 根据方法注解获取请求方式，参数类型和参数注解拼接请求的链接，当一切都准 备好之后会把数据添加到 Retrofit 的 RequestBuilder 中。然后当我们主动发起网 络请求的时候会调用 okhttp 发起网络请求，okhttp 的配置包括请求方式，URL 等在 Retrofit 的 RequestBuilder 的 build()方法中实现，并发起真正的网络请求。</p>
<p>内部使用了优秀的架构设计和大量的设计模式，在我分析过 Retrofit 最新版的源 码和大量优秀的 Retrofit 源码分析文章后，我发现，要想真正理解 Retrofit 内部 的核心源码流程和设计思想，首先，需要对它使用到的九大设计模式有一定的了 解，下面我简单说一说： </p>
<p>1、创建 Retrofit 实例：使用建造者模式通过内部 Builder 类建立了一个 Retroift 实例。 网络请求工厂使用了工厂方法模式。</p>
<p>2、创建网络请求接口的实例：<br>首先，使用外观模式统一调用创建网络请求接口实例和网络请求参数配置 的方法。 然后，使用动态代理动态地去创建网络请求接口实例。 接着，使用了建造者模式 &amp; 单例模式创建了 serviceMethod 对象。 再者，使用了策略模式对 serviceMethod 对象进行网络请求参数配置，即 通过解析网络请求接口方法的参数、返回值和注解类型，从 Retrofit 对象中获取对应的网络的 url 地址、网络请求执行器、网络请求适配器和数据 转换器。 最后，使用了装饰者模式 ExecuteCallBack 为 serviceMethod 对象加入线 程切换的操作，便于接受数据后通过 Handler 从子线程切换到主线程从而 对返回数据结果进行处理。</p>
<p>3、发送网络请求：<br>在异步请求时，通过静态 delegate 代理对网络请求接口的方法中的每个 参数使用对应的 ParameterHanlder 进行解析。</p>
<p>4、解析数据</p>
<p>5、切换线程：<br>使用了适配器模式通过检测不同的 Platform 使用不同的回调执行器，然 后使用回调执行器切换线程，这里同样是使用了装饰模式。</p>
<p>6、处理结果</p>
<h3 id="Rxjava"><a href="#Rxjava" class="headerlink" title="Rxjava"></a>Rxjava</h3><p>RxJava 变换操作符 map flatMap concatMap buffer</p>
<p>map：【数据类型转换】将被观察者发送的事件转换为另一种类型的事件。<br>flatMap：【化解循环嵌套和接口嵌套】将被观察者发送的事件序列进行 拆分 &amp; 转换 后合并成一个新的事件序列，最后再进行发送。<br>concatMap：【有序】与 flatMap 的 区别在于，拆分 &amp; 重新合并生成 的事件序列 的顺序与被观察者旧序列生产的顺序一致。<br>buffer：定期从被观察者发送的事件中获取一定数量的事件并放到缓存区 中，然后把这些数据集合打包发射。</p>
<h4 id="Rxjava-的线程池与你们自己实现任务管理框架"><a href="#Rxjava-的线程池与你们自己实现任务管理框架" class="headerlink" title="Rxjava 的线程池与你们自己实现任务管理框架?"></a>Rxjava 的线程池与你们自己实现任务管理框架?</h4><h3 id="图片缓存框架：Glide-amp-Fresco"><a href="#图片缓存框架：Glide-amp-Fresco" class="headerlink" title="图片缓存框架：Glide &amp; Fresco"></a>图片缓存框架：Glide &amp; Fresco</h3><h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h4><p>为什么要在项目中使用这个库？<br>1.多样化媒体加载：不仅可以进行图片缓存，还支持 Gif、WebP、缩略图，甚 至是 Video。<br>2.通过设置绑定生命周期：可以使加载图片的生命周期动态管理起来。<br>3.高效的缓存策略：支持内存、Disk 缓存，并且 Picasso 只会缓存原始尺寸的 图片，内 Glide 缓存的是多种规格，也就是 Glide 会根据你 ImageView 的大小来 缓存相应大小的图片尺寸。<br>4.内存开销小：默认的 Bitmap 格式是 RGB_565 格式，而 Picasso 默认的是 ARGB_8888 格式，内存开销小一半。</p>
<p>这个库都有哪些用法？对应什么样的使用场景？<br>1.图片加载Glide.with(this).load(imageUrl).override(800,800).placeholder().error().animate().into()。<br>2.多样式媒体加载：asBitamp、asGif。<br>3.生命周期集成。<br>4.可以配置磁盘缓存策略 ALL、NONE、SOURCE、RESULT。</p>
<p>Glide&amp;with:<br>1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等） 以及 glide 对象。<br>2、将 glide 请求和 application/SupportFragment/Fragment 的生命周期绑定在一块。</p>
<p>Glide&amp;load：<br>设置请求 url，并记录 url 已设置的状态。</p>
<p>Glide&amp;into：<br>1、首先根据转码类 transcodeClass 类型返回不同的 ImageViewTarget：BitmapImageViewTarget、DrawableImageViewTarget。<br>2、递归建立缩略图请求，没有缩略图请求，则直接进行正常请求。<br>3、如果没指定宽高，会根据 ImageView 的宽高计算出图片宽高，最终执行到 onSizeReay()方法中的 engine.load()方法。<br>4、engine 是一个负责加载和管理缓存资源的类</p>
<p>常规三级缓存的流程：强引用-&gt;软引用-&gt;硬盘缓存<br>当我们的APP中想要加载某张图片时，先去LruCache中寻找图片，如果LruCache 中有，则直接取出来使用，如果 LruCache 中没有，则去 SoftReference 中寻找 （软引用适合当 cache，当内存吃紧的时候才会被回收。而 weakReference 在每 次 system.gc（）就会被回收）（当 LruCache 存储紧张时，会把最近最少使用 的数据放到 SoftReference 中），如果 SoftReference 中有，则从 SoftReference 中取出图片使用，同时将图片重新放回到 LruCache 中，如果 SoftReference 中 也没有图片，则去硬盘缓存中中寻找，如果有则取出来使用，同时将图片添加到 LruCache 中，如果没有，则连接网络从网上下载图片。图片下载完成后，将图 片保存到硬盘缓存中，然后放到 LruCache 中。</p>
<p>Glide 缓存机制大致分为三层：内存缓存、弱引用缓存、磁盘缓存。<br>取的顺序是：内存、弱引用、磁盘。<br>存的顺序是：弱引用、内存、磁盘。</p>
<p>三层存储的机制在 Engine 中实现的。先说下 Engine 是什么？Engine 这一层负 责加载时做管理内存缓存的逻辑。持有 MemoryCache、Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;。通过 load（）来加载图片，加载前后 会做内存存储的逻辑。如果内存缓存中没有，那么才会使用 EngineJob 这一层来 进行异步获取硬盘资源或网络资源。EngineJob类似一个异步线程或observable。 Engine 是一个全局唯一的，通过 Glide.getEngine()来获取。</p>
<p>需要一个图片资源，首先先取ActiveResources，activeResources是盛放正在使用的资源，以弱引用的形式存在。同时资源内部有被引用的记录。如果资源没有引用记录了，那么再放回 Lrucache 中，同时从 activeResources 中清除（activeResources开启了一个后台线程专门检测ReferenceQueue）。如果没有，则继续从LruResourceCache中取，取到以后从LruResourceCache删除同时加入ActiveResources中。如果 Lrucache 和 activeResources 中没有，那么进行资源异步请求（网络 /diskLrucache），请求成功后，资源放到 diskLrucache 和 activeResources 中。</p>
<p>缓存：<br>ActiveResources 活跃的内存缓存，使用的是弱引用的方式，用作优化列表反复滑动中Lru频繁清除，然后在重新加载的情况<br>LruResourceCache 内存缓存,不包含正在使用的资源。使用cache.remove(key)从LruResourceCache获取缓存<br>ResourceCacheGenerator:缓存的被加工过的原数据缓存（磁盘)<br>DataCacheGenerator:原文件<br>SourceGenerator:从网络加载数据</p>
<p>Glide源码机制的核心思想：</p>
<p>使用一个弱引用 map activeResources 来盛放项目中正在使用的资源。Lrucache 中不含有正在使用的资源。资源内部有个计数器来显示自己是不是还有被引用的 情况，把正在使用的资源和没有被使用的资源分开有什么好处呢？？因为当 Lrucache 需要移除一个缓存时，会调用 resource.recycle()方法。注意到该方法上 面注释写着只有没有任何 consumer 引用该资源的时候才可以调用这个方法。那 么为什么调用 resource.recycle()方法需要保证该资源没有任何 consumer 引用 呢？glide 中 resource 定义的 recycle（）要做的事情是把这个不用的资源（假设 是 bitmap 或 drawable）放到 bitmapPool 中。bitmapPool 是一个 bitmap 回收 再利用的库，在做 transform 的时候会从这个 bitmapPool 中拿一个 bitmap 进行 再利用。这样就避免了重新创建 bitmap，减少了内存的开支。而既然 bitmapPool 中的 bitmap 会被重复利用，那么肯定要保证回收该资源的时候（即调用资源的 recycle（）时），要保证该资源真的没有外界引用了。这也是为什么 glide 花费 那么多逻辑来保证 Lrucache 中的资源没有外界引用的原因。</p>
<p>相关问题：<br>Glide 如何确定图片加载完毕？<br>Glide 使用什么缓存？<br>Glide 内存缓存如何控制大小？</p>
<h4 id="Fresco"><a href="#Fresco" class="headerlink" title="Fresco"></a>Fresco</h4><p>DraweeView：继承于 ImageView，只是简单的读取 xml 文件的一些属性值和做 一些初始化的工作，图层管理交由 Hierarchy 负责，图层数据获取交由负责。<br>DraweeHierarchy：由多层 Drawable 组成，每层 Drawable 提供某种功能（例如： 缩放、圆角）。 DraweeController：控制数据的获取与图片加载，向 pipeline 发出请求，并接收相应事件，并根据不同事件控制 Hierarchy，从 DraweeView 接收用户的事件，然后执行取消网络请求、回收资源等操作。<br>DraweeHolder： 统筹管理 Hierarchy 与 DraweeHolder。<br>ImagePipeline：Fresco 的核心模块，用 来以各种方式（内存、磁盘、网络等）获取图像。 Producer/Consumer：Producer 也有很多种，它用来完成网络数据获取，缓存数据获取、图片解码等多种工作， 它产生的结果由 Consumer 进行消费。<br>IO/Data：这一层便是数据层了，负责实 现内存缓存、磁盘缓存、网络缓存和其他 IO 相关的功能。</p>
<p>具体实现：<br>GenericDraweeHierarchy：负责 SimpleDraweeView 上的图层管理，由多层 Drawable 组成，每层 Drawable 提供某种功能（例如：缩放、圆角）。</p>
<ol>
<li>背景图（backgroundImage）</li>
<li>占位图（placeholderImage=）</li>
<li>加载的图片（actualImage）</li>
<li>进度条（progressBarImage）</li>
<li>重试加载的图片（retryImage）</li>
<li>失败图片（failureImage）</li>
<li>叠加图（overlayImage）</li>
</ol>
<p>内存缓存：</p>
<p>已解码的内存缓存（BitmapMemoryCache）与未解码的内存缓存（EncodedMemoryCache）区别就是已解码内存缓存的数据是CloseableReference<CloseableBitmap>。而未解码内存缓存的数据是CloseableReference<PooledByteBuffer>。即他们的实现方式一样，区别仅仅在于<strong>资源的测量与释放方式不同</strong>。它们使用ValueDescriptor来描述不同资源的数据大小，使用不同的ResourceReleaser来释放资源。</p>
<p>BitmapMemoryCache（已解码的内存缓存）：BitmapMemoryCacheFactory提供工厂方法获取存储缓存的数据结构。<br>EncodedMemoryCache（未解码的内存缓存）：EncodedCountingMemoryCacheFactory提供工厂方法获取存储缓存的数据结构。</p>
<p>CountingLruMap：Fresco中定义的LRU缓存载体，里面使用了LinkedHashMap作为数据存储载体，但是并没有启用LinkedHashMap的accessOrder功能。同时里面封装了map中的总大小mSizeInBytes，还有各个缓存的大小（ValueDescriptor.getSizeInBytes）。</p>
<p>CountingMemoryCache:具体缓存缓存实现<br>Fresco中实现具体内存缓存的类是CountingMemoryCache，它内部维持着几个重要参数：<br>ExclusiveEntries存储着未被使用的对象的CountingLruMap；<br>CachedEntries存储着所有对象的CountingLruMap；<br>MemoryCacheParams存储着最大缓存对象数量、缓存池大小等参数;<br>PARAMS_INTERCHECK_INTERVAL_MS检查缓存参数变化的事件间隔：5分钟；</p>
<p>它使用一个内部类Entry来封装缓存对象，除了记录缓存键、缓存对象之外，它还记录着该对象的引用数量（clientCount）及是否被缓存追踪（isOrphan）。注意：每个缓存对象只有满足clientCount为0并且isOrphan为true时才可以被释放，可从referenceToClose函数中看出此逻辑。</p>
<p>Fresco使用InstrumentedMemoryCache包装了CountingMemoryCache，主要增加的功能就是提供了MemoryCacheTracker，会在缓存命中或未命中时提供回调函数，供使用者实现自定义功能。</p>
<p>Fresco的缓存调用处：</p>
<p>1.BitmapMemoryCacheProducer：已解码的内存缓存的调用处<br>2.EncodedMemoryCacheProducer：未解码的内存缓存的调用处<br>3.DiskCacheReadProducer：磁盘中未解码的内存缓存的调用处<br>4.NetworkFetchProducer:从网络获取图片的调用处</p>
<p>这里提一点Bitmap缓存：在5.0以下系统，Bitmap缓存位于ashmem，这样Bitmap对象的创建和释放将不会引发GC，更少的GC会使你的APP运行得更加流畅。5.0及其以上系统，相比之下，内存管理有了很大改进，所以Bitmap缓存直接位于Java的heap上。</p>
<h4 id="Fresco-与-Glide-的对比："><a href="#Fresco-与-Glide-的对比：" class="headerlink" title="Fresco 与 Glide 的对比："></a>Fresco 与 Glide 的对比：</h4><p>Glide：相对轻量级，用法简单优雅，支持 Gif 动态图，适合用在那些对图片依赖 不大的 App 中。 Fresco：采用匿名共享内存来保存图片，也就是 Native 堆，有 效的的避免了 OOM，功能强大，但是库体积过大，适合用在对图片依赖比较大 的 App 中。</p>
<h4 id="实现一个-ImageLoader-的流程"><a href="#实现一个-ImageLoader-的流程" class="headerlink" title="实现一个 ImageLoader 的流程"></a>实现一个 ImageLoader 的流程</h4><p>同步异步加载、图片压缩、内存硬盘缓存、网络拉取</p>
<p>1.同步加载只创建一个线程然后按照顺序进行图片加载<br>2.异步加载使用线程池，让存在的加载任务都处于不同线程<br>3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载</p>
<p>具体为：</p>
<p>1、ImageLoader 作为一个单例，提供了加载图片到指定控件的方法：直 接从内存缓存中获取对象，如果没有则用一个 ThreadPoolExecutor 去执 行 Runnable 任务来加载图片。ThreadPoolExecutor 的创建需要指定核心 线程数 CPU 数+1，最大线程数 CPU 数*2+1，线程闲置超市时长 10s,这几 个关键数据，还可以加入 ThreadFactory 参数来创建定制化的线程。<br>2、ImageLoader 的具体实现 loadBitmap：先从内存缓存 LruCache 中加 载，如果为空再从磁盘缓存中加载，加载成功后记得存入内存缓存，如果 为空则从网络中直接下载输出流到磁盘缓存，然后再从磁盘中加载，如果 为 空 并 且 磁 盘 缓 存 没 有 被 创 建 的 话 ， 直 接 通 过 BitmapFactory 的 decodeStream 获取网络请求的输入流获取 Bitmap 对象。<br>3、v4 包的 LruCache 可以兼容到 2.2 版本，LruCache 采用 LinkedHashMap 存储缓存对象。创建对象只需要提供缓存容量并重写 sizeOf 方法：作用 是计算缓存对象的大小。有时需要重写 entryRemoved 方法，用于回收一 些资源。<br>4、DiskLruCache 通过 open 方法创建，设置缓存路径，缓存容量。缓存 添加通过 Editor 对象创建输出流，下载资源到输出流完成后，commit， 如果失败则 abort 撤回。然后刷新磁盘缓存。缓存查找通过 Snapshot 对象获取输入流，获取 FileDescriptor，通过 FileDescriptor 解析出 Bitmap 对象。 5、列表中需要加载图片的时候，当列表在滑动中不进行图片加载，当滑 动停止后再去加载图片。</p>
<h4 id="EventBus（略）"><a href="#EventBus（略）" class="headerlink" title="EventBus（略）"></a>EventBus（略）</h4><h4 id="LeakCanary-实现原理"><a href="#LeakCanary-实现原理" class="headerlink" title="LeakCanary 实现原理"></a>LeakCanary 实现原理</h4><p>为什么要在项目中使用这个库？<br>1.针对 Android Activity 组件完全自动化的内存泄漏检查，在最新的版本中， 还加入了 android.app.fragment 的组件自动化的内存泄漏检测。<br>2.易用集成，使用成本低。<br>3.友好的界面展示和通知。</p>
<p>这个库都有哪些用法？对应什么样的使用场景？</p>
<p>直接从 application 中拿到全局的 refWatcher 对象，在 Fragment 或其他组件的 销毁回调中使用 refWatcher.watch(this)检测是否发生内存泄漏。</p>
<p>这个库的优缺点是什么，跟同类型库的比较？ 检测结果并不是特别的准确，因为内存的释放和对象的生命周期有关也和 GC 的 调度有关。</p>
<p>这个库的核心实现原理是什么？如果让你实现这个库的某些核心功能，你会考虑怎么去实现？<br>主要分为如下 7 个步骤：<br>1、RefWatcher.watch()创建了一个KeyedWeakReference用于去观察对象。<br>2、然后，在后台线程中，它会检测引用是否被清除了，并且是否没有触 发 GC。<br>3、如果引用仍然没有被清除，那么它将会把堆栈信息保存在文件系统中 的.hprof 文件里。<br>4、HeapAnalyzerService 被开启在一个独立的进程中，并且 HeapAnalyzer 使用了 HAHA 开源库解析了指定时刻的堆栈快照文件 heap dump。<br>5、从 heap dump 中， HeapAnalyzer 根据一个独特的引用 key 找到了 KeyedWeakReference，并且定位了泄露的引用。<br>6、HeapAnalyzer 为了确定是否有泄露，计算了到 GC Roots 的最短强引 用路径，然后建立了导致泄露的链式引用。<br>7、这个结果被传回到 app 进程中的 DisplayLeakService，然后一个泄露 通知便展现出来了。<br>简单来说就是： 在一个 Activity 执行完 onDestroy()之后，将它放入 WeakReference 中，然后将 这个 WeakReference 类型的 Activity 对象与 ReferenceQueque 关联。这时再从 ReferenceQueque 中查看是否有该对象，如果没有，执行 gc，再次查看，还是 没有的话则判断发生内存泄露了。最后用 HAHA 这个开源库去分析 dump 之后 的 heap 内存（主要就是创建一个 HprofParser 解析器去解析出对应的引用内存 快照文件 snapshot）。</p>
<p>源码分析中一些核心分析点：</p>
<p>AndroidExcludedRefs：它是一个 enum 类，它声明了 Android SDK 和厂商定制 的 SDK 中存在的内存泄露的 case，根据 AndroidExcludedRefs 这个类的类名就 可看出这些 case 都会被 Leakcanary 的监测过滤掉。</p>
<p>buildAndInstall()（即 install 方法）这个方法应该仅仅只调用一次。</p>
<p>debuggerControl : 判断是否处于调试模式，调试模式中不会进行内存泄漏检测。 为什么呢？因为在调试过程中可能会保留上一个引用从而导致错误信息上报。</p>
<p>watchExecutor : 线程控制器，在 onDestroy() 之后并且主线程空闲时执行内存 泄漏检测。</p>
<p>gcTrigger : 用于 GC，watchExecutor 首次检测到可能的内存泄漏，会主动进行 GC，GC 之后会再检测一次，仍然泄漏的判定为内存泄漏，最后根据 heapDump 信息生成相应的泄漏引用链。</p>
<p>gcTrigger 的 runGc()方法：这里并没有使用 System.gc()方法进行回收，因为 system.gc()并不会每次都执行。而是从 AOSP 中拷贝一段 GC 回收的代码，从而 相比 System.gc()更能够保证进行垃圾回收的工作。</p>
<p>Runtime.getRuntime().gc();</p>
<p>子线程延时 1000ms； System.runFinalization();</p>
<p>install 方法内部最终还是调用了 application 的 registerActivityLifecycleCallbacks()方法，这样就能够监听 activity 对应的生命周 期事件了。 在 RefWatcher#watch()中使用随机的 UUID 保证了每个检测对象对应的 key 的 唯一性。 在 KeyedWeakReference 内部，使用了 key 和 name 标识了一个被检测的 WeakReference 对象。在其构造方法中将弱引用和引用队列 ReferenceQueue 关联起来，如果弱引用 reference 持有的对象被 GC 回收，JVM 就会把这个弱引 用加入到与之关联的引用队列 referenceQueue 中。即 KeyedWeakReference 持 有的 Activity 对象如果被 GC 回收，该对象就会加入到引用队列 referenceQueue 中。</p>
<p>使用 Android SDK 的 API Debug.dumpHprofData() 来生成 hprof 文件。</p>
<p>在 HeapAnalyzerService（类型为 IntentService 的 ForegroundService）的 runAnalysis()方法中，为了避免减慢 app 进程或占用内存，这里将 HeapAnalyzerService 设置在了一个独立的进程中。</p>
<p>leakCannary中如何判断一个对象是否被回收？如何触发手动gc？c层实现？</p>
<h3 id="BlockCanary"><a href="#BlockCanary" class="headerlink" title="BlockCanary"></a>BlockCanary</h3><p>该组件利用了主线程的消息队列处理机制，应用发生卡顿，一定是在 dispatchMessage 中执行了耗时操作。我们通过给主线程的 Looper 设置一个 Printer，打点统计 dispatchMessage 方法执行的时间，如果超出阀值，表示发生 卡顿，则 dump 出各种信息，提供开发者分析性能瓶颈。</p>
<h3 id="ButterKnife-实现原理"><a href="#ButterKnife-实现原理" class="headerlink" title="ButterKnife 实现原理"></a>ButterKnife 实现原理</h3><p>ButterKnife 对性能的影响很小，因为没有使用使用反射，而是使用的 Annotation Processing Tool(APT)，注解处理器，javac 中用于编译时扫描和解析 Java 注解的 工具。在编译阶段执行的，它的原理就是读入 Java 源代码，解析注解，然后生 成新的 Java 代码。新生成的 Java 代码最后被编译成 Java 字节码，注解解析器不 能改变读入的 Java 类，比如不能加入或删除 Java 方法。</p>
<h3 id="热修复和插件化"><a href="#热修复和插件化" class="headerlink" title="热修复和插件化"></a>热修复和插件化</h3><p>插件化：动态加载主要解决 3 个技术问题：<br>1、使用 ClassLoader 加载类。<br>2、资源访问。<br>3、生命周期管理。</p>
<p>插件化是体现在功能拆分方面的，它将某个功能独立提取出来，独立开发，独立 测试，再插入到主应用中。以此来减少主应用的规模。</p>
<h4 id="热修复："><a href="#热修复：" class="headerlink" title="热修复："></a>热修复：</h4><p>代码热修复原理：<br>1.将编译好的 class 文件拆分打包成两个 dex，绕过 dex 方法数量的限制以 及安装时的检查，在运行时再动态加载第二个 dex 文件中。<br>2.热修复是体现在 bug 修复方面的，它实现的是不需要重新发版和重新安 装，就可以去修复已知的 bug。<br>3.利用 PathClassLoader 和 DexClassLoader 去加载与 bug 类同名的类，替 换掉 bug 类，进而达到修复 bug 的目的，原理是在 app 打包的时候阻止 类打上 CLASS_ISPREVERIFIED 标志， 然后在热修复的时候动态改变 BaseDexClassLoader 对象间接引用的 dexElements，替换掉旧的类。</p>
<p>相同点:都使用 ClassLoader 来实现加载新的功能类，都可以使用 PathClassLoader 与 DexClassLoader。<br>不同点：热修复因为是为了修复 Bug 的，所以要将新的类替代同名的 Bug 类，要抢先加 载新的类而不是 Bug 类，所以多做两件事：在原先的 app 打包的时候，阻止相 关类去打上 CLASS_ISPREVERIFIED 标志，还有在热修复时动态改变 BaseDexClassLoader 对象间接引用的 dexElements，这样才能抢先代替 Bug 类， 完成系统不加载旧的 Bug 类.。 而插件化只是增加新的功能类或者是资源文件， 所以不涉及抢先加载新的类这样的使命，就避过了阻止相关类去打上 CLASS_ISPREVERIFIED 标志和还有在热修复时动态改变 BaseDexClassLoader 对 象间接引用的 dexElements.<br>所以插件化比热修复简单，热修复是在插件化的基础上在进行替换旧的 Bug 类。</p>
<p>热修复原理：<br>资源修复：很多热修复框架的资源修复参考了 Instant Run 的资源修复的原理。传统编译部署流程如下：<br>Instant Run 编译部署流程如下：</p>
<ul>
<li>Hot Swap：修改一个现有方法中的代码时会采用 Hot Swap。</li>
<li>Warm Swap：修改或删除一个现有的资源文件时会采用 Warm Swap。</li>
<li>Cold Swap：有很多情况，如添加、删除或修改一个字段和方法、添加一 个类等。</li>
</ul>
<p>Instant Run 中的资源热修复流程：<br>1、创建新的 AssetManager，通过反射调用 addAssetPath 方法加载外部 的资源，这样新创建的 AssetManager 就含有了外部资源。<br>2、将 AssetManager 类型的 mAssets 字段的引用全部替换为新创建的 AssetManager。</p>
<p>代码修复：<br>1、类加载方案：<br>根据 dex 文件的查找流程，我们将有 Bug 的类 Key.class 进行修改，再将 Key.class 打 包 成 包 含 dex 的 补 丁 包 Patch.jar ， 放 在 Element 数 组 dexElements 的第一个元素，这样会首先找到 Patch.dex 中的 Key.class 去 替换之前存在 Bug 的 Key.class，排在数组后面的 dex 文件中存在 Bug 的 Key.class 根据 ClassLoader 的双亲委托模式就不会被加载。<br>类加载方案需要重启 App 后让 ClassLoader 重新加载新的类，为什么需要重启 呢？<br>这是因为类是无法被卸载的，要想重新加载新的类就需要重启 App，因此 采用类加载方案的热修复框架是不能即时生效的。</p>
<p>各个热修复框架的实现细节差异：</p>
<ul>
<li>QQ 空间的超级补丁和 Nuwa 是按照上面说的将补丁包放在 Element 数组 的第一个元素得到优先加载。</li>
<li>微信的 Tinker 将新旧 APK 做了 diff，得到 path.dex，再将 patch.dex 与手 机中 APK 的 classes.dex 做合并，生成新的 classes.dex，然后在运行时通 过反射将 classes.dex 放在 Elements 数组的第一个元素。</li>
<li>饿了么的 Amigo 则是将补丁包中每个 dex 对应的 Elements 取出来，之后 组成新的 Element 数组，在运行时通过反射用新的 Elements 数组替换掉 现有的 Elements 数组。</li>
</ul>
<p>2、底层替换方案：<br>当我们要反射 Key 的 show 方法，会调用 Key.class.getDeclaredMethod(“show”).invoke(Key.class.newInstance());，最终会 在 native 层将传入的 javaMethod 在 ART 虚拟机中对应一个 ArtMethod 指针， ArtMethod 结构体中包含了 Java 方法的所有信息，包括执行入口、访问权限、 所属类和代码执行地址等。</p>
<p>替换 ArtMethod 结构体中的字段或者替换整个 ArtMethod 结构体，这就是底层 替换方案。</p>
<p>AndFix 采用的是替换 ArtMethod 结构体中的字段，这样会有兼容性问题，因为 厂商可能会修改 ArtMethod 结构体，导致方法替换失败。</p>
<p>Sophix 采用的是替换整个 ArtMethod 结构体，这样不会存在兼容问题。 底层替换方案直接替换了方法，可以立即生效不需要重启。采用底层替换方案主 要是阿里系为主，包括 AndFix、Dexposed、阿里百川、Sophix。</p>
<p>3、Instant Run 方案：<br>什么是 ASM？ ASM 是一个 java 字节码操控框架，它能够动态生成类或者增强现有类的功能。 ASM 可以直接产生 class 文件，也可以在类被加载到虚拟机之前动态改变类的行 为。 Instant Run 在第一次构建 APK 时，使用 ASM 在每一个方法中注入了类似的代 码逻辑：当$change 不为 null 时，则调用它的 access$dispatch 方法，参数为具 体的方法名和方法参数。当 MainActivity 的 onCreate 方法做了修改，就会生成 替换类 MainActivity$override，这个类实现了 IncrementalChange 接口，同时也 会生成一个 AppPatchesLoaderImpl 类，这个类的 getPatchedClasses 方法会返 回被修改的类的列表（里面包含了 MainActivity），根据列表会将 MainActivity 的$change 设置为 MainActivity$override。最后这个$change 就不会为 null，则 会执行 MainActivity$override 的 access$dispatch 方法，最终会执行 onCreate 方法，从而实现了 onCreate 方法的修改。<br>借鉴 Instant Run 原理的热修复框架有 Robust 和 Aceso。</p>
<p>动态链接库修复：<br>重新加载 so。</p>
<p>加载 so 主要用到了 System 类的 load 和 loadLibrary 方法，最终都会调用到 nativeLoad 方法。其会调用 JavaVMExt 的 LoadNativeLibrary 函数来加载 so。<br>so 修复主要有两个方案：<br>1、将 so 补丁插入到 NativeLibraryElement 数组的前部，让 so 补丁的路 径先被返回和加载。<br>2、调用 System 的 load 方法来接管 so 的加载入口。</p>
<h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><p>为什么选用插件化？<br>在 Android 传统开发中，一旦应用的代码被打包成 APK 并被上传到各个应用市 场，我们就不能修改应用的源码了，只能通过服务器来控制应用中预留的分支代 码。但是很多时候我们无法预知需求和突然发生的情况，也就不能提前在应用代 码中预留分支代码，这时就需要采用动态加载技术，即在程序运行时，动态加载 一些程序中原本不存在的可执行文件并运行这些文件里的代码逻辑。其中可执行 文件包括动态链接库 so 和 dex 相关文件（dex 以及包含 dex 的 jar/apk 文件）。 随着应用开发技术和业务的逐步发展，动态加载技术派生出两个技术：热修复和 插件化。其中热修复技术主要用来修复 Bug，而插件化技术则主要用于解决应用 越来越庞大以及功能模块的解耦。详细点说，就是为了解决以下几种情况：<br>1、业务复杂、模块耦合：随着业务越来越复杂，应用程序的工程和功能 模块数量会越来越多，一个应用可能由几十甚至几百人来协同开发，其中 的一个工程可能就由一个小组来进行开发维护，如果功能模块间的耦合度 较高，修改一个模块会影响其它功能模块，势必会极大地增加沟通成本。<br>2、应用间的接入：当一个应用需要接入其它应用时，如淘宝，为了将流 量引流到其它的淘宝应用如：飞猪旅游、口碑外卖、聚划算等等应用，如 使用常规技术有两个问题：可能要维护多个版本的问题或单个应用体积将 会非常庞大的问题。<br>3、65536 限制，内存占用大。</p>
<p>插件化的思想：安装的应用可以理解为插件，这些插件可以自由地进行插拔。</p>
<p>插件化的定义：<br>插件一般是指经过处理的 APK，so 和 dex 等文件，插件可以被宿主进行加载，有的插件也可以作为 APK 独立运行。将一个应用按照插件的方式进行改造的过程就叫作插件化。</p>
<p>插件化的优势：<br>1.低耦合<br>2.应用间的接入和维护更便捷，每个应用团队只需要负责自己的那一部分。<br>3.应用及主 dex 的体积也会相应变小，间接地避免了 65536 限制。<br>4.第一次加载到内存的只有淘宝客户端，当使用到其它插件时才会加载相应 插件到内存，以减少内存占用。</p>
<p>插件化框架对比：</p>
<ul>
<li>最 早 的 插 件 化 框 架 ： 2012 年 大 众 点 评 的 屠 毅 敏 就 推 出 了 AndroidDynamicLoader 框架。</li>
<li>目前主流的插件化方案有滴滴任玉刚的 VirtualApk、360 的 DroidPlugin、 RePlugin、Wequick 的 Small 框架。</li>
<li>如果加载的插件不需要和宿主有任何耦合，也无须和宿主进行通信，比如 加载第三方 App，那么推荐使用 RePlugin，其他情况推荐使用 VirtualApk。由于 VirtualApk 在加载耦合插件方面是插件化框架的首选，具有普遍的 适用性，因此有必要对它的源码进行了解。</li>
</ul>
<p>插件化原理：<br>Activity 插件化：<br>主要实现方式有三种：<br>1.反射：对性能有影响，主流的插件化框架没有采用此方式。<br>2.接口：dynamic-load-apk 采用。<br>3.Hook：主流。</p>
<p>Hook 实现方式有两种：Hook IActivityManager 和 Hook Instrumentation。主要 方案就是先用一个在 AndroidManifest.xml 中注册的 Activity 来进行占坑，用来 通过 AMS 的校验，接着在合适的时机用插件 Activity 替换占坑的 Activity。</p>
<p>Hook IActivityManager：<br>1、占坑、通过校验：<br>在 Android 7.0 和 8.0 的源码中 IActivityManager 借助了 Singleton 类实现单例， 而且该单例是静态的，因此 IActivityManager 是一个比较好的 Hook 点。</p>
<p>接着，定义替换 IActivityManager 的代理类 IActivityManagerProxy，由于 Hook 点 IActivityManager 是一个接口，建议这里采用动态代理。</p>
<ul>
<li>拦截 startActivity 方法，获取参数 args 中保存的 Intent 对象，它是原本 要启动插件 TargetActivity 的 Intent。</li>
<li>新建一个 subIntent 用来启动 StubActivity，并将前面得到的 TargetActivity 的 Intent 保存到 subIntent 中，便于以后还原 TargetActivity。</li>
<li>最 后 ， 将 subIntent 赋 值 给 参 数 args ， 这 样 启 动 的 目 标 就 变 为 了 StubActivity，用来通过 AMS 的校验。</li>
</ul>
<p>然后，用代理类 IActivityManagerProxy 来替换 IActivityManager。</p>
<ul>
<li>当 版 本 大 于 等 于 26 时 ， 使 用 反 射 获 取 ActivityManager 的 IActivityManagerSingleton 字段， 小于时则获取 ActivityManagerNative 中的 gDefault 字段。</li>
<li>然后，通过反射获取对应的 Singleton 实例，从上面得到的 2 个字段中拿 到对应的 IActivityManager。</li>
<li>最 后 ， 使 用 Proxy.newProxyInstance() 方 法 动 态 创 建 代 理 类 IActivityManagerProxy ， 用 IActivityManagerProxy 来 替 换 IActivityManager。</li>
</ul>
<p>2.还原插件 Activity<br>前面用占坑 Activity 通过了 AMS 的校验， 但是我们要启动的是插件 TargetActivity，还需要用插件 TargetActivity 来替换占坑的 SubActivity， 替换时机为图中步骤 2 之后。<br>在 ActivityThread 的 H 类 中 重 写 的 handleMessage 方 法 会 对 LAUNCH_ACTIVITY类型的消息进行处理，最终会调用Activity的onCreate 方法。在 Handler 的 dispatchMessage 处理消息的这个方法中，看到如果 Handelr 的 Callback 类型的 mCallBack 不为 null，就会执行 mCallback 的 handleMessage 方法，因此 mCallback 可以作为 Hook 点。我们可以用自 定义的 Callback 来替换 mCallback</p>
<p>自定义的 Callback 实现了 Handler.Callback，并重写了 handleMessage 方法， 当收到消息的类型为 LAUNCH_ACTIVITY 时，将启动 SubActivity 的 Intent 替换 为启动 TargetActivity 的 Intent。然后使用反射将 Handler 的 mCallback 替换为 自定义的 CallBack 即可。使用时则在 application 的 attachBaseContext 方法中 进行 hook 即可。</p>
<p>3、插件 Activity 的生命周期：<br>AMS 和 ActivityThread 之间的通信采用了 token 来对 Activity 进行标识， 并且此后的 Activity 的生命周期处理也是根据 token 来对 Activity 进行标 识 的 ， 因 为 我 们 在 Activity 启 动 时 用 插 件 TargetActivity 替 换 占 坑 SubActivity ， 这 一 过 程 在 performLaunchActivity 之 前 ， 因 此 performLaunchActivity 的 r.token 就是 TargetActivity。所以 TargetActivity 具有生命周期。</p>
<p>Hook Instrumentation：<br>Hook Instrumentation 实现同样也需要用到占坑 Activity，与 Hook IActivity 实现 不同的是，用占坑 Activity 替换插件 Activity 以及还原插件 Activity 的地方不同。</p>
<p>分析：在 Activity 通过 AMS 校验前，会调用 Activity 的 startActivityForResult 方 法，其中调用了 Instrumentation 的 execStartActivity 方法来激活 Activity 的生命 周期。并且在 ActivityThread 的 performLaunchActivity 中使用了 mInstrumentation 的 newActivity 方法，其内部会用类加载器来创建 Activity 的 实例。 方案：在 Instrumentation 的 execStartActivity 方法中用占坑 SubActivity 来通过 AMS 的验证，在 Instrumentation 的 newActivity 方法中还原 TargetActivity，这 两部操作都和 Instrumentation 有关，因此我们可以用自定义的 Instumentation 来替换掉 mInstrumentation。具体为：</p>
<ul>
<li>首先检查 TargetActivity 是否已经注册， 如果没有则将 TargetActivity 的 ClassName 保存起来用于后面还原。接着把要启动的 TargetActivity 替换 为 StubActivity，最后通过反射调用 execStartActivity 方法，这样就可以 用 StubActivity 通过 AMS 的验证。</li>
<li>在 newActivity 方法中创建了此前保存的 TargetActivity， 完成了还原 TargetActivity 。 最 后 使 用 反 射 用 InstrumentationProxy 替 换 mInstumentation。</li>
</ul>
<p>资源插件化：<br>资源的插件化和热修复的资源修复都借助了 AssetManager。<br>资源的插件化方案主要有两种：<br>1.合并资源方案，将插件的资源全部添加到宿主的 Resources 中，这种 方案插件可以访问宿主的资源。<br>2.构建插件资源方案，每个插件都构造出独立的 Resources，这种方案 插件不可以访问宿主资源。</p>
<p>so 的插件化：<br>so 的插件化方案和 so 热修复的第一种方案类似，就是将 so 插件插入到 NativelibraryElement 数组中，并且将存储 so 插件的文件添加到 nativeLibraryDirectories 集合中就可以了。<br>插件的加载机制方案：<br>1、Hook ClassLoader。<br>2、委托给系统的 ClassLoader 帮忙加载。</p>
<h3 id="模块化和组件化"><a href="#模块化和组件化" class="headerlink" title="模块化和组件化"></a>模块化和组件化</h3><p>分析现有的组件化方案：<br>很多大厂的组件化方案是以 多工程 + 多 Module 的结构(微信, 美团等超级 App 更是以 多工程 + 多 Module + 多 P 工程(以页面为单元的代码隔离方 式) 的三级工程结构), 使用 Git Submodule 创建多个子仓库管理各个模块的代 码, 并将各个模块的代码打包成 AAR 上传至私有 Maven 仓库使用远程版本号 依赖的方式进行模块间代码的隔离。</p>
<p>组件化开发的好处：<br>1.避免重复造轮子，可以节省开发和维护的成本。<br>2.可以通过组件和模块为业务基准合理地安排人力，提高开发效率。<br>3.不同的项目可以共用一个组件或模块，确保整体技术方案的统一性。<br>4.为未来插件化共用同一套底层模型做准备。</p>
<p>跨组件通信：<br>跨组件通信场景：<br>1.第 一 种 是 组 件 之 间 的 页 面 跳 转 (Activity 到 Activity, Fragment 到 Fragment, Activity 到 Fragment, Fragment 到 Activity) 以及跳转时的 数据传递 (基础数据类型和可序列化的自定义类类型)。<br>2.第二种是组件之间的自定义类和自定义方法的调用(组件向外提供服务)。</p>
<p>如何管理过多的路由表？<br>RouterHub 存在于基础库, 可以被看作是所有组件都需要遵守的通讯协议, 里 面不仅可以放路由地址常量, 还可以放跨组件传递数据时命名的各种 Key 值, 再配以适当注释, 任何组件开发人员不需要事先沟通只要依赖了这个协议, 就知 道了各自该怎样协同工作, 既提高了效率又降低了出错风险, 约定的东西自然要 比口头上说的强。 Tips: 如果您觉得把每个路由地址都写在基础库的 RouterHub 中, 太麻烦了, 也可以在每个组件内部建立一个私有 RouterHub, 将不需要跨组件的路由地址 放入私有 RouterHub 中管理, 只将需要跨组件的路由地址放入基础库的公有 RouterHub 中管理, 如果您不需要集中管理所有路由地址的话, 这也是比较推 荐的一种方式。</p>
<p>ARouter 路由原理：<br>ARouter 维护了一个路由表 Warehouse，其中保存着全部的模块跳转关系， ARouter 路由跳转实际上还是调用了 startActivity 的跳转，使用了原生的 Framework 机制，只是通过 apt 注解的形式制造出跳转规则，并人为地拦截跳转 和设置跳转条件。</p>
<p>多模块开发的时候不同的负责人可能会引入重复资源，相同的字符串，相同的 icon 等但是文件名并不一样，怎样去重？</p>
<h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><p>gradle 熟悉么，自动打包知道么？<br>如何加快 Gradle 的编译速度？<br>Gradle 的 Flavor 能否配置 sourceset？<br>Gradle 生命周期<br>谈谈你对 AOP 技术的理解？<br>说说你了解的编译插桩技术？</p>
<h3 id="项目中遇到哪些难题，最终你是如何解决的？"><a href="#项目中遇到哪些难题，最终你是如何解决的？" class="headerlink" title="项目中遇到哪些难题，最终你是如何解决的？"></a>项目中遇到哪些难题，最终你是如何解决的？</h3><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="没有给权限如何定位，特定机型定位失败，如何解决"><a href="#没有给权限如何定位，特定机型定位失败，如何解决" class="headerlink" title="没有给权限如何定位，特定机型定位失败，如何解决?"></a>没有给权限如何定位，特定机型定位失败，如何解决?</h4><h4 id="Android-中进程内存的分配，能不能自己分配定额内存？"><a href="#Android-中进程内存的分配，能不能自己分配定额内存？" class="headerlink" title="Android 中进程内存的分配，能不能自己分配定额内存？"></a>Android 中进程内存的分配，能不能自己分配定额内存？</h4><h4 id="非-UI-线程可以更新-UI-吗"><a href="#非-UI-线程可以更新-UI-吗" class="headerlink" title="非 UI 线程可以更新 UI 吗?"></a>非 UI 线程可以更新 UI 吗?</h4><p>可以，当访问 UI 时，ViewRootImpl 会调用 checkThread 方法去检查当前访问 UI 的线程是哪个，如果不是 UI 线程则会抛出异常。执行 onCreate 方法的那个 时候 ViewRootImpl 还没创建，无法去检查当前线程.ViewRootImpl 的创建在 onResume 方法回调之后。</p>
<p>非 UI 线程是可以刷新 UI 的，前提是它要拥有自己的 ViewRoot,即更新 UI 的线程 和创建 ViewRoot 的线程是同一个，或者在执行 checkThread()前更新 UI。</p>
<h4 id="单元测试有没有做过，说说熟悉的单元测试框架"><a href="#单元测试有没有做过，说说熟悉的单元测试框架" class="headerlink" title="单元测试有没有做过，说说熟悉的单元测试框架"></a>单元测试有没有做过，说说熟悉的单元测试框架</h4><p>单元测试（Junit4、Mockito、PowerMockito、Robolectric）</p>
<p>UI 测试（Espresso、UI Automator）</p>
<p>压力测试（Monkey）</p>
<h4 id="快应用、react-native、小程序等区别"><a href="#快应用、react-native、小程序等区别" class="headerlink" title="快应用、react native、小程序等区别"></a>快应用、react native、小程序等区别</h4><h2 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h2><p><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">剑指 Offer 题解</a><br><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">Leetcode 题解</a></p>
<h4 id="高频题集"><a href="#高频题集" class="headerlink" title="高频题集"></a>高频题集</h4><p>1、无重复字符的最长子串<br>2、简化路径<br>3、复原 IP 地址<br>4、三数之和<br>5、岛屿的最大面积<br>6、搜索旋转排序数组<br>7、朋友圈<br>8、接雨水<br>9、反转链表<br>10、两数相加<br>11、合并两个有序链表<br>12、合并 K 个排序链表<br>13、买卖股票的最佳时机<br>14、买卖股票的最佳时机 II<br>15、最大子序和<br>16、最小栈<br>17、LRU 缓存机制<br>18、寻找两个有序数组的中位数<br>19、最长回文子串<br>20、合并两个有序数组<br>21、整数反转<br>22、排序链表<br>23、子集<br>24、全排列<br>25、实现二叉树中序遍历（不使用递归）<br>26、爬楼梯（斐波那契数列）<br>27、滑动窗口的最大值<br>28、判断单链表成环与否？<br>29、如何从一百万个数里面找到最小的一百个数，考虑算法的时间复杂度和空间复杂度<br>30、手写数组实现队列<br>31、java 排序算法和查找算法 (写出你所知道的排序算法及时空复杂度，稳定性)</p>
<h4 id="次高频题集"><a href="#次高频题集" class="headerlink" title="次高频题集"></a>次高频题集</h4><p>1、算法熟悉么？给了一个二叉排序树，出了一个给定节点找到它的下一个元素（指的是大小顺 序的下一个）的算法题。<br>2、x 个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完<br>3、求二叉树第 n 层节点数<br>4、如何设计一个抽奖系统，比如满 200 抽 20，满 500 抽 50。<br>5、求无序数组中的中位数<br>6、二叉树深度算法<br>7、堆和栈在内存中的区别是什么(数据结构方面以及实际实现方面)<br>8、最快的排序算法是哪个？给阿里 2 万多名员工按年龄排序应该选择哪个算法？<br>9、堆和树的区别？<br>10、求 1000 以内的水仙花数以及 40 亿以内的水仙花数；<br>11、子串包含问题(KMP 算法)写代码实现；<br>12、万亿级别的两个 URL 文件 A 和 B，如何求出 A 和 B 的差集 C,(Bit 映射-&gt;hash 分组-&gt;多文件 读写效率-&gt;磁盘寻址以及应用层面对寻址的优化)<br>13、蚁群算法与蒙特卡洛算法；<br>14、百度 POI 中如何试下查找最近的商家功能(坐标镜像+R 树)。<br>15、5 枚硬币，2 正 3 反如何划分为两堆然后通过翻转让两堆中正面向上的硬币和反面向上的硬 币个数相同；<br>16、时针走一圈，时针分针重合几次；<br>17、N * N 的方格纸,里面有多少个正方形；<br>18、请在 100 个电话号码找出 135 的电话号码 注意 不能用正则，（类似怎么最好的遍历 LogGat 日志）<br>19、一个青蛙跳台阶，一次可以跳一步和两步，如果一共有 N 个台阶，可以有几种跳法？<br>20、写代码实现队列的基本操作，外加查找最大值；<br>21、图：有向无环图的解释<br>22、二叉树 深度遍历与广度遍历<br>23、B 树、B+树<br>24、密码学中两大加密算法是什么<br>25、判断环（猜测应该是链表环）<br>26、有一个 List 列表，去掉列表中的某一 Object 对象，如何在 for 循环里面写；<br>27、设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？ （二叉排序树，建立索引）<br>28、怎么在不引入其他变量的情况下,让 a（int） 和 b（int） 互换？<br>29、回形打印二维数组<br>30、二叉树，给出根节点和目标节点，找出从根节点到目标节点的路径<br>31、一个无序，不重复数组，输出 N 个元素，使得 N 个元素的和相加为 M，给出时间复杂度、空 间复杂度。手写算法<br>32、两个不重复的数组集合中，求共同的元素。<br>33、上一问扩展，海量数据，内存中放不下，怎么求出。<br>34、从长度为 m 的 int 数组中随机取出 n 个元素，每次取的元素都是之前未取过的，如何优化<br>35、逆序一个字符串，不能调用 String 的 reverse 方法(考察编码风格)<br>36、算法：将一个有序数组去重得到一个新数组(空间复杂度为 O(N))<br>37、算法：如何从 1T 的无序数组(长度为 n)里面找出前 k 大的数据，复杂度要求为 O(logN)<br>38、m * n 的矩阵，能形成几个正方形（2 * 2 能形成 1 个正方形，2 * 3 2 个，3 * 3 6 个）<br>39、面试头条的时候在线编程：从上到下从左到右输出二叉树<br>40、从长度为 m 的 int 数组中随机取出 n 个元素，每次取的元素都是之前未取过的，如何优化<br>41、逆序一个字符串，不能调用 String 的 reverse 方法(考察编码风格)<br>42、算法：将一个有序数组去重得到一个新数组(空间复杂度为 O(N))<br>43、算法：如何从 1T 的无序数组(长度为 n)里面找出前 k 大的数据，复杂度要求为 O(logN)<br>44、堆和树的区别<br>45、堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面 去回答)？<br>46、什么是深拷贝和浅拷贝<br>47、手写链表逆序代码<br>48、讲一下对图的理解<br>49、手写一段代码，如何找出一段字符串中，出现最多的汉字是哪个？<br>50、单向链表逆序。<br>51、实现一个数组插入。（处理异常判别，不使用 Collections 相关接口)。<br>52、找到无序数组的最大连续求和。<br>53、找到多个员工的共同繁忙时段。<br>54、输出一个集合{A,B,C,D}的全部子集**<br>55、手写代码：遍历文件目录；<br>56、电梯运行的算法分析；<br>57、手写实现单链表的 get 操作；<br>58、100 个数字排序怎么做？<br>59、一个集合里有 1000 万个随机元素，如何快速计算他们的和（我特喵的以为是考算法，想半 天没有 O（n）以下的方案，结果他居然说多线程）<br>60、切饼问题：1 刀切 2 块，2 刀切 4 块，10 刀最多切几块。<br>61、追击问题：2 辆火车相向同时出发，一个从 A 点出发，速度是 30km/h,一个从 B 点出发，速 度是 20km/h，A、B 之间的距离是 S，同时一只鸟也从 A 点出发，速度是 50km/h，鸟在两辆火车 间折返飞行，问三者相遇时，鸟飞的总路程。<br>62、算法：给定一段已排好序的数列，数列中元素有可能是重复的，找出数列中目标值的最小 索引，要求不能用递归，只能用循环。<br>63、一个文件中有 100 万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。 说出最优的方法<br>64、2000 万个整数，找出第五十大的数字？<br>65、烧一根不均匀的绳，从头烧到尾总共需要 1 个小时。现在有若干条材质相同的绳子，问如 何用烧绳的方法来计时一个小时十五分钟呢？<br>66、求 1000 以内的水仙花数以及 40 亿以内的水仙花数<br>67、称重问题：10 个箱子，每个箱子里都有若干砖头，其中有一个箱子里每个砖头重 9 克，其 他的箱子里的砖头每个重 10 克，给你一个秤，要求只能用一次称重找出砖头重 9 克的箱子。<br>68、时针走一圈，时针分针重合几次<br>69、N*N 的方格纸,里面有多少个正方形<br>70、标号 1-n 的 n 个人首尾相接，1 到 3 报数，报到 3 的退出，求最后一个人的标号<br>71、给定一个字符串，求第一个不重复的字符 abbcad -&gt; c<br>72、上网站写代码，如下： 有一个容器类 ArrayList，保存整数类型的元素，现在要求编写一 个帮助类，类内提供一个帮助函数，帮助函数的功能是删除 容器中&lt;10 的元素。<br>73、写代码，LeetCode 上股票利益最大化问题<br>74、写代码，剑指 offer 上第一次只出现一次的字符<br>75、算法：连续子数组的最大和<br>76、子串包含问题(KMP 算法)写代码实现<br>77、ViewGroup 的层级深度，转换为二叉树的层级深度<br>78、String 字符串的数字相加<br>79、使用三个线程顺序打印有序的数组<br>80、给定一个有序的数组和目标数，找出与目标数最近接的 index，要求复杂度是 log(n)的时 间复杂度<br>81、给定一个二叉树和一个目标数，在二叉树中是否存在一条路径的所有节点的和与目标数是 相同的 case，并且打印。<br>82、二叉树，读取每一层最右边的节点<br>83、int 数组，除了一个数字外，其他数字都出现两次，找出这个只出现一次的数字<br>84、一个类，内部有一个链表的数据结构，实现 void add(Node n)和 void remove(int index) 的函数<br>85、手写消费者生产者模型的代码<br>86、一个无序的 int 数组，给一个 target 数字，找出数组中两个数字相加为 target，并输出坐 标<br>87、数组中存有 1-3 的三种数字,例如[1,2,3,1,2,2,1,3,3]，将其排序为[1,1,1,2,2,2,3,3,3]， 要求时间复杂度，后续将内容变为一个对象，继续排序<br>88、”之”字形打印二叉树<br>89、1~100 盏灯，都是亮的，第一次将能被 1 整除的数的灯按下，变暗，第二次将能被 2 整除的 数的等按下，变亮，第三次将能被 3 整除的数的等按下，变暗…第 100 次将能被 100 整除的数 的灯按下，问，最后有多少盏灯是亮的。<br>90、实现一个 o(n）复杂度的堆和最大数。<br>91、实现一个数组的窗口扫描算法。<br>92、识别一个字符串是否是 ipv4 地址。<br>93、o(n)复杂度实现偶数递增奇数递减单向链接排序。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Summer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://skyskiper.github.io/2021/Android%E5%B0%8F%E6%8A%84/">https://skyskiper.github.io/2021/Android%E5%B0%8F%E6%8A%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://skyskiper.github.io">阿七笔记</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/Android%E7%83%AD%E9%A2%98%E7%AD%94%E6%A1%88/"><span>Android热题答案</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Summer</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>